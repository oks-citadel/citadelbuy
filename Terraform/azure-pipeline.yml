# ===================================================================
# AZURE DEVOPS PIPELINE - Global Commerce Platform
# ===================================================================
# This pipeline handles:
# 1. Building and testing microservices
# 2. Building Docker images
# 3. Infrastructure deployment via Terraform
# 4. Application deployment
# 5. Health checks and smoke tests
# ===================================================================

name: $(BuildDefinitionName)_$(Date:yyyyMMdd)$(Rev:.r)

trigger:
  branches:
    include:
      - main
      - develop
      - release/*
  paths:
    exclude:
      - docs/**
      - README.md

pr:
  branches:
    include:
      - main
      - develop
  paths:
    exclude:
      - docs/**
      - README.md

variables:
  - name: dockerRegistryServiceConnection
    value: 'ACR-ServiceConnection'
  - name: terraformVersion
    value: '1.5.7'
  - name: nodeVersion
    value: '18.x'
  - name: azureSubscription
    value: 'Azure-Production-Subscription'
  
  # Container Registry
  - name: containerRegistry
    value: '$(acrLoginServer)'
  
  # Build Configuration
  - name: buildConfiguration
    value: 'Release'
  
  # Terraform Backend
  - name: terraformBackendResourceGroup
    value: 'terraform-state-rg'
  - name: terraformBackendStorageAccount
    value: 'tfstateglobalcommerce'
  - name: terraformBackendContainerName
    value: 'tfstate'

stages:
# ===================================================================
# STAGE 1: BUILD & TEST
# ===================================================================
- stage: Build
  displayName: 'Build & Test'
  jobs:
  - job: BuildServices
    displayName: 'Build Microservices'
    pool:
      vmImage: 'ubuntu-latest'
    
    strategy:
      matrix:
        apiGateway:
          serviceName: 'api-gateway'
          serviceDir: 'backend/api-gateway'
        authService:
          serviceName: 'auth-service'
          serviceDir: 'backend/services/auth-service'
        userService:
          serviceName: 'user-service'
          serviceDir: 'backend/services/user-service'
        productService:
          serviceName: 'product-service'
          serviceDir: 'backend/services/product-service'
        orderService:
          serviceName: 'order-service'
          serviceDir: 'backend/services/order-service'
        paymentService:
          serviceName: 'payment-service'
          serviceDir: 'backend/services/payment-service'
        inventoryService:
          serviceName: 'inventory-service'
          serviceDir: 'backend/services/inventory-service'
        shippingService:
          serviceName: 'shipping-service'
          serviceDir: 'backend/services/shipping-service'
        notificationService:
          serviceName: 'notification-service'
          serviceDir: 'backend/services/notification-service'
        searchService:
          serviceName: 'search-service'
          serviceDir: 'backend/services/search-service'
        analyticsService:
          serviceName: 'analytics-service'
          serviceDir: 'backend/services/analytics-service'
        aiService:
          serviceName: 'ai-service'
          serviceDir: 'backend/services/ai-service'
        vendorService:
          serviceName: 'vendor-service'
          serviceDir: 'backend/services/vendor-service'
    
    steps:
    - task: NodeTool@0
      inputs:
        versionSpec: $(nodeVersion)
      displayName: 'Install Node.js'
    
    - script: |
        cd $(serviceDir)
        npm ci
        npm run lint
        npm run test:unit
        npm run build
      displayName: 'Build and Test $(serviceName)'
    
    - task: PublishTestResults@2
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: '$(serviceDir)/**/test-results.xml'
        mergeTestResults: true
        failTaskOnFailedTests: true
      displayName: 'Publish Test Results'
    
    - task: PublishCodeCoverageResults@1
      inputs:
        codeCoverageTool: 'Cobertura'
        summaryFileLocation: '$(serviceDir)/**/coverage/cobertura-coverage.xml'
      displayName: 'Publish Code Coverage'

  - job: BuildFrontend
    displayName: 'Build Frontend'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - task: NodeTool@0
      inputs:
        versionSpec: $(nodeVersion)
      displayName: 'Install Node.js'
    
    - script: |
        cd frontend/web
        npm ci
        npm run lint
        npm run test
        npm run build
      displayName: 'Build Web Application'
    
    - task: PublishBuildArtifacts@1
      inputs:
        PathtoPublish: 'frontend/web/dist'
        ArtifactName: 'web-dist'
      displayName: 'Publish Web Artifacts'

# ===================================================================
# STAGE 2: BUILD & PUSH DOCKER IMAGES
# ===================================================================
- stage: DockerBuild
  displayName: 'Build Docker Images'
  dependsOn: Build
  jobs:
  - job: BuildImages
    displayName: 'Build and Push Docker Images'
    pool:
      vmImage: 'ubuntu-latest'
    
    strategy:
      matrix:
        apiGateway:
          serviceName: 'api-gateway'
          dockerfile: 'backend/api-gateway/Dockerfile'
        authService:
          serviceName: 'auth-service'
          dockerfile: 'backend/services/auth-service/Dockerfile'
        userService:
          serviceName: 'user-service'
          dockerfile: 'backend/services/user-service/Dockerfile'
        productService:
          serviceName: 'product-service'
          dockerfile: 'backend/services/product-service/Dockerfile'
        orderService:
          serviceName: 'order-service'
          dockerfile: 'backend/services/order-service/Dockerfile'
        paymentService:
          serviceName: 'payment-service'
          dockerfile: 'backend/services/payment-service/Dockerfile'
        inventoryService:
          serviceName: 'inventory-service'
          dockerfile: 'backend/services/inventory-service/Dockerfile'
        shippingService:
          serviceName: 'shipping-service'
          dockerfile: 'backend/services/shipping-service/Dockerfile'
        notificationService:
          serviceName: 'notification-service'
          dockerfile: 'backend/services/notification-service/Dockerfile'
        searchService:
          serviceName: 'search-service'
          dockerfile: 'backend/services/search-service/Dockerfile'
        analyticsService:
          serviceName: 'analytics-service'
          dockerfile: 'backend/services/analytics-service/Dockerfile'
        aiService:
          serviceName: 'ai-service'
          dockerfile: 'backend/services/ai-service/Dockerfile'
        vendorService:
          serviceName: 'vendor-service'
          dockerfile: 'backend/services/vendor-service/Dockerfile'
    
    steps:
    - task: Docker@2
      displayName: 'Build $(serviceName) Image'
      inputs:
        command: build
        repository: $(serviceName)
        dockerfile: $(dockerfile)
        tags: |
          $(Build.BuildId)
          latest
    
    - task: Docker@2
      displayName: 'Push $(serviceName) to ACR'
      inputs:
        command: push
        containerRegistry: $(dockerRegistryServiceConnection)
        repository: $(serviceName)
        tags: |
          $(Build.BuildId)
          latest

# ===================================================================
# STAGE 3: DEPLOY TO DEV
# ===================================================================
- stage: DeployDev
  displayName: 'Deploy to Dev'
  dependsOn: DockerBuild
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/develop'))
  
  variables:
    - group: 'dev-environment-variables'
    - name: environment
      value: 'dev'
  
  jobs:
  - deployment: DeployInfrastructure
    displayName: 'Deploy Infrastructure'
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'dev'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
          
          - task: TerraformInstaller@0
            displayName: 'Install Terraform'
            inputs:
              terraformVersion: $(terraformVersion)
          
          - task: TerraformTaskV4@4
            displayName: 'Terraform Init'
            inputs:
              provider: 'azurerm'
              command: 'init'
              workingDirectory: '$(System.DefaultWorkingDirectory)/infrastructure/terraform'
              backendServiceArm: $(azureSubscription)
              backendAzureRmResourceGroupName: $(terraformBackendResourceGroup)
              backendAzureRmStorageAccountName: $(terraformBackendStorageAccount)
              backendAzureRmContainerName: $(terraformBackendContainerName)
              backendAzureRmKey: 'dev.terraform.tfstate'
          
          - task: TerraformTaskV4@4
            displayName: 'Terraform Plan'
            inputs:
              provider: 'azurerm'
              command: 'plan'
              workingDirectory: '$(System.DefaultWorkingDirectory)/infrastructure/terraform'
              commandOptions: '-var-file="terraform.dev.tfvars" -var="db_admin_username=$(DB_ADMIN_USERNAME)" -var="db_admin_password=$(DB_ADMIN_PASSWORD)" -var="apim_publisher_email=$(APIM_PUBLISHER_EMAIL)" -out=tfplan'
              environmentServiceNameAzureRM: $(azureSubscription)
          
          - task: TerraformTaskV4@4
            displayName: 'Terraform Apply'
            inputs:
              provider: 'azurerm'
              command: 'apply'
              workingDirectory: '$(System.DefaultWorkingDirectory)/infrastructure/terraform'
              commandOptions: 'tfplan'
              environmentServiceNameAzureRM: $(azureSubscription)
  
  - deployment: DeployApplications
    displayName: 'Deploy Applications'
    dependsOn: DeployInfrastructure
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'dev'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: AzureWebAppContainer@1
            displayName: 'Deploy API Gateway'
            inputs:
              azureSubscription: $(azureSubscription)
              appName: 'globalcommerce-dev-api-gateway'
              imageName: '$(containerRegistry)/api-gateway:$(Build.BuildId)'
          
          # Add similar tasks for other services...
          
          - script: |
              echo "Running database migrations..."
              # Add migration scripts here
            displayName: 'Run Database Migrations'
  
  - job: SmokeTests
    displayName: 'Run Smoke Tests'
    dependsOn: DeployApplications
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - script: |
        echo "Running smoke tests..."
        # Add smoke test scripts here
      displayName: 'Execute Smoke Tests'

# ===================================================================
# STAGE 4: DEPLOY TO TEST
# ===================================================================
- stage: DeployTest
  displayName: 'Deploy to Test'
  dependsOn: DeployDev
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/develop'))
  
  variables:
    - group: 'test-environment-variables'
    - name: environment
      value: 'test'
  
  jobs:
  - deployment: DeployInfrastructure
    displayName: 'Deploy Infrastructure'
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'test'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
          
          - task: TerraformInstaller@0
            displayName: 'Install Terraform'
            inputs:
              terraformVersion: $(terraformVersion)
          
          - task: TerraformTaskV4@4
            displayName: 'Terraform Init'
            inputs:
              provider: 'azurerm'
              command: 'init'
              workingDirectory: '$(System.DefaultWorkingDirectory)/infrastructure/terraform'
              backendServiceArm: $(azureSubscription)
              backendAzureRmResourceGroupName: $(terraformBackendResourceGroup)
              backendAzureRmStorageAccountName: $(terraformBackendStorageAccount)
              backendAzureRmContainerName: $(terraformBackendContainerName)
              backendAzureRmKey: 'test.terraform.tfstate'
          
          - task: TerraformTaskV4@4
            displayName: 'Terraform Plan'
            inputs:
              provider: 'azurerm'
              command: 'plan'
              workingDirectory: '$(System.DefaultWorkingDirectory)/infrastructure/terraform'
              commandOptions: '-var-file="terraform.test.tfvars" -var="db_admin_username=$(DB_ADMIN_USERNAME)" -var="db_admin_password=$(DB_ADMIN_PASSWORD)" -var="apim_publisher_email=$(APIM_PUBLISHER_EMAIL)" -out=tfplan'
              environmentServiceNameAzureRM: $(azureSubscription)
          
          - task: TerraformTaskV4@4
            displayName: 'Terraform Apply'
            inputs:
              provider: 'azurerm'
              command: 'apply'
              workingDirectory: '$(System.DefaultWorkingDirectory)/infrastructure/terraform'
              commandOptions: 'tfplan'
              environmentServiceNameAzureRM: $(azureSubscription)
  
  - deployment: DeployApplications
    displayName: 'Deploy Applications'
    dependsOn: DeployInfrastructure
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'test'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: AzureWebAppContainer@1
            displayName: 'Deploy API Gateway'
            inputs:
              azureSubscription: $(azureSubscription)
              appName: 'globalcommerce-test-api-gateway'
              imageName: '$(containerRegistry)/api-gateway:$(Build.BuildId)'
  
  - job: IntegrationTests
    displayName: 'Run Integration Tests'
    dependsOn: DeployApplications
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - script: |
        echo "Running integration tests..."
        # Add integration test scripts here
      displayName: 'Execute Integration Tests'

# ===================================================================
# STAGE 5: DEPLOY TO PRODUCTION
# ===================================================================
- stage: DeployProduction
  displayName: 'Deploy to Production'
  dependsOn: DeployTest
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  
  variables:
    - group: 'production-environment-variables'
    - name: environment
      value: 'production'
  
  jobs:
  - deployment: DeployInfrastructure
    displayName: 'Deploy Infrastructure'
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'production'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
          
          - task: TerraformInstaller@0
            displayName: 'Install Terraform'
            inputs:
              terraformVersion: $(terraformVersion)
          
          - task: TerraformTaskV4@4
            displayName: 'Terraform Init'
            inputs:
              provider: 'azurerm'
              command: 'init'
              workingDirectory: '$(System.DefaultWorkingDirectory)/infrastructure/terraform'
              backendServiceArm: $(azureSubscription)
              backendAzureRmResourceGroupName: $(terraformBackendResourceGroup)
              backendAzureRmStorageAccountName: $(terraformBackendStorageAccount)
              backendAzureRmContainerName: $(terraformBackendContainerName)
              backendAzureRmKey: 'production.terraform.tfstate'
          
          - task: TerraformTaskV4@4
            displayName: 'Terraform Plan'
            inputs:
              provider: 'azurerm'
              command: 'plan'
              workingDirectory: '$(System.DefaultWorkingDirectory)/infrastructure/terraform'
              commandOptions: '-var-file="terraform.production.tfvars" -var="db_admin_username=$(DB_ADMIN_USERNAME)" -var="db_admin_password=$(DB_ADMIN_PASSWORD)" -var="apim_publisher_email=$(APIM_PUBLISHER_EMAIL)" -out=tfplan'
              environmentServiceNameAzureRM: $(azureSubscription)
          
          - task: TerraformTaskV4@4
            displayName: 'Terraform Apply'
            inputs:
              provider: 'azurerm'
              command: 'apply'
              workingDirectory: '$(System.DefaultWorkingDirectory)/infrastructure/terraform'
              commandOptions: 'tfplan'
              environmentServiceNameAzureRM: $(azureSubscription)
  
  - deployment: DeployApplicationsBlueGreen
    displayName: 'Deploy Applications (Blue-Green)'
    dependsOn: DeployInfrastructure
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'production'
    strategy:
      runOnce:
        deploy:
          steps:
          # Blue-Green deployment to staging slot
          - task: AzureWebAppContainer@1
            displayName: 'Deploy to Staging Slot'
            inputs:
              azureSubscription: $(azureSubscription)
              appName: 'globalcommerce-production-api-gateway'
              slotName: 'staging'
              imageName: '$(containerRegistry)/api-gateway:$(Build.BuildId)'
          
          # Warm up staging slot
          - script: |
              echo "Warming up staging slot..."
              curl -f https://globalcommerce-production-api-gateway-staging.azurewebsites.net/health || exit 1
            displayName: 'Warm Up Staging Slot'
          
          # Run smoke tests on staging
          - script: |
              echo "Running smoke tests on staging..."
              # Add smoke tests
            displayName: 'Smoke Tests on Staging'
          
          # Swap slots
          - task: AzureAppServiceManage@0
            displayName: 'Swap Slots'
            inputs:
              azureSubscription: $(azureSubscription)
              Action: 'Swap Slots'
              WebAppName: 'globalcommerce-production-api-gateway'
              ResourceGroupName: 'globalcommerce-production-rg'
              SourceSlot: 'staging'
  
  - job: ProductionSmokeTests
    displayName: 'Production Smoke Tests'
    dependsOn: DeployApplicationsBlueGreen
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - script: |
        echo "Running production smoke tests..."
        # Add production smoke test scripts
      displayName: 'Execute Production Smoke Tests'
  
  - job: NotifyTeam
    displayName: 'Notify Team'
    dependsOn: ProductionSmokeTests
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: SendEmail@1
      inputs:
        To: 'platform-team@company.com'
        Subject: 'Production Deployment Successful - Build $(Build.BuildId)'
        Body: 'The Global Commerce Platform has been successfully deployed to production.'
