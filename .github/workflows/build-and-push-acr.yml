name: Build and Push to ACR

on:
  push:
    branches:
      - main
      - develop
    paths:
      - 'organization/apps/**'
      - 'organization/packages/**'
      - '**/Dockerfile*'
      - '.github/workflows/build-and-push-acr.yml'
  workflow_dispatch:
    inputs:
      services:
        description: 'Services to build (comma-separated or "all")'
        required: false
        default: 'api,web'
        type: string

env:
  REGISTRY: broxivaacr.azurecr.io
  AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

jobs:
  prepare-matrix:
    name: Prepare Build Matrix
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      version: ${{ steps.version.outputs.version }}
      environment: ${{ steps.environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine environment
        id: environment
        run: |
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/develop" ]; then
            echo "environment=development" >> $GITHUB_OUTPUT
          else
            echo "environment=development" >> $GITHUB_OUTPUT
          fi

      - name: Generate semantic version
        id: version
        run: |
          # Get the latest tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")

          # Remove 'v' prefix if present
          VERSION=${LATEST_TAG#v}

          # Increment patch version
          IFS='.' read -ra VERSION_PARTS <<< "$VERSION"
          MAJOR=${VERSION_PARTS[0]:-0}
          MINOR=${VERSION_PARTS[1]:-0}
          PATCH=${VERSION_PARTS[2]:-0}

          # Increment based on branch
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            PATCH=$((PATCH + 1))
            NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          else
            # For develop, use pre-release version
            COMMIT_COUNT=$(git rev-list --count HEAD)
            NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}-dev.${COMMIT_COUNT}"
          fi

          echo "version=${NEW_VERSION}" >> $GITHUB_OUTPUT
          echo "Generated version: ${NEW_VERSION}"

      - name: Set matrix
        id: set-matrix
        run: |
          MATRIX='{"include":[{"name":"api","context":"./organization","dockerfile":"./organization/apps/api/Dockerfile","image":"broxiva-api"},{"name":"web","context":"./organization","dockerfile":"./organization/apps/web/Dockerfile","image":"broxiva-web"}]}'
          echo "matrix=$MATRIX" >> $GITHUB_OUTPUT
          echo "Matrix: $MATRIX"

  build-and-push:
    name: Build & Push ${{ matrix.name }}
    runs-on: ubuntu-latest
    needs: prepare-matrix
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.prepare-matrix.outputs.matrix) }}

    permissions:
      contents: read
      id-token: write
      packages: write
      security-events: write
      attestations: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            image=moby/buildkit:latest
            network=host

      - name: Azure login via OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Login to Azure Container Registry
        run: |
          az acr login --name broxivaacr

      - name: Generate image metadata
        id: meta
        run: |
          # Generate short SHA
          SHORT_SHA=$(git rev-parse --short HEAD)
          echo "short_sha=${SHORT_SHA}" >> $GITHUB_OUTPUT

          # Get branch name
          BRANCH_NAME=${GITHUB_REF#refs/heads/}
          BRANCH_NAME=$(echo $BRANCH_NAME | sed 's/[^a-zA-Z0-9._-]/-/g')
          echo "branch=${BRANCH_NAME}" >> $GITHUB_OUTPUT

          # Get version
          VERSION="${{ needs.prepare-matrix.outputs.version }}"
          echo "version=${VERSION}" >> $GITHUB_OUTPUT

          # Generate tags
          BASE_IMAGE="${{ env.REGISTRY }}/${{ matrix.image }}"
          TAGS="${BASE_IMAGE}:${SHORT_SHA}"
          TAGS="${TAGS},${BASE_IMAGE}:${BRANCH_NAME}"
          TAGS="${TAGS},${BASE_IMAGE}:${VERSION}"

          # Add 'latest' tag for main branch
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            TAGS="${TAGS},${BASE_IMAGE}:latest"
          fi

          # Add 'develop' tag for develop branch
          if [ "${{ github.ref }}" = "refs/heads/develop" ]; then
            TAGS="${TAGS},${BASE_IMAGE}:develop"
          fi

          echo "tags=${TAGS}" >> $GITHUB_OUTPUT
          echo "build_date=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_OUTPUT

          # Print tags for debugging
          echo "Generated tags:"
          echo "${TAGS}" | tr ',' '\n'

      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ matrix.name }}-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-${{ matrix.name }}-
            ${{ runner.os }}-buildx-

      - name: Build and push Docker image
        id: build-push
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.dockerfile }}
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new,mode=max
          provenance: true
          sbom: true
          build-args: |
            BUILD_DATE=${{ steps.meta.outputs.build_date }}
            VCS_REF=${{ steps.meta.outputs.short_sha }}
            VERSION=${{ steps.meta.outputs.version }}
            ENVIRONMENT=${{ needs.prepare-matrix.outputs.environment }}
          labels: |
            org.opencontainers.image.title=${{ matrix.name }}
            org.opencontainers.image.description=Broxiva ${{ matrix.name }} service
            org.opencontainers.image.url=https://github.com/${{ github.repository }}
            org.opencontainers.image.source=https://github.com/${{ github.repository }}
            org.opencontainers.image.version=${{ steps.meta.outputs.version }}
            org.opencontainers.image.created=${{ steps.meta.outputs.build_date }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.licenses=MIT
            com.broxiva.environment=${{ needs.prepare-matrix.outputs.environment }}
            com.broxiva.service=${{ matrix.name }}

      - name: Move cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

      - name: Pull image for scanning
        run: |
          docker pull ${{ env.REGISTRY }}/${{ matrix.image }}:${{ steps.meta.outputs.short_sha }}

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ matrix.image }}:${{ steps.meta.outputs.short_sha }}
          format: 'sarif'
          output: 'trivy-results-${{ matrix.name }}.sarif'
          severity: 'CRITICAL,HIGH,MEDIUM'
          timeout: '10m'
          vuln-type: 'os,library'
          scanners: 'vuln,secret,config'

      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results-${{ matrix.name }}.sarif'
          category: 'trivy-${{ matrix.name }}'

      - name: Run Trivy vulnerability scanner (JSON output)
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ matrix.image }}:${{ steps.meta.outputs.short_sha }}
          format: 'json'
          output: 'trivy-results-${{ matrix.name }}.json'
          severity: 'CRITICAL,HIGH,MEDIUM,LOW'
          timeout: '10m'

      - name: Upload Trivy JSON results
        uses: actions/upload-artifact@v4
        with:
          name: trivy-results-${{ matrix.name }}
          path: trivy-results-${{ matrix.name }}.json
          retention-days: 30

      - name: Generate SBOM with Syft
        uses: anchore/sbom-action@v0
        with:
          image: ${{ env.REGISTRY }}/${{ matrix.image }}:${{ steps.meta.outputs.short_sha }}
          format: 'spdx-json'
          output-file: 'sbom-${{ matrix.name }}.spdx.json'
          upload-artifact: false
          upload-release-assets: false

      - name: Generate SBOM with CycloneDX
        uses: anchore/sbom-action@v0
        with:
          image: ${{ env.REGISTRY }}/${{ matrix.image }}:${{ steps.meta.outputs.short_sha }}
          format: 'cyclonedx-json'
          output-file: 'sbom-${{ matrix.name }}.cyclonedx.json'
          upload-artifact: false
          upload-release-assets: false

      - name: Upload SBOM artifacts
        uses: actions/upload-artifact@v4
        with:
          name: sbom-${{ matrix.name }}
          path: |
            sbom-${{ matrix.name }}.spdx.json
            sbom-${{ matrix.name }}.cyclonedx.json
          retention-days: 90

      - name: Sign image with Cosign
        if: github.ref == 'refs/heads/main'
        run: |
          # Install cosign
          curl -sLO https://github.com/sigstore/cosign/releases/latest/download/cosign-linux-amd64
          chmod +x cosign-linux-amd64
          sudo mv cosign-linux-amd64 /usr/local/bin/cosign

          # Sign the image
          cosign sign --yes ${{ env.REGISTRY }}/${{ matrix.image }}@${{ steps.build-push.outputs.digest }}

      - name: Generate attestation
        if: github.ref == 'refs/heads/main'
        uses: actions/attest-build-provenance@v1
        with:
          subject-name: ${{ env.REGISTRY }}/${{ matrix.image }}
          subject-digest: ${{ steps.build-push.outputs.digest }}
          push-to-registry: true

      - name: Image size and layers report
        run: |
          echo "### Docker Image Report for ${{ matrix.name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ needs.prepare-matrix.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ steps.meta.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**SHA:** ${{ steps.meta.outputs.short_sha }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Tags:**" >> $GITHUB_STEP_SUMMARY
          echo '${{ steps.meta.outputs.tags }}' | tr ',' '\n' | sed 's/^/- /' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Image Digest:** ${{ steps.build-push.outputs.digest }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          docker images ${{ env.REGISTRY }}/${{ matrix.image }}:${{ steps.meta.outputs.short_sha }} --format "**Size:** {{.Size}}" >> $GITHUB_STEP_SUMMARY

      - name: Scan summary
        run: |
          if [ -f trivy-results-${{ matrix.name }}.json ]; then
            CRITICAL=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity=="CRITICAL")] | length' trivy-results-${{ matrix.name }}.json)
            HIGH=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity=="HIGH")] | length' trivy-results-${{ matrix.name }}.json)
            MEDIUM=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity=="MEDIUM")] | length' trivy-results-${{ matrix.name }}.json)

            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Security Scan Results:**" >> $GITHUB_STEP_SUMMARY
            echo "- Critical: ${CRITICAL}" >> $GITHUB_STEP_SUMMARY
            echo "- High: ${HIGH}" >> $GITHUB_STEP_SUMMARY
            echo "- Medium: ${MEDIUM}" >> $GITHUB_STEP_SUMMARY

            # Fail if critical vulnerabilities found
            if [ "$CRITICAL" -gt 0 ]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "⚠️ **WARNING:** Critical vulnerabilities found!" >> $GITHUB_STEP_SUMMARY
            fi
          fi

  tag-release:
    name: Tag Release
    runs-on: ubuntu-latest
    needs: [prepare-matrix, build-and-push]
    if: github.ref == 'refs/heads/main'
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create and push tag
        run: |
          VERSION="${{ needs.prepare-matrix.outputs.version }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "v${VERSION}" -m "Release version ${VERSION}"
          git push origin "v${VERSION}"

      - name: Create GitHub Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ needs.prepare-matrix.outputs.version }}
          release_name: Release v${{ needs.prepare-matrix.outputs.version }}
          body: |
            ## Release v${{ needs.prepare-matrix.outputs.version }}

            ### Docker Images
            All images have been built and pushed to Azure Container Registry:
            - `broxivaacr.azurecr.io/broxiva-api:${{ needs.prepare-matrix.outputs.version }}`
            - `broxivaacr.azurecr.io/broxiva-web:${{ needs.prepare-matrix.outputs.version }}`

            ### Changes
            See commit history for detailed changes.
          draft: false
          prerelease: false

  summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [prepare-matrix, build-and-push]
    if: always()
    steps:
      - name: Generate summary
        run: |
          echo "## Build and Push Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ needs.prepare-matrix.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.prepare-matrix.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${GITHUB_REF#refs/heads/}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${GITHUB_SHA:0:7}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ needs.build-and-push.result }}" = "success" ]; then
            echo "### ✅ All images successfully built and pushed to ACR" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Images are available at: \`broxivaacr.azurecr.io\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Services deployed:**" >> $GITHUB_STEP_SUMMARY
            echo "- broxiva-api" >> $GITHUB_STEP_SUMMARY
            echo "- broxiva-web" >> $GITHUB_STEP_SUMMARY
          else
            echo "### ❌ Some builds failed" >> $GITHUB_STEP_SUMMARY
            echo "Please check the individual job logs for details." >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [prepare-matrix, build-and-push]
    if: always()
    steps:
      - name: Notify on success
        if: needs.build-and-push.result == 'success'
        run: |
          echo "All images successfully built and pushed to ACR"
          # Add your notification logic here (Slack, Teams, etc.)

      - name: Notify on failure
        if: needs.build-and-push.result == 'failure'
        run: |
          echo "Build or push failed"
          # Add your notification logic here (Slack, Teams, etc.)
