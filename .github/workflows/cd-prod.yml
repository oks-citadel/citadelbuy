name: Deploy to Production AKS - Blue-Green

on:
  push:
    branches:
      - main
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.github/ISSUE_TEMPLATE/**'
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Image tag to deploy (must be from staging)'
        required: true
        type: string
      skip_approval:
        description: 'Skip manual approval (NOT RECOMMENDED)'
        required: false
        type: boolean
        default: false
      deployment_strategy:
        description: 'Deployment strategy'
        required: false
        type: choice
        options:
          - blue-green
          - rolling
        default: blue-green

env:
  AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  AKS_CLUSTER_NAME: citadelbuy-prod-aks
  AKS_RESOURCE_GROUP: citadelbuy-prod-rg
  KUBERNETES_NAMESPACE: citadelbuy-production
  CONTAINER_REGISTRY: ghcr.io/citadelplatforms
  KUSTOMIZE_VERSION: 'v5.3.0'

permissions:
  id-token: write
  contents: read
  packages: read
  deployments: write

jobs:
  pre-deployment-validation:
    name: Pre-Deployment Validation
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9
          run_install: false

      - name: Validate version tag
        run: |
          if [ "${{ github.event.inputs.image_tag }}" == "" ]; then
            echo "Error: Image tag is required for production deployment"
            exit 1
          fi

          TAG="${{ github.event.inputs.image_tag }}"
          if [[ ! "$TAG" =~ ^(v[0-9]+\.[0-9]+\.[0-9]+|staging-.*)$ ]]; then
            echo "Error: Image tag must be a semantic version (v1.2.3) or from staging"
            exit 1
          fi

      - name: Verify staging deployment
        run: |
          echo "Verifying that this version was deployed to staging first..."
          # Add verification logic to check staging deployment history

      - name: Validate Kubernetes manifests
        run: |
          cd infrastructure/kubernetes/production
          if [ -f validate-manifests.sh ]; then
            chmod +x validate-manifests.sh
            ./validate-manifests.sh
          fi

      - name: Security scan manifests
        run: |
          cd infrastructure/kubernetes
          if [ -f verify-security.sh ]; then
            chmod +x verify-security.sh
            ./verify-security.sh
          fi

      - name: Check image availability
        run: |
          echo "Verifying container images exist..."
          TAG="${{ github.event.inputs.image_tag }}"

          # Check if images exist in registry
          docker manifest inspect ${{ env.CONTAINER_REGISTRY }}/citadelbuy-api:$TAG || exit 1
          docker manifest inspect ${{ env.CONTAINER_REGISTRY }}/citadelbuy-web:$TAG || exit 1
          docker manifest inspect ${{ env.CONTAINER_REGISTRY }}/citadelbuy-worker:$TAG || exit 1

      - name: Run security vulnerability scan
        run: |
          echo "Scanning images for vulnerabilities..."
          # Add container vulnerability scanning here (e.g., Trivy, Snyk)

      - name: Lint Kustomize files
        run: |
          curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash -s -- ${{ env.KUSTOMIZE_VERSION }}
          ./kustomize build infrastructure/kubernetes/production > /dev/null

  approval:
    name: Production Deployment Approval
    needs: pre-deployment-validation
    runs-on: ubuntu-latest
    environment:
      name: production-approval
    if: github.event.inputs.skip_approval != 'true'

    steps:
      - name: Approval checkpoint
        run: |
          echo "================================================"
          echo "PRODUCTION DEPLOYMENT APPROVED"
          echo "================================================"
          echo "Approved by: ${{ github.actor }}"
          echo "Image tag: ${{ github.event.inputs.image_tag }}"
          echo "Strategy: ${{ github.event.inputs.deployment_strategy || 'blue-green' }}"
          echo "Timestamp: $(date)"
          echo "================================================"

      - name: Create deployment issue
        uses: actions/github-script@v7
        with:
          script: |
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Production Deployment - ${{ github.event.inputs.image_tag }}`,
              body: `## Production Deployment\n\n- **Image Tag:** ${{ github.event.inputs.image_tag }}\n- **Approved by:** ${{ github.actor }}\n- **Strategy:** ${{ github.event.inputs.deployment_strategy || 'blue-green' }}\n- **Workflow Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`,
              labels: ['deployment', 'production']
            });

  deploy-green:
    name: Deploy Green Environment
    needs: [pre-deployment-validation, approval]
    runs-on: ubuntu-latest
    if: |
      always() &&
      (needs.approval.result == 'success' || needs.approval.result == 'skipped') &&
      (github.event.inputs.deployment_strategy == 'blue-green' || github.event.inputs.deployment_strategy == '')
    environment:
      name: production
      url: https://citadelbuy.com

    outputs:
      deployment-id: ${{ steps.deployment-info.outputs.deployment-id }}
      image-tag: ${{ steps.image-tag.outputs.tag }}
      green-deployed: ${{ steps.green-status.outputs.success }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci
        working-directory: ./apps/api

      - name: Azure Login via OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Set AKS context
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ env.AKS_RESOURCE_GROUP }}
          cluster-name: ${{ env.AKS_CLUSTER_NAME }}
          admin: 'false'

      - name: Install kubelogin
        run: |
          curl -LO https://github.com/Azure/kubelogin/releases/download/v0.1.1/kubelogin-linux-amd64.zip
          unzip kubelogin-linux-amd64.zip
          sudo mv bin/linux_amd64/kubelogin /usr/local/bin/
          rm -rf bin kubelogin-linux-amd64.zip

      - name: Configure kubectl with kubelogin
        run: |
          kubelogin convert-kubeconfig -l azurecli
          kubectl config set-context --current --namespace=${{ env.KUBERNETES_NAMESPACE }}

      - name: Verify cluster connection
        run: |
          kubectl cluster-info
          kubectl get nodes
          kubectl get namespaces

      - name: Install Kustomize
        run: |
          curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash -s -- ${{ env.KUSTOMIZE_VERSION }}
          sudo mv kustomize /usr/local/bin/

      - name: Set image tag
        id: image-tag
        run: |
          TAG="${{ github.event.inputs.image_tag }}"
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "Deploying image tag: $TAG"

      - name: Create namespace if not exists
        run: |
          kubectl create namespace ${{ env.KUBERNETES_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Backup current deployment state
        id: backup
        run: |
          BACKUP_DIR="backups/prod-$(date +%Y%m%d-%H%M%S)"
          mkdir -p $BACKUP_DIR

          kubectl get all -n ${{ env.KUBERNETES_NAMESPACE }} -o yaml > $BACKUP_DIR/current-state.yaml
          kubectl get configmaps -n ${{ env.KUBERNETES_NAMESPACE }} -o yaml > $BACKUP_DIR/configmaps.yaml
          kubectl get secrets -n ${{ env.KUBERNETES_NAMESPACE }} -o yaml > $BACKUP_DIR/secrets.yaml
          kubectl get ingress -n ${{ env.KUBERNETES_NAMESPACE }} -o yaml > $BACKUP_DIR/ingress.yaml

          echo "backup-dir=$BACKUP_DIR" >> $GITHUB_OUTPUT
          echo "Backup created at: $BACKUP_DIR"

      - name: Detect current deployment color
        id: current-color
        run: |
          CURRENT_COLOR=$(kubectl get service citadelbuy-api -n ${{ env.KUBERNETES_NAMESPACE }} -o jsonpath='{.spec.selector.color}' 2>/dev/null || echo "blue")
          if [ "$CURRENT_COLOR" == "blue" ]; then
            NEW_COLOR="green"
          else
            NEW_COLOR="blue"
          fi

          echo "current=$CURRENT_COLOR" >> $GITHUB_OUTPUT
          echo "new=$NEW_COLOR" >> $GITHUB_OUTPUT

          echo "Current active color: $CURRENT_COLOR"
          echo "New deployment color: $NEW_COLOR"

      - name: Run database migrations
        env:
          DATABASE_URL: ${{ secrets.PROD_DATABASE_URL }}
        run: |
          cd apps/api
          echo "Running Prisma migrations on production database..."

          # Create migration backup
          echo "Creating database backup before migration..."
          # Add your backup logic here

          # Run migrations
          npx prisma migrate deploy --schema=./prisma/schema.prisma
          npx prisma migrate deploy --schema=./prisma/schema-organization.prisma
          npx prisma migrate deploy --schema=./prisma/schema-dropshipping.prisma
          npx prisma migrate deploy --schema=./prisma/schema-privacy.prisma

          echo "Migrations completed successfully"
        continue-on-error: false

      - name: Generate Prisma clients
        run: |
          cd apps/api
          npx prisma generate --schema=./prisma/schema.prisma
          npx prisma generate --schema=./prisma/schema-organization.prisma
          npx prisma generate --schema=./prisma/schema-dropshipping.prisma
          npx prisma generate --schema=./prisma/schema-privacy.prisma

      - name: Update Kustomize for Green deployment
        run: |
          cd infrastructure/kubernetes/production

          # Update image tags
          kustomize edit set image \
            ${{ env.CONTAINER_REGISTRY }}/citadelbuy-api:${{ steps.image-tag.outputs.tag }} \
            ${{ env.CONTAINER_REGISTRY }}/citadelbuy-web:${{ steps.image-tag.outputs.tag }} \
            ${{ env.CONTAINER_REGISTRY }}/citadelbuy-worker:${{ steps.image-tag.outputs.tag }}

          # Add green color label
          cat >> kustomization.yaml <<EOF

          # Blue-Green deployment - GREEN environment
          patchesStrategicMerge:
            - |-
              apiVersion: apps/v1
              kind: Deployment
              metadata:
                name: citadelbuy-api-green
              spec:
                selector:
                  matchLabels:
                    color: green
                template:
                  metadata:
                    labels:
                      color: green
                      version: ${{ steps.image-tag.outputs.tag }}
            - |-
              apiVersion: apps/v1
              kind: Deployment
              metadata:
                name: citadelbuy-web-green
              spec:
                selector:
                  matchLabels:
                    color: green
                template:
                  metadata:
                    labels:
                      color: green
                      version: ${{ steps.image-tag.outputs.tag }}
            - |-
              apiVersion: apps/v1
              kind: Deployment
              metadata:
                name: citadelbuy-worker-green
              spec:
                selector:
                  matchLabels:
                    color: green
                template:
                  metadata:
                    labels:
                      color: green
                      version: ${{ steps.image-tag.outputs.tag }}
          EOF

      - name: Build Kustomize manifests for Green
        run: |
          kustomize build infrastructure/kubernetes/production > deployment-green.yaml

          # Rename deployments to include -green suffix
          sed -i 's/name: citadelbuy-api$/name: citadelbuy-api-green/' deployment-green.yaml
          sed -i 's/name: citadelbuy-web$/name: citadelbuy-web-green/' deployment-green.yaml
          sed -i 's/name: citadelbuy-worker$/name: citadelbuy-worker-green/' deployment-green.yaml

          echo "=== Green Deployment Manifests ==="
          cat deployment-green.yaml

      - name: Deploy Green environment
        id: deploy-green
        run: |
          echo "Deploying GREEN environment..."
          kubectl apply -f deployment-green.yaml

          echo "Waiting for GREEN deployments to be ready..."
          kubectl rollout status deployment/citadelbuy-api-green -n ${{ env.KUBERNETES_NAMESPACE }} --timeout=10m
          kubectl rollout status deployment/citadelbuy-web-green -n ${{ env.KUBERNETES_NAMESPACE }} --timeout=10m
          kubectl rollout status deployment/citadelbuy-worker-green -n ${{ env.KUBERNETES_NAMESPACE }} --timeout=10m

          echo "GREEN environment deployed successfully"

      - name: Set deployment info
        id: deployment-info
        run: |
          DEPLOYMENT_ID="prod-$(date +%Y%m%d-%H%M%S)-$(git rev-parse --short HEAD)"
          echo "deployment-id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT

          # Annotate green deployments
          for deployment in citadelbuy-api-green citadelbuy-web-green citadelbuy-worker-green; do
            kubectl annotate deployment/$deployment -n ${{ env.KUBERNETES_NAMESPACE }} \
              deployment-id=$DEPLOYMENT_ID \
              deployed-by=${{ github.actor }} \
              git-commit=${{ github.sha }} \
              image-tag=${{ steps.image-tag.outputs.tag }} \
              deployment-color=green \
              --overwrite
          done

      - name: Health check - Green API
        run: |
          echo "Running health checks on GREEN environment..."
          sleep 30

          API_POD=$(kubectl get pod -n ${{ env.KUBERNETES_NAMESPACE }} -l app=citadelbuy-api,color=green -o jsonpath="{.items[0].metadata.name}")
          echo "Testing GREEN API pod: $API_POD"

          kubectl exec -n ${{ env.KUBERNETES_NAMESPACE }} $API_POD -- curl -f http://localhost:4000/api/health/live || exit 1
          kubectl exec -n ${{ env.KUBERNETES_NAMESPACE }} $API_POD -- curl -f http://localhost:4000/api/health/ready || exit 1

          echo "GREEN API health checks passed!"

      - name: Health check - Green Web
        run: |
          WEB_POD=$(kubectl get pod -n ${{ env.KUBERNETES_NAMESPACE }} -l app=citadelbuy-web,color=green -o jsonpath="{.items[0].metadata.name}")
          echo "Testing GREEN Web pod: $WEB_POD"

          kubectl exec -n ${{ env.KUBERNETES_NAMESPACE }} $WEB_POD -- curl -f http://localhost:3000/health || exit 1

          echo "GREEN Web health checks passed!"

      - name: Set green deployment status
        id: green-status
        run: |
          echo "success=true" >> $GITHUB_OUTPUT

      - name: Upload deployment artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-manifests-production-green
          path: |
            deployment-green.yaml
            infrastructure/kubernetes/production/
            ${{ steps.backup.outputs.backup-dir }}/
          retention-days: 365

  test-green:
    name: Test Green Environment
    needs: deploy-green
    runs-on: ubuntu-latest
    if: success()

    outputs:
      tests-passed: ${{ steps.test-results.outputs.passed }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Azure Login via OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Set AKS context
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ env.AKS_RESOURCE_GROUP }}
          cluster-name: ${{ env.AKS_CLUSTER_NAME }}

      - name: Install kubelogin
        run: |
          curl -LO https://github.com/Azure/kubelogin/releases/download/v0.1.1/kubelogin-linux-amd64.zip
          unzip kubelogin-linux-amd64.zip
          sudo mv bin/linux_amd64/kubelogin /usr/local/bin/
          rm -rf bin kubelogin-linux-amd64.zip
          kubelogin convert-kubeconfig -l azurecli

      - name: Get Green service endpoints
        id: green-endpoints
        run: |
          # Port forward to green services for testing
          kubectl port-forward -n ${{ env.KUBERNETES_NAMESPACE }} service/citadelbuy-api-green 8080:4000 &
          kubectl port-forward -n ${{ env.KUBERNETES_NAMESPACE }} service/citadelbuy-web-green 8081:3000 &
          sleep 10

          echo "api-url=http://localhost:8080" >> $GITHUB_OUTPUT
          echo "web-url=http://localhost:8081" >> $GITHUB_OUTPUT

      - name: Run smoke tests on Green
        run: |
          cd tests
          npm ci
          npm run test:smoke -- --environment=production-green
        env:
          API_URL: ${{ steps.green-endpoints.outputs.api-url }}
          WEB_URL: ${{ steps.green-endpoints.outputs.web-url }}

      - name: Run integration tests on Green
        run: |
          cd tests
          npm run test:integration -- --environment=production-green
        env:
          API_URL: ${{ steps.green-endpoints.outputs.api-url }}

      - name: Performance tests on Green
        run: |
          cd tests/load
          npm ci
          npm run test:performance -- --environment=production-green
        continue-on-error: true

      - name: Set test results
        id: test-results
        run: |
          echo "passed=true" >> $GITHUB_OUTPUT

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: green-test-results
          path: tests/results/
          retention-days: 90

  switch-traffic:
    name: Switch Traffic to Green
    needs: [deploy-green, test-green]
    runs-on: ubuntu-latest
    if: success() && needs.test-green.outputs.tests-passed == 'true'
    environment:
      name: production-traffic-switch

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login via OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Set AKS context
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ env.AKS_RESOURCE_GROUP }}
          cluster-name: ${{ env.AKS_CLUSTER_NAME }}

      - name: Install kubelogin
        run: |
          curl -LO https://github.com/Azure/kubelogin/releases/download/v0.1.1/kubelogin-linux-amd64.zip
          unzip kubelogin-linux-amd64.zip
          sudo mv bin/linux_amd64/kubelogin /usr/local/bin/
          rm -rf bin kubelogin-linux-amd64.zip
          kubelogin convert-kubeconfig -l azurecli

      - name: Switch service to Green
        run: |
          echo "Switching production traffic to GREEN environment..."

          # Update services to point to green deployments
          kubectl patch service citadelbuy-api -n ${{ env.KUBERNETES_NAMESPACE }} -p '{"spec":{"selector":{"color":"green"}}}'
          kubectl patch service citadelbuy-web -n ${{ env.KUBERNETES_NAMESPACE }} -p '{"spec":{"selector":{"color":"green"}}}'

          echo "Traffic switched to GREEN environment"

      - name: Verify traffic switch
        run: |
          sleep 10

          # Verify services are routing to green pods
          API_SELECTOR=$(kubectl get service citadelbuy-api -n ${{ env.KUBERNETES_NAMESPACE }} -o jsonpath='{.spec.selector.color}')
          WEB_SELECTOR=$(kubectl get service citadelbuy-web -n ${{ env.KUBERNETES_NAMESPACE }} -o jsonpath='{.spec.selector.color}')

          if [ "$API_SELECTOR" != "green" ] || [ "$WEB_SELECTOR" != "green" ]; then
            echo "Error: Traffic not routing to green environment"
            exit 1
          fi

          echo "Traffic successfully routing to GREEN environment"

      - name: Monitor for errors
        run: |
          echo "Monitoring GREEN environment for 2 minutes..."
          sleep 120

          # Check for any pod crashes
          CRASHED_PODS=$(kubectl get pods -n ${{ env.KUBERNETES_NAMESPACE }} -l color=green --field-selector=status.phase!=Running --no-headers | wc -l)
          if [ "$CRASHED_PODS" -gt "0" ]; then
            echo "Warning: $CRASHED_PODS green pods are not running"
            kubectl get pods -n ${{ env.KUBERNETES_NAMESPACE }} -l color=green
          fi

      - name: Notify traffic switch
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "Production Traffic Switched to Green",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": ":large_green_circle: *Production Traffic Switched*\n*Environment:* Production (GREEN)\n*Deployment ID:* ${{ needs.deploy-green.outputs.deployment-id }}\n*Image Tag:* ${{ needs.deploy-green.outputs.image-tag }}\n*Switched by:* ${{ github.actor }}"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK

  cleanup-blue:
    name: Cleanup Blue Environment
    needs: [deploy-green, switch-traffic]
    runs-on: ubuntu-latest
    if: success()

    steps:
      - name: Azure Login via OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Set AKS context
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ env.AKS_RESOURCE_GROUP }}
          cluster-name: ${{ env.AKS_CLUSTER_NAME }}

      - name: Install kubelogin
        run: |
          curl -LO https://github.com/Azure/kubelogin/releases/download/v0.1.1/kubelogin-linux-amd64.zip
          unzip kubelogin-linux-amd64.zip
          sudo mv bin/linux_amd64/kubelogin /usr/local/bin/
          rm -rf bin kubelogin-linux-amd64.zip
          kubelogin convert-kubeconfig -l azurecli

      - name: Wait before cleanup
        run: |
          echo "Waiting 10 minutes before cleaning up BLUE environment..."
          echo "This allows time to rollback if issues are detected."
          sleep 600

      - name: Scale down Blue deployments
        run: |
          echo "Scaling down BLUE environment..."

          kubectl scale deployment/citadelbuy-api-blue -n ${{ env.KUBERNETES_NAMESPACE }} --replicas=0 || echo "Blue API deployment not found"
          kubectl scale deployment/citadelbuy-web-blue -n ${{ env.KUBERNETES_NAMESPACE }} --replicas=0 || echo "Blue Web deployment not found"
          kubectl scale deployment/citadelbuy-worker-blue -n ${{ env.KUBERNETES_NAMESPACE }} --replicas=0 || echo "Blue Worker deployment not found"

          echo "BLUE environment scaled down (kept for rollback capability)"

  deploy-rolling:
    name: Deploy via Rolling Update
    needs: [pre-deployment-validation, approval]
    runs-on: ubuntu-latest
    if: |
      always() &&
      (needs.approval.result == 'success' || needs.approval.result == 'skipped') &&
      github.event.inputs.deployment_strategy == 'rolling'
    environment:
      name: production
      url: https://citadelbuy.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login via OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Set AKS context
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ env.AKS_RESOURCE_GROUP }}
          cluster-name: ${{ env.AKS_CLUSTER_NAME }}

      - name: Install kubelogin
        run: |
          curl -LO https://github.com/Azure/kubelogin/releases/download/v0.1.1/kubelogin-linux-amd64.zip
          unzip kubelogin-linux-amd64.zip
          sudo mv bin/linux_amd64/kubelogin /usr/local/bin/
          rm -rf bin kubelogin-linux-amd64.zip
          kubelogin convert-kubeconfig -l azurecli

      - name: Deploy with Rolling Update
        run: |
          echo "Deploying via Rolling Update strategy..."
          kubectl set image deployment/citadelbuy-api -n ${{ env.KUBERNETES_NAMESPACE }} \
            api=${{ env.CONTAINER_REGISTRY }}/citadelbuy-api:${{ github.event.inputs.image_tag }}

          kubectl set image deployment/citadelbuy-web -n ${{ env.KUBERNETES_NAMESPACE }} \
            web=${{ env.CONTAINER_REGISTRY }}/citadelbuy-web:${{ github.event.inputs.image_tag }}

          kubectl rollout status deployment/citadelbuy-api -n ${{ env.KUBERNETES_NAMESPACE }} --timeout=10m
          kubectl rollout status deployment/citadelbuy-web -n ${{ env.KUBERNETES_NAMESPACE }} --timeout=10m

  notification:
    name: Deployment Notification
    needs: [deploy-green, switch-traffic, cleanup-blue]
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Notify on success
        if: needs.switch-traffic.result == 'success'
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "Production Deployment Successful",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": ":white_check_mark: *Production Deployment Complete*\n*Environment:* Production\n*Strategy:* Blue-Green\n*Deployment ID:* ${{ needs.deploy-green.outputs.deployment-id }}\n*Image Tag:* ${{ needs.deploy-green.outputs.image-tag }}\n*Deployed by:* ${{ github.actor }}\n*URL:* https://citadelbuy.com"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK

      - name: Notify on failure
        if: needs.deploy-green.result == 'failure' || needs.test-green.result == 'failure'
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "Production Deployment Failed",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": ":x: *Production Deployment Failed*\n*Environment:* Production\n*Actor:* ${{ github.actor }}\n*Workflow:* ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\n*Action Required:* Review logs and rollback if necessary"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK
