# Secret Rotation Workflow for CitadelBuy Platform
# Automates periodic and emergency rotation of all platform secrets
# Integrates with Azure Key Vault, GitHub Secrets, and Kubernetes External Secrets
# Implements zero-downtime rotation strategy with rollback capability

name: Secret Rotation

on:
  # Scheduled monthly rotation (First day of every month at 2 AM UTC)
  schedule:
    - cron: '0 2 1 * *'

  # Manual trigger with rotation options
  workflow_dispatch:
    inputs:
      rotation_type:
        description: 'Type of rotation to perform'
        required: true
        type: choice
        default: 'all'
        options:
          - all
          - azure-keyvault
          - database
          - api-keys
          - github-secrets
          - kubernetes-secrets

      environment:
        description: 'Environment to rotate secrets for'
        required: true
        type: choice
        default: 'production'
        options:
          - production
          - staging
          - development
          - all

      emergency_rotation:
        description: 'Emergency rotation (skip approval)'
        required: false
        type: boolean
        default: false

      dry_run:
        description: 'Dry run mode (no actual changes)'
        required: false
        type: boolean
        default: false

      force_restart:
        description: 'Force restart workloads after rotation'
        required: false
        type: boolean
        default: true

# Permissions required for secret rotation
permissions:
  id-token: write      # For Azure OIDC authentication
  contents: read       # For checking out repository
  actions: write       # For managing GitHub secrets
  deployments: write   # For managing environment secrets

# Concurrency control - only one rotation at a time per environment
concurrency:
  group: secret-rotation-${{ github.event.inputs.environment || 'all' }}
  cancel-in-progress: false

env:
  # Azure Configuration
  AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}

  # Key Vault Configuration
  KEYVAULT_NAME_PROD: ${{ secrets.KEYVAULT_NAME_PROD }}
  KEYVAULT_NAME_STAGING: ${{ secrets.KEYVAULT_NAME_STAGING }}
  KEYVAULT_NAME_DEV: ${{ secrets.KEYVAULT_NAME_DEV }}

  # Kubernetes Configuration
  AKS_CLUSTER_NAME_PROD: ${{ secrets.AKS_CLUSTER_NAME_PROD }}
  AKS_CLUSTER_NAME_STAGING: ${{ secrets.AKS_CLUSTER_NAME_STAGING }}
  AKS_RESOURCE_GROUP: ${{ secrets.AKS_RESOURCE_GROUP }}

  # Notification Configuration
  SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_SECURITY }}
  TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_SECURITY }}
  PAGERDUTY_INTEGRATION_KEY: ${{ secrets.PAGERDUTY_INTEGRATION_KEY }}

  # Audit Configuration
  AUDIT_LOG_STORAGE: ${{ secrets.AUDIT_LOG_STORAGE_ACCOUNT }}
  AUDIT_LOG_CONTAINER: 'secret-rotation-audit'

jobs:
  # ============================================================
  # PREPARATION AND VALIDATION
  # ============================================================

  prepare-rotation:
    name: Prepare and Validate Rotation
    runs-on: ubuntu-latest
    timeout-minutes: 10

    outputs:
      rotation-id: ${{ steps.generate-id.outputs.rotation_id }}
      environments: ${{ steps.determine-env.outputs.environments }}
      rotation-types: ${{ steps.determine-types.outputs.types }}
      emergency: ${{ steps.check-emergency.outputs.is_emergency }}
      approval-required: ${{ steps.check-approval.outputs.required }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Generate Rotation ID
        id: generate-id
        run: |
          ROTATION_ID="rot-$(date +%Y%m%d-%H%M%S)-$(uuidgen | cut -d'-' -f1)"
          echo "rotation_id=$ROTATION_ID" >> $GITHUB_OUTPUT
          echo "Generated Rotation ID: $ROTATION_ID"

      - name: Determine Environments
        id: determine-env
        run: |
          ENV_INPUT="${{ github.event.inputs.environment || 'production' }}"
          if [ "$ENV_INPUT" == "all" ]; then
            ENVIRONMENTS='["production","staging","development"]'
          else
            ENVIRONMENTS='["'$ENV_INPUT'"]'
          fi
          echo "environments=$ENVIRONMENTS" >> $GITHUB_OUTPUT
          echo "Environments to rotate: $ENVIRONMENTS"

      - name: Determine Rotation Types
        id: determine-types
        run: |
          TYPE_INPUT="${{ github.event.inputs.rotation_type || 'all' }}"
          if [ "$TYPE_INPUT" == "all" ]; then
            TYPES='["azure-keyvault","database","api-keys","github-secrets","kubernetes-secrets"]'
          else
            TYPES='["'$TYPE_INPUT'"]'
          fi
          echo "types=$TYPES" >> $GITHUB_OUTPUT
          echo "Rotation types: $TYPES"

      - name: Check Emergency Rotation
        id: check-emergency
        run: |
          EMERGENCY="${{ github.event.inputs.emergency_rotation || 'false' }}"
          echo "is_emergency=$EMERGENCY" >> $GITHUB_OUTPUT
          if [ "$EMERGENCY" == "true" ]; then
            echo "EMERGENCY ROTATION INITIATED"
          fi

      - name: Check Approval Requirement
        id: check-approval
        run: |
          EMERGENCY="${{ steps.check-emergency.outputs.is_emergency }}"
          ENV_INPUT="${{ github.event.inputs.environment || 'production' }}"

          if [ "$EMERGENCY" == "true" ]; then
            echo "required=false" >> $GITHUB_OUTPUT
            echo "Approval skipped for emergency rotation"
          elif [ "$ENV_INPUT" == "production" ] || [ "$ENV_INPUT" == "all" ]; then
            echo "required=true" >> $GITHUB_OUTPUT
            echo "Approval required for production rotation"
          else
            echo "required=false" >> $GITHUB_OUTPUT
            echo "No approval required for non-production rotation"
          fi

      - name: Send Preparation Notification
        run: |
          ROTATION_ID="${{ steps.generate-id.outputs.rotation_id }}"
          ENVS="${{ steps.determine-env.outputs.environments }}"
          TYPES="${{ steps.determine-types.outputs.types }}"
          EMERGENCY="${{ steps.check-emergency.outputs.is_emergency }}"

          MESSAGE="Secret Rotation Initiated\n"
          MESSAGE+="Rotation ID: $ROTATION_ID\n"
          MESSAGE+="Environments: $ENVS\n"
          MESSAGE+="Types: $TYPES\n"
          MESSAGE+="Emergency: $EMERGENCY\n"
          MESSAGE+="Triggered by: ${{ github.actor }}\n"
          MESSAGE+="Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          # Send to Slack
          if [ -n "${{ env.SLACK_WEBHOOK_URL }}" ]; then
            curl -X POST "${{ env.SLACK_WEBHOOK_URL }}" \
              -H 'Content-Type: application/json' \
              -d "{\"text\":\"$MESSAGE\"}"
          fi

      - name: Create Audit Log Entry
        run: |
          ROTATION_ID="${{ steps.generate-id.outputs.rotation_id }}"

          cat > rotation-audit.json <<EOF
          {
            "rotation_id": "$ROTATION_ID",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "triggered_by": "${{ github.actor }}",
            "trigger_type": "${{ github.event_name }}",
            "environments": ${{ steps.determine-env.outputs.environments }},
            "rotation_types": ${{ steps.determine-types.outputs.types }},
            "emergency": ${{ steps.check-emergency.outputs.is_emergency }},
            "dry_run": ${{ github.event.inputs.dry_run || 'false' }},
            "status": "initiated"
          }
          EOF

          echo "Audit log entry created"
          cat rotation-audit.json

      - name: Upload Audit Log
        uses: actions/upload-artifact@v4
        with:
          name: rotation-audit-${{ steps.generate-id.outputs.rotation_id }}
          path: rotation-audit.json
          retention-days: 365

  # ============================================================
  # APPROVAL GATE (for production rotations)
  # ============================================================

  approval-gate:
    name: Approval Gate
    runs-on: ubuntu-latest
    needs: prepare-rotation
    if: needs.prepare-rotation.outputs.approval-required == 'true'
    timeout-minutes: 60

    environment:
      name: production-secret-rotation
      url: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

    steps:
      - name: Await Approval
        run: |
          echo "Waiting for approval from security team..."
          echo "Rotation ID: ${{ needs.prepare-rotation.outputs.rotation-id }}"
          echo "This rotation requires manual approval before proceeding"

      - name: Approval Granted
        run: |
          echo "Approval granted. Proceeding with rotation..."

          # Send notification
          MESSAGE="Secret Rotation Approved\n"
          MESSAGE+="Rotation ID: ${{ needs.prepare-rotation.outputs.rotation-id }}\n"
          MESSAGE+="Approved by: ${{ github.actor }}"

          if [ -n "${{ env.SLACK_WEBHOOK_URL }}" ]; then
            curl -X POST "${{ env.SLACK_WEBHOOK_URL }}" \
              -H 'Content-Type: application/json' \
              -d "{\"text\":\"$MESSAGE\"}"
          fi

  # ============================================================
  # AZURE KEY VAULT SECRET ROTATION
  # ============================================================

  rotate-azure-keyvault:
    name: Rotate Azure Key Vault Secrets
    runs-on: ubuntu-latest
    needs: [prepare-rotation, approval-gate]
    if: |
      always() &&
      needs.prepare-rotation.result == 'success' &&
      (needs.approval-gate.result == 'success' || needs.approval-gate.result == 'skipped') &&
      contains(needs.prepare-rotation.outputs.rotation-types, 'azure-keyvault')
    timeout-minutes: 30

    strategy:
      matrix:
        environment: ${{ fromJson(needs.prepare-rotation.outputs.environments) }}
      fail-fast: false

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Set Key Vault Name
        id: set-keyvault
        run: |
          case "${{ matrix.environment }}" in
            production)
              echo "keyvault_name=${{ env.KEYVAULT_NAME_PROD }}" >> $GITHUB_OUTPUT
              ;;
            staging)
              echo "keyvault_name=${{ env.KEYVAULT_NAME_STAGING }}" >> $GITHUB_OUTPUT
              ;;
            development)
              echo "keyvault_name=${{ env.KEYVAULT_NAME_DEV }}" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: Backup Current Secrets
        run: |
          KEYVAULT_NAME="${{ steps.set-keyvault.outputs.keyvault_name }}"
          ROTATION_ID="${{ needs.prepare-rotation.outputs.rotation-id }}"

          echo "Backing up secrets from $KEYVAULT_NAME..."

          # Create backup directory
          mkdir -p secret-backups/${{ matrix.environment }}

          # List all secrets
          SECRETS=$(az keyvault secret list --vault-name $KEYVAULT_NAME --query "[].name" -o tsv)

          # Backup each secret (metadata only, not values for security)
          for SECRET in $SECRETS; do
            echo "Backing up metadata for $SECRET..."
            az keyvault secret show --vault-name $KEYVAULT_NAME --name $SECRET \
              --query "{name:name, version:id, contentType:contentType, tags:tags}" \
              > secret-backups/${{ matrix.environment }}/${SECRET}.json
          done

          echo "Backup completed for $KEYVAULT_NAME"

      - name: Rotate Service Principal Secrets
        run: |
          KEYVAULT_NAME="${{ steps.set-keyvault.outputs.keyvault_name }}"
          DRY_RUN="${{ github.event.inputs.dry_run || 'false' }}"

          echo "Rotating Service Principal secrets in $KEYVAULT_NAME..."

          # List of service principals to rotate
          SERVICE_PRINCIPALS=(
            "citadelbuy-api-sp"
            "citadelbuy-web-sp"
            "citadelbuy-services-sp"
            "citadelbuy-monitoring-sp"
          )

          for SP_NAME in "${SERVICE_PRINCIPALS[@]}"; do
            echo "Rotating credentials for $SP_NAME..."

            if [ "$DRY_RUN" == "false" ]; then
              # Get Service Principal Object ID
              SP_ID=$(az ad sp list --display-name $SP_NAME --query "[0].id" -o tsv)

              if [ -n "$SP_ID" ]; then
                # Create new credential
                NEW_CRED=$(az ad sp credential reset --id $SP_ID --query password -o tsv)

                # Store in Key Vault
                SECRET_NAME=$(echo $SP_NAME | tr '-' '_' | tr '[:lower:]' '[:upper:]')-SECRET
                az keyvault secret set \
                  --vault-name $KEYVAULT_NAME \
                  --name $SECRET_NAME \
                  --value "$NEW_CRED" \
                  --tags "rotated-at=$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                          "rotation-id=${{ needs.prepare-rotation.outputs.rotation-id }}" \
                          "rotated-by=${{ github.actor }}"

                echo "Rotated and stored: $SECRET_NAME"
              else
                echo "Warning: Service Principal $SP_NAME not found"
              fi
            else
              echo "DRY RUN: Would rotate $SP_NAME"
            fi
          done

      - name: Rotate Storage Account Keys
        run: |
          KEYVAULT_NAME="${{ steps.set-keyvault.outputs.keyvault_name }}"
          DRY_RUN="${{ github.event.inputs.dry_run || 'false' }}"

          echo "Rotating Storage Account keys in $KEYVAULT_NAME..."

          # Get storage accounts for this environment
          STORAGE_ACCOUNTS=$(az storage account list \
            --query "[?tags.environment=='${{ matrix.environment }}'].name" -o tsv)

          for STORAGE_ACCOUNT in $STORAGE_ACCOUNTS; do
            echo "Rotating keys for storage account: $STORAGE_ACCOUNT"

            if [ "$DRY_RUN" == "false" ]; then
              # Get resource group
              RESOURCE_GROUP=$(az storage account show \
                --name $STORAGE_ACCOUNT \
                --query resourceGroup -o tsv)

              # Rotate key1 (key2 remains active for zero-downtime)
              NEW_KEY=$(az storage account keys renew \
                --account-name $STORAGE_ACCOUNT \
                --resource-group $RESOURCE_GROUP \
                --key key1 \
                --query "[?keyName=='key1'].value" -o tsv)

              # Store in Key Vault
              SECRET_NAME="STORAGE-$(echo $STORAGE_ACCOUNT | tr '[:lower:]' '[:upper:]')-KEY"
              az keyvault secret set \
                --vault-name $KEYVAULT_NAME \
                --name $SECRET_NAME \
                --value "$NEW_KEY" \
                --tags "rotated-at=$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                        "rotation-id=${{ needs.prepare-rotation.outputs.rotation-id }}"

              echo "Rotated and stored: $SECRET_NAME"
            else
              echo "DRY RUN: Would rotate $STORAGE_ACCOUNT"
            fi
          done

      - name: Rotate Azure SQL Connection Strings
        run: |
          KEYVAULT_NAME="${{ steps.set-keyvault.outputs.keyvault_name }}"
          DRY_RUN="${{ github.event.inputs.dry_run || 'false' }}"

          echo "Rotating Azure SQL connection strings in $KEYVAULT_NAME..."

          # This will be handled in the database rotation job
          # Here we just update the connection string format in Key Vault

          if [ "$DRY_RUN" == "false" ]; then
            echo "Azure SQL passwords will be rotated in database rotation job"
            # Update connection string templates with new credentials
          else
            echo "DRY RUN: Would update SQL connection strings"
          fi

      - name: Upload Backup Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: keyvault-backup-${{ matrix.environment }}-${{ needs.prepare-rotation.outputs.rotation-id }}
          path: secret-backups/
          retention-days: 90

      - name: Verify Secret Rotation
        run: |
          KEYVAULT_NAME="${{ steps.set-keyvault.outputs.keyvault_name }}"

          echo "Verifying rotated secrets in $KEYVAULT_NAME..."

          # Verify secrets have recent rotation tags
          ROTATION_ID="${{ needs.prepare-rotation.outputs.rotation-id }}"

          ROTATED_SECRETS=$(az keyvault secret list --vault-name $KEYVAULT_NAME \
            --query "[?tags.\"rotation-id\"=='$ROTATION_ID'].name" -o tsv)

          echo "Verified rotated secrets:"
          echo "$ROTATED_SECRETS"

          if [ -z "$ROTATED_SECRETS" ]; then
            echo "Warning: No secrets found with rotation-id tag"
          fi

  # ============================================================
  # DATABASE CREDENTIALS ROTATION
  # ============================================================

  rotate-database-credentials:
    name: Rotate Database Credentials
    runs-on: ubuntu-latest
    needs: [prepare-rotation, approval-gate, rotate-azure-keyvault]
    if: |
      always() &&
      needs.prepare-rotation.result == 'success' &&
      (needs.approval-gate.result == 'success' || needs.approval-gate.result == 'skipped') &&
      contains(needs.prepare-rotation.outputs.rotation-types, 'database')
    timeout-minutes: 30

    strategy:
      matrix:
        environment: ${{ fromJson(needs.prepare-rotation.outputs.environments) }}
        database: ['postgresql', 'mongodb', 'redis']
      fail-fast: false

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Set Key Vault Name
        id: set-keyvault
        run: |
          case "${{ matrix.environment }}" in
            production)
              echo "keyvault_name=${{ env.KEYVAULT_NAME_PROD }}" >> $GITHUB_OUTPUT
              ;;
            staging)
              echo "keyvault_name=${{ env.KEYVAULT_NAME_STAGING }}" >> $GITHUB_OUTPUT
              ;;
            development)
              echo "keyvault_name=${{ env.KEYVAULT_NAME_DEV }}" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: Install Database Clients
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client mongodb-clients redis-tools

      - name: Rotate PostgreSQL Credentials
        if: matrix.database == 'postgresql'
        run: |
          KEYVAULT_NAME="${{ steps.set-keyvault.outputs.keyvault_name }}"
          DRY_RUN="${{ github.event.inputs.dry_run || 'false' }}"

          echo "Rotating PostgreSQL credentials for ${{ matrix.environment }}..."

          # Get current credentials from Key Vault
          DB_HOST=$(az keyvault secret show --vault-name $KEYVAULT_NAME \
            --name "POSTGRES-HOST-${{ matrix.environment }}" --query value -o tsv)
          DB_USER=$(az keyvault secret show --vault-name $KEYVAULT_NAME \
            --name "POSTGRES-USER-${{ matrix.environment }}" --query value -o tsv)
          DB_PASSWORD=$(az keyvault secret show --vault-name $KEYVAULT_NAME \
            --name "POSTGRES-PASSWORD-${{ matrix.environment }}" --query value -o tsv)
          DB_NAME=$(az keyvault secret show --vault-name $KEYVAULT_NAME \
            --name "POSTGRES-DATABASE-${{ matrix.environment }}" --query value -o tsv)

          if [ "$DRY_RUN" == "false" ]; then
            # Generate new password (32 characters, alphanumeric + special chars)
            NEW_PASSWORD=$(openssl rand -base64 32 | tr -dc 'a-zA-Z0-9!@#$%^&*' | head -c 32)

            # Create new user with same privileges (zero-downtime strategy)
            NEW_USER="${DB_USER}_new"

            export PGPASSWORD="$DB_PASSWORD"

            # Create new user
            psql -h "$DB_HOST" -U "$DB_USER" -d "$DB_NAME" <<EOF
            CREATE USER $NEW_USER WITH PASSWORD '$NEW_PASSWORD';
            GRANT ALL PRIVILEGES ON DATABASE $DB_NAME TO $NEW_USER;
            GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO $NEW_USER;
            GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO $NEW_USER;
EOF

            # Store new credentials in Key Vault
            az keyvault secret set \
              --vault-name $KEYVAULT_NAME \
              --name "POSTGRES-USER-${{ matrix.environment }}" \
              --value "$NEW_USER" \
              --tags "rotated-at=$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                      "rotation-id=${{ needs.prepare-rotation.outputs.rotation-id }}"

            az keyvault secret set \
              --vault-name $KEYVAULT_NAME \
              --name "POSTGRES-PASSWORD-${{ matrix.environment }}" \
              --value "$NEW_PASSWORD" \
              --tags "rotated-at=$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                      "rotation-id=${{ needs.prepare-rotation.outputs.rotation-id }}"

            # Update connection string
            CONNECTION_STRING="postgresql://$NEW_USER:$NEW_PASSWORD@$DB_HOST:5432/$DB_NAME?sslmode=require"
            az keyvault secret set \
              --vault-name $KEYVAULT_NAME \
              --name "DATABASE-URL-${{ matrix.environment }}" \
              --value "$CONNECTION_STRING" \
              --tags "rotated-at=$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                      "rotation-id=${{ needs.prepare-rotation.outputs.rotation-id }}"

            echo "PostgreSQL credentials rotated successfully"
            echo "Old user will be removed after verification period"
          else
            echo "DRY RUN: Would rotate PostgreSQL credentials"
          fi

      - name: Rotate MongoDB Credentials
        if: matrix.database == 'mongodb'
        run: |
          KEYVAULT_NAME="${{ steps.set-keyvault.outputs.keyvault_name }}"
          DRY_RUN="${{ github.event.inputs.dry_run || 'false' }}"

          echo "Rotating MongoDB credentials for ${{ matrix.environment }}..."

          if [ "$DRY_RUN" == "false" ]; then
            # Get current credentials
            MONGO_URI=$(az keyvault secret show --vault-name $KEYVAULT_NAME \
              --name "MONGODB-URI-${{ matrix.environment }}" --query value -o tsv)

            # Generate new password
            NEW_PASSWORD=$(openssl rand -base64 32 | tr -dc 'a-zA-Z0-9!@#$%^&*' | head -c 32)

            # Update MongoDB user password (use mongosh or mongo client)
            # This is a simplified example - adjust based on your MongoDB setup
            echo "MongoDB credential rotation requires admin access"

            # Store new credentials
            az keyvault secret set \
              --vault-name $KEYVAULT_NAME \
              --name "MONGODB-PASSWORD-${{ matrix.environment }}" \
              --value "$NEW_PASSWORD" \
              --tags "rotated-at=$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                      "rotation-id=${{ needs.prepare-rotation.outputs.rotation-id }}"

            echo "MongoDB credentials rotated successfully"
          else
            echo "DRY RUN: Would rotate MongoDB credentials"
          fi

      - name: Rotate Redis Credentials
        if: matrix.database == 'redis'
        run: |
          KEYVAULT_NAME="${{ steps.set-keyvault.outputs.keyvault_name }}"
          DRY_RUN="${{ github.event.inputs.dry_run || 'false' }}"

          echo "Rotating Redis credentials for ${{ matrix.environment }}..."

          if [ "$DRY_RUN" == "false" ]; then
            # For Azure Cache for Redis, rotate access keys
            REDIS_NAME="citadelbuy-redis-${{ matrix.environment }}"
            RESOURCE_GROUP="${{ env.AKS_RESOURCE_GROUP }}"

            # Regenerate primary key
            NEW_KEY=$(az redis regenerate-keys \
              --name $REDIS_NAME \
              --resource-group $RESOURCE_GROUP \
              --key-type Primary \
              --query primaryKey -o tsv)

            # Store in Key Vault
            az keyvault secret set \
              --vault-name $KEYVAULT_NAME \
              --name "REDIS-PASSWORD-${{ matrix.environment }}" \
              --value "$NEW_KEY" \
              --tags "rotated-at=$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                      "rotation-id=${{ needs.prepare-rotation.outputs.rotation-id }}"

            echo "Redis credentials rotated successfully"
          else
            echo "DRY RUN: Would rotate Redis credentials"
          fi

  # ============================================================
  # API KEYS ROTATION (Stripe, SendGrid, etc.)
  # ============================================================

  rotate-api-keys:
    name: Rotate API Keys
    runs-on: ubuntu-latest
    needs: [prepare-rotation, approval-gate]
    if: |
      always() &&
      needs.prepare-rotation.result == 'success' &&
      (needs.approval-gate.result == 'success' || needs.approval-gate.result == 'skipped') &&
      contains(needs.prepare-rotation.outputs.rotation-types, 'api-keys')
    timeout-minutes: 20

    strategy:
      matrix:
        environment: ${{ fromJson(needs.prepare-rotation.outputs.environments) }}
        service: ['stripe', 'sendgrid', 'twilio', 'cloudflare']
      fail-fast: false

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Set Key Vault Name
        id: set-keyvault
        run: |
          case "${{ matrix.environment }}" in
            production)
              echo "keyvault_name=${{ env.KEYVAULT_NAME_PROD }}" >> $GITHUB_OUTPUT
              ;;
            staging)
              echo "keyvault_name=${{ env.KEYVAULT_NAME_STAGING }}" >> $GITHUB_OUTPUT
              ;;
            development)
              echo "keyvault_name=${{ env.KEYVAULT_NAME_DEV }}" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: Rotate Stripe API Keys
        if: matrix.service == 'stripe'
        run: |
          KEYVAULT_NAME="${{ steps.set-keyvault.outputs.keyvault_name }}"
          DRY_RUN="${{ github.event.inputs.dry_run || 'false' }}"

          echo "Rotating Stripe API keys for ${{ matrix.environment }}..."

          if [ "$DRY_RUN" == "false" ]; then
            # Note: Stripe API key rotation must be done manually through Stripe Dashboard
            # This step creates a reminder and updates the rotation timestamp

            echo "Manual Action Required: Rotate Stripe API keys in Stripe Dashboard"
            echo "Environment: ${{ matrix.environment }}"
            echo "After manual rotation, update the key in Key Vault"

            # Send notification for manual action
            MESSAGE="MANUAL ACTION REQUIRED: Rotate Stripe API keys\n"
            MESSAGE+="Environment: ${{ matrix.environment }}\n"
            MESSAGE+="Rotation ID: ${{ needs.prepare-rotation.outputs.rotation-id }}\n"
            MESSAGE+="Instructions: https://dashboard.stripe.com/apikeys"

            if [ -n "${{ env.SLACK_WEBHOOK_URL }}" ]; then
              curl -X POST "${{ env.SLACK_WEBHOOK_URL }}" \
                -H 'Content-Type: application/json' \
                -d "{\"text\":\"$MESSAGE\"}"
            fi
          else
            echo "DRY RUN: Would notify for Stripe API key rotation"
          fi

      - name: Rotate SendGrid API Keys
        if: matrix.service == 'sendgrid'
        run: |
          KEYVAULT_NAME="${{ steps.set-keyvault.outputs.keyvault_name }}"
          DRY_RUN="${{ github.event.inputs.dry_run || 'false' }}"

          echo "Rotating SendGrid API keys for ${{ matrix.environment }}..."

          if [ "$DRY_RUN" == "false" ]; then
            # Get current SendGrid API key
            SENDGRID_API_KEY=$(az keyvault secret show --vault-name $KEYVAULT_NAME \
              --name "SENDGRID-API-KEY-${{ matrix.environment }}" --query value -o tsv 2>/dev/null || echo "")

            if [ -n "$SENDGRID_API_KEY" ]; then
              # Create new API key via SendGrid API
              NEW_API_KEY=$(curl -s -X POST "https://api.sendgrid.com/v3/api_keys" \
                -H "Authorization: Bearer $SENDGRID_API_KEY" \
                -H "Content-Type: application/json" \
                -d '{"name":"citadelbuy-'${{ matrix.environment }}'-'$(date +%Y%m%d)'","scopes":["mail.send"]}' \
                | jq -r '.api_key')

              if [ -n "$NEW_API_KEY" ] && [ "$NEW_API_KEY" != "null" ]; then
                # Store new key in Key Vault
                az keyvault secret set \
                  --vault-name $KEYVAULT_NAME \
                  --name "SENDGRID-API-KEY-${{ matrix.environment }}" \
                  --value "$NEW_API_KEY" \
                  --tags "rotated-at=$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                          "rotation-id=${{ needs.prepare-rotation.outputs.rotation-id }}"

                echo "SendGrid API key rotated successfully"

                # Note: Old key should be revoked after verification
              else
                echo "Error: Failed to create new SendGrid API key"
                exit 1
              fi
            else
              echo "Warning: SendGrid API key not found in Key Vault"
            fi
          else
            echo "DRY RUN: Would rotate SendGrid API key"
          fi

      - name: Rotate Twilio API Keys
        if: matrix.service == 'twilio'
        run: |
          KEYVAULT_NAME="${{ steps.set-keyvault.outputs.keyvault_name }}"
          DRY_RUN="${{ github.event.inputs.dry_run || 'false' }}"

          echo "Rotating Twilio API keys for ${{ matrix.environment }}..."

          if [ "$DRY_RUN" == "false" ]; then
            echo "Manual Action Required: Rotate Twilio API keys in Twilio Console"
            echo "Environment: ${{ matrix.environment }}"
          else
            echo "DRY RUN: Would rotate Twilio API key"
          fi

      - name: Rotate Cloudflare API Keys
        if: matrix.service == 'cloudflare'
        run: |
          KEYVAULT_NAME="${{ steps.set-keyvault.outputs.keyvault_name }}"
          DRY_RUN="${{ github.event.inputs.dry_run || 'false' }}"

          echo "Rotating Cloudflare API keys for ${{ matrix.environment }}..."

          if [ "$DRY_RUN" == "false" ]; then
            echo "Manual Action Required: Rotate Cloudflare API tokens in Cloudflare Dashboard"
            echo "Environment: ${{ matrix.environment }}"
          else
            echo "DRY RUN: Would rotate Cloudflare API token"
          fi

  # ============================================================
  # SYNC SECRETS TO GITHUB
  # ============================================================

  sync-github-secrets:
    name: Sync Secrets to GitHub
    runs-on: ubuntu-latest
    needs: [prepare-rotation, approval-gate, rotate-azure-keyvault, rotate-database-credentials, rotate-api-keys]
    if: |
      always() &&
      needs.prepare-rotation.result == 'success' &&
      (needs.approval-gate.result == 'success' || needs.approval-gate.result == 'skipped') &&
      contains(needs.prepare-rotation.outputs.rotation-types, 'github-secrets')
    timeout-minutes: 15

    strategy:
      matrix:
        environment: ${{ fromJson(needs.prepare-rotation.outputs.environments) }}
      fail-fast: false

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Set Key Vault Name
        id: set-keyvault
        run: |
          case "${{ matrix.environment }}" in
            production)
              echo "keyvault_name=${{ env.KEYVAULT_NAME_PROD }}" >> $GITHUB_OUTPUT
              ;;
            staging)
              echo "keyvault_name=${{ env.KEYVAULT_NAME_STAGING }}" >> $GITHUB_OUTPUT
              ;;
            development)
              echo "keyvault_name=${{ env.KEYVAULT_NAME_DEV }}" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: Install GitHub CLI
        run: |
          sudo apt-get update
          sudo apt-get install -y gh

      - name: Authenticate GitHub CLI
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | gh auth login --with-token

      - name: Sync Secrets to GitHub Environment
        run: |
          KEYVAULT_NAME="${{ steps.set-keyvault.outputs.keyvault_name }}"
          DRY_RUN="${{ github.event.inputs.dry_run || 'false' }}"
          ENVIRONMENT="${{ matrix.environment }}"

          echo "Syncing secrets from $KEYVAULT_NAME to GitHub environment: $ENVIRONMENT"

          # Define secrets to sync
          declare -A SECRETS_MAP=(
            ["DATABASE-URL-$ENVIRONMENT"]="DATABASE_URL"
            ["POSTGRES-HOST-$ENVIRONMENT"]="POSTGRES_HOST"
            ["POSTGRES-USER-$ENVIRONMENT"]="POSTGRES_USER"
            ["POSTGRES-PASSWORD-$ENVIRONMENT"]="POSTGRES_PASSWORD"
            ["POSTGRES-DATABASE-$ENVIRONMENT"]="POSTGRES_DATABASE"
            ["REDIS-PASSWORD-$ENVIRONMENT"]="REDIS_PASSWORD"
            ["MONGODB-URI-$ENVIRONMENT"]="MONGODB_URI"
            ["SENDGRID-API-KEY-$ENVIRONMENT"]="SENDGRID_API_KEY"
          )

          for KV_SECRET in "${!SECRETS_MAP[@]}"; do
            GH_SECRET="${SECRETS_MAP[$KV_SECRET]}"

            echo "Syncing $KV_SECRET -> $GH_SECRET"

            if [ "$DRY_RUN" == "false" ]; then
              # Get secret value from Key Vault
              SECRET_VALUE=$(az keyvault secret show --vault-name $KEYVAULT_NAME \
                --name "$KV_SECRET" --query value -o tsv 2>/dev/null || echo "")

              if [ -n "$SECRET_VALUE" ]; then
                # Update GitHub environment secret
                gh secret set "$GH_SECRET" \
                  --env "$ENVIRONMENT" \
                  --body "$SECRET_VALUE" \
                  --repo "${{ github.repository }}"

                echo "Synced: $GH_SECRET"
              else
                echo "Warning: Secret $KV_SECRET not found in Key Vault"
              fi
            else
              echo "DRY RUN: Would sync $GH_SECRET"
            fi
          done

          echo "GitHub secrets sync completed for $ENVIRONMENT"

  # ============================================================
  # SYNC SECRETS TO KUBERNETES
  # ============================================================

  sync-kubernetes-secrets:
    name: Sync Secrets to Kubernetes
    runs-on: ubuntu-latest
    needs: [prepare-rotation, approval-gate, rotate-azure-keyvault, rotate-database-credentials, rotate-api-keys]
    if: |
      always() &&
      needs.prepare-rotation.result == 'success' &&
      (needs.approval-gate.result == 'success' || needs.approval-gate.result == 'skipped') &&
      contains(needs.prepare-rotation.outputs.rotation-types, 'kubernetes-secrets')
    timeout-minutes: 20

    strategy:
      matrix:
        environment: ${{ fromJson(needs.prepare-rotation.outputs.environments) }}
      fail-fast: false

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Set AKS Cluster Name
        id: set-cluster
        run: |
          case "${{ matrix.environment }}" in
            production)
              echo "cluster_name=${{ env.AKS_CLUSTER_NAME_PROD }}" >> $GITHUB_OUTPUT
              ;;
            staging)
              echo "cluster_name=${{ env.AKS_CLUSTER_NAME_STAGING }}" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "cluster_name=citadelbuy-aks-${{ matrix.environment }}" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: Get AKS Credentials
        run: |
          CLUSTER_NAME="${{ steps.set-cluster.outputs.cluster_name }}"
          RESOURCE_GROUP="${{ env.AKS_RESOURCE_GROUP }}"

          az aks get-credentials \
            --name $CLUSTER_NAME \
            --resource-group $RESOURCE_GROUP \
            --overwrite-existing

      - name: Verify External Secrets Operator
        run: |
          echo "Checking External Secrets Operator installation..."

          # Check if ESO is installed
          if ! kubectl get deployment -n external-secrets external-secrets 2>/dev/null; then
            echo "Warning: External Secrets Operator not found"
            echo "Secrets will need to be synced manually or ESO needs to be installed"
          else
            echo "External Secrets Operator is installed"
          fi

      - name: Trigger External Secrets Sync
        run: |
          DRY_RUN="${{ github.event.inputs.dry_run || 'false' }}"

          echo "Triggering External Secrets sync for ${{ matrix.environment }}..."

          if [ "$DRY_RUN" == "false" ]; then
            # Force reconciliation of all ExternalSecrets
            EXTERNAL_SECRETS=$(kubectl get externalsecrets -A -o json | \
              jq -r '.items[] | select(.spec.target.name | contains("'${{ matrix.environment }}'")) | "\(.metadata.namespace)/\(.metadata.name)"')

            for ES in $EXTERNAL_SECRETS; do
              NAMESPACE=$(echo $ES | cut -d'/' -f1)
              NAME=$(echo $ES | cut -d'/' -f2)

              echo "Refreshing ExternalSecret: $NAMESPACE/$NAME"

              # Annotate to force refresh
              kubectl annotate externalsecret $NAME \
                -n $NAMESPACE \
                force-sync=$(date +%s) \
                --overwrite
            done

            # Wait for secrets to be updated
            echo "Waiting for secrets to sync..."
            sleep 10

            # Verify secrets were updated
            for ES in $EXTERNAL_SECRETS; do
              NAMESPACE=$(echo $ES | cut -d'/' -f1)
              NAME=$(echo $ES | cut -d'/' -f2)

              # Get the target secret name
              TARGET_SECRET=$(kubectl get externalsecret $NAME -n $NAMESPACE \
                -o jsonpath='{.spec.target.name}')

              # Check if secret exists and was recently updated
              if kubectl get secret $TARGET_SECRET -n $NAMESPACE &>/dev/null; then
                echo "Verified: $NAMESPACE/$TARGET_SECRET"
              else
                echo "Warning: Secret $NAMESPACE/$TARGET_SECRET not found"
              fi
            done

            echo "Kubernetes secrets sync completed"
          else
            echo "DRY RUN: Would trigger External Secrets sync"
          fi

      - name: Create Manual Kubernetes Secrets (Fallback)
        run: |
          DRY_RUN="${{ github.event.inputs.dry_run || 'false' }}"

          echo "Creating manual Kubernetes secrets as fallback..."

          # This is a fallback in case External Secrets is not available
          # In production, External Secrets Operator should handle this automatically

          if [ "$DRY_RUN" == "false" ]; then
            echo "Manual secret creation would be performed here if needed"
          else
            echo "DRY RUN: Would create manual Kubernetes secrets"
          fi

  # ============================================================
  # RESTART WORKLOADS
  # ============================================================

  restart-workloads:
    name: Restart Affected Workloads
    runs-on: ubuntu-latest
    needs: [prepare-rotation, sync-kubernetes-secrets, sync-github-secrets]
    if: |
      always() &&
      needs.prepare-rotation.result == 'success' &&
      (github.event.inputs.force_restart == 'true' || github.event.inputs.force_restart == '')
    timeout-minutes: 30

    strategy:
      matrix:
        environment: ${{ fromJson(needs.prepare-rotation.outputs.environments) }}
      fail-fast: false

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Set AKS Cluster Name
        id: set-cluster
        run: |
          case "${{ matrix.environment }}" in
            production)
              echo "cluster_name=${{ env.AKS_CLUSTER_NAME_PROD }}" >> $GITHUB_OUTPUT
              ;;
            staging)
              echo "cluster_name=${{ env.AKS_CLUSTER_NAME_STAGING }}" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "cluster_name=citadelbuy-aks-${{ matrix.environment }}" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: Get AKS Credentials
        run: |
          CLUSTER_NAME="${{ steps.set-cluster.outputs.cluster_name }}"
          RESOURCE_GROUP="${{ env.AKS_RESOURCE_GROUP }}"

          az aks get-credentials \
            --name $CLUSTER_NAME \
            --resource-group $RESOURCE_GROUP \
            --overwrite-existing

      - name: Graceful Rolling Restart - API
        run: |
          DRY_RUN="${{ github.event.inputs.dry_run || 'false' }}"

          echo "Performing graceful rolling restart of API workloads..."

          NAMESPACES=("api" "api-${{ matrix.environment }}")

          for NAMESPACE in "${NAMESPACES[@]}"; do
            if kubectl get namespace $NAMESPACE &>/dev/null; then
              echo "Restarting deployments in namespace: $NAMESPACE"

              if [ "$DRY_RUN" == "false" ]; then
                # Get all deployments in namespace
                DEPLOYMENTS=$(kubectl get deployments -n $NAMESPACE -o name)

                for DEPLOYMENT in $DEPLOYMENTS; do
                  echo "Rolling restart: $DEPLOYMENT"

                  kubectl rollout restart $DEPLOYMENT -n $NAMESPACE

                  # Wait for rollout to complete (with timeout)
                  kubectl rollout status $DEPLOYMENT -n $NAMESPACE --timeout=5m || echo "Warning: Rollout timeout for $DEPLOYMENT"
                done
              else
                echo "DRY RUN: Would restart deployments in $NAMESPACE"
              fi
            fi
          done

      - name: Graceful Rolling Restart - Services
        run: |
          DRY_RUN="${{ github.event.inputs.dry_run || 'false' }}"

          echo "Performing graceful rolling restart of service workloads..."

          SERVICES=(
            "ai-engine"
            "analytics"
            "chatbot"
            "fraud-detection"
            "pricing"
            "recommendation"
            "search"
            "supplier-integration"
          )

          for SERVICE in "${SERVICES[@]}"; do
            NAMESPACE="$SERVICE-${{ matrix.environment }}"

            if kubectl get namespace $NAMESPACE &>/dev/null; then
              echo "Restarting service: $SERVICE"

              if [ "$DRY_RUN" == "false" ]; then
                DEPLOYMENTS=$(kubectl get deployments -n $NAMESPACE -o name)

                for DEPLOYMENT in $DEPLOYMENTS; do
                  echo "Rolling restart: $DEPLOYMENT"
                  kubectl rollout restart $DEPLOYMENT -n $NAMESPACE
                  kubectl rollout status $DEPLOYMENT -n $NAMESPACE --timeout=5m || echo "Warning: Rollout timeout"
                done
              else
                echo "DRY RUN: Would restart service $SERVICE"
              fi
            fi
          done

      - name: Graceful Rolling Restart - Web
        run: |
          DRY_RUN="${{ github.event.inputs.dry_run || 'false' }}"

          echo "Performing graceful rolling restart of web workloads..."

          NAMESPACE="web-${{ matrix.environment }}"

          if kubectl get namespace $NAMESPACE &>/dev/null; then
            if [ "$DRY_RUN" == "false" ]; then
              DEPLOYMENTS=$(kubectl get deployments -n $NAMESPACE -o name)

              for DEPLOYMENT in $DEPLOYMENTS; do
                echo "Rolling restart: $DEPLOYMENT"
                kubectl rollout restart $DEPLOYMENT -n $NAMESPACE
                kubectl rollout status $DEPLOYMENT -n $NAMESPACE --timeout=5m || echo "Warning: Rollout timeout"
              done
            else
              echo "DRY RUN: Would restart web deployments"
            fi
          fi

      - name: Verify Workload Health
        run: |
          echo "Verifying workload health after restart..."

          # Check pod status across all namespaces
          kubectl get pods -A | grep -E "(api|web|service)" | grep -v Running || true

          # Check for crash looping pods
          CRASH_LOOPS=$(kubectl get pods -A | grep -E "CrashLoopBackOff|Error" | wc -l)

          if [ $CRASH_LOOPS -gt 0 ]; then
            echo "Warning: Found $CRASH_LOOPS pods in error state"
            kubectl get pods -A | grep -E "CrashLoopBackOff|Error"
          else
            echo "All pods are healthy"
          fi

  # ============================================================
  # CLEANUP AND FINALIZATION
  # ============================================================

  cleanup-old-secrets:
    name: Cleanup Old Secrets
    runs-on: ubuntu-latest
    needs: [prepare-rotation, restart-workloads]
    if: |
      always() &&
      needs.prepare-rotation.result == 'success' &&
      needs.restart-workloads.result == 'success'
    timeout-minutes: 15

    strategy:
      matrix:
        environment: ${{ fromJson(needs.prepare-rotation.outputs.environments) }}
      fail-fast: false

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Set Key Vault Name
        id: set-keyvault
        run: |
          case "${{ matrix.environment }}" in
            production)
              echo "keyvault_name=${{ env.KEYVAULT_NAME_PROD }}" >> $GITHUB_OUTPUT
              ;;
            staging)
              echo "keyvault_name=${{ env.KEYVAULT_NAME_STAGING }}" >> $GITHUB_OUTPUT
              ;;
            development)
              echo "keyvault_name=${{ env.KEYVAULT_NAME_DEV }}" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: Cleanup Old Database Users
        run: |
          DRY_RUN="${{ github.event.inputs.dry_run || 'false' }}"

          echo "Cleaning up old database users for ${{ matrix.environment }}..."

          if [ "$DRY_RUN" == "false" ]; then
            # This should be done after verification period (e.g., 24-48 hours)
            # For now, just log the cleanup that would occur
            echo "Old database users will be removed after verification period"
            echo "Manual cleanup recommended after 48 hours"
          else
            echo "DRY RUN: Would cleanup old database users"
          fi

      - name: Cleanup Old API Keys
        run: |
          DRY_RUN="${{ github.event.inputs.dry_run || 'false' }}"

          echo "Cleaning up old API keys for ${{ matrix.environment }}..."

          if [ "$DRY_RUN" == "false" ]; then
            echo "Old API keys should be revoked manually after verification"
            echo "Check SendGrid, Stripe, and other service dashboards"
          else
            echo "DRY RUN: Would cleanup old API keys"
          fi

  # ============================================================
  # FINAL AUDIT AND NOTIFICATION
  # ============================================================

  finalize-rotation:
    name: Finalize Rotation and Audit
    runs-on: ubuntu-latest
    needs: [
      prepare-rotation,
      rotate-azure-keyvault,
      rotate-database-credentials,
      rotate-api-keys,
      sync-github-secrets,
      sync-kubernetes-secrets,
      restart-workloads,
      cleanup-old-secrets
    ]
    if: always()
    timeout-minutes: 10

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Determine Overall Status
        id: status
        run: |
          # Check if any critical job failed
          KEYVAULT_STATUS="${{ needs.rotate-azure-keyvault.result }}"
          DATABASE_STATUS="${{ needs.rotate-database-credentials.result }}"
          API_KEYS_STATUS="${{ needs.rotate-api-keys.result }}"
          GITHUB_STATUS="${{ needs.sync-github-secrets.result }}"
          K8S_STATUS="${{ needs.sync-kubernetes-secrets.result }}"
          RESTART_STATUS="${{ needs.restart-workloads.result }}"

          if [[ "$KEYVAULT_STATUS" == "failure" ]] || \
             [[ "$DATABASE_STATUS" == "failure" ]] || \
             [[ "$API_KEYS_STATUS" == "failure" ]] || \
             [[ "$GITHUB_STATUS" == "failure" ]] || \
             [[ "$K8S_STATUS" == "failure" ]]; then
            echo "overall_status=failed" >> $GITHUB_OUTPUT
            echo "Rotation failed in one or more components"
          elif [[ "$RESTART_STATUS" == "failure" ]]; then
            echo "overall_status=partial" >> $GITHUB_OUTPUT
            echo "Rotation succeeded but workload restart failed"
          else
            echo "overall_status=success" >> $GITHUB_OUTPUT
            echo "Rotation completed successfully"
          fi

      - name: Create Final Audit Report
        run: |
          ROTATION_ID="${{ needs.prepare-rotation.outputs.rotation-id }}"
          OVERALL_STATUS="${{ steps.status.outputs.overall_status }}"

          cat > final-audit-report.json <<EOF
          {
            "rotation_id": "$ROTATION_ID",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "triggered_by": "${{ github.actor }}",
            "trigger_type": "${{ github.event_name }}",
            "environments": ${{ needs.prepare-rotation.outputs.environments }},
            "rotation_types": ${{ needs.prepare-rotation.outputs.rotation-types }},
            "emergency": ${{ needs.prepare-rotation.outputs.emergency }},
            "dry_run": ${{ github.event.inputs.dry_run || 'false' }},
            "overall_status": "$OVERALL_STATUS",
            "job_results": {
              "azure_keyvault": "${{ needs.rotate-azure-keyvault.result }}",
              "database_credentials": "${{ needs.rotate-database-credentials.result }}",
              "api_keys": "${{ needs.rotate-api-keys.result }}",
              "github_secrets": "${{ needs.sync-github-secrets.result }}",
              "kubernetes_secrets": "${{ needs.sync-kubernetes-secrets.result }}",
              "workload_restart": "${{ needs.restart-workloads.result }}",
              "cleanup": "${{ needs.cleanup-old-secrets.result }}"
            },
            "run_url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          }
          EOF

          echo "Final audit report:"
          cat final-audit-report.json

      - name: Upload Final Audit Report
        uses: actions/upload-artifact@v4
        with:
          name: final-audit-report-${{ needs.prepare-rotation.outputs.rotation-id }}
          path: final-audit-report.json
          retention-days: 365

      - name: Send Success Notification
        if: steps.status.outputs.overall_status == 'success'
        run: |
          ROTATION_ID="${{ needs.prepare-rotation.outputs.rotation-id }}"

          MESSAGE="Secret Rotation Completed Successfully\n"
          MESSAGE+="Rotation ID: $ROTATION_ID\n"
          MESSAGE+="Environments: ${{ needs.prepare-rotation.outputs.environments }}\n"
          MESSAGE+="Types: ${{ needs.prepare-rotation.outputs.rotation-types }}\n"
          MESSAGE+="Triggered by: ${{ github.actor }}\n"
          MESSAGE+="Duration: ${{ github.event.repository.updated_at }}\n"
          MESSAGE+="All secrets have been rotated and workloads restarted successfully.\n"
          MESSAGE+="Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          # Send to Slack
          if [ -n "${{ env.SLACK_WEBHOOK_URL }}" ]; then
            curl -X POST "${{ env.SLACK_WEBHOOK_URL }}" \
              -H 'Content-Type: application/json' \
              -d "{\"text\":\"$MESSAGE\",\"username\":\"Secret Rotation Bot\",\"icon_emoji\":\":lock:\"}"
          fi

          # Send to Microsoft Teams
          if [ -n "${{ env.TEAMS_WEBHOOK_URL }}" ]; then
            curl -X POST "${{ env.TEAMS_WEBHOOK_URL }}" \
              -H 'Content-Type: application/json' \
              -d "{\"text\":\"$MESSAGE\"}"
          fi

      - name: Send Failure Notification
        if: steps.status.outputs.overall_status == 'failed'
        run: |
          ROTATION_ID="${{ needs.prepare-rotation.outputs.rotation-id }}"

          MESSAGE="SECRET ROTATION FAILED\n"
          MESSAGE+="Rotation ID: $ROTATION_ID\n"
          MESSAGE+="Environments: ${{ needs.prepare-rotation.outputs.environments }}\n"
          MESSAGE+="Types: ${{ needs.prepare-rotation.outputs.rotation-types }}\n"
          MESSAGE+="Triggered by: ${{ github.actor }}\n"
          MESSAGE+="IMMEDIATE ACTION REQUIRED\n"
          MESSAGE+="Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          # Send to Slack
          if [ -n "${{ env.SLACK_WEBHOOK_URL }}" ]; then
            curl -X POST "${{ env.SLACK_WEBHOOK_URL }}" \
              -H 'Content-Type: application/json' \
              -d "{\"text\":\"$MESSAGE\",\"username\":\"Secret Rotation Bot\",\"icon_emoji\":\":warning:\"}"
          fi

          # Send to PagerDuty for critical alert
          if [ -n "${{ env.PAGERDUTY_INTEGRATION_KEY }}" ]; then
            curl -X POST "https://events.pagerduty.com/v2/enqueue" \
              -H 'Content-Type: application/json' \
              -d "{
                \"routing_key\": \"${{ env.PAGERDUTY_INTEGRATION_KEY }}\",
                \"event_action\": \"trigger\",
                \"payload\": {
                  \"summary\": \"Secret Rotation Failed - $ROTATION_ID\",
                  \"severity\": \"critical\",
                  \"source\": \"github-actions\",
                  \"custom_details\": {
                    \"rotation_id\": \"$ROTATION_ID\",
                    \"environments\": \"${{ needs.prepare-rotation.outputs.environments }}\",
                    \"run_url\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\"
                  }
                }
              }"
          fi

      - name: Send Partial Success Notification
        if: steps.status.outputs.overall_status == 'partial'
        run: |
          ROTATION_ID="${{ needs.prepare-rotation.outputs.rotation-id }}"

          MESSAGE="Secret Rotation Partially Successful\n"
          MESSAGE+="Rotation ID: $ROTATION_ID\n"
          MESSAGE+="Secrets rotated successfully but workload restart encountered issues.\n"
          MESSAGE+="Manual verification recommended.\n"
          MESSAGE+="Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          if [ -n "${{ env.SLACK_WEBHOOK_URL }}" ]; then
            curl -X POST "${{ env.SLACK_WEBHOOK_URL }}" \
              -H 'Content-Type: application/json' \
              -d "{\"text\":\"$MESSAGE\",\"username\":\"Secret Rotation Bot\",\"icon_emoji\":\":warning:\"}"
          fi

      - name: Create Rollback Instructions
        if: steps.status.outputs.overall_status == 'failed'
        run: |
          cat > rollback-instructions.md <<'EOF'
          # Secret Rotation Rollback Instructions

          ## Rotation ID
          ${{ needs.prepare-rotation.outputs.rotation-id }}

          ## Rollback Steps

          ### 1. Restore from Backup
          Download the backup artifacts from this workflow run:
          - keyvault-backup-*-${{ needs.prepare-rotation.outputs.rotation-id }}

          ### 2. Restore Azure Key Vault Secrets
          ```bash
          # For each environment that was rotated
          KEYVAULT_NAME="<your-keyvault-name>"
          BACKUP_DIR="./secret-backups/<environment>"

          # Restore each secret from backup metadata
          # Note: Actual secret values are not backed up for security
          # You may need to manually revert to previous versions

          az keyvault secret list-versions --vault-name $KEYVAULT_NAME --name <secret-name>
          az keyvault secret set-attributes --vault-name $KEYVAULT_NAME --name <secret-name> --version <previous-version>
          ```

          ### 3. Restore Database Credentials
          ```bash
          # Revert to old database user
          # Drop new user if created
          # Re-enable old user
          ```

          ### 4. Restore API Keys
          - Reactivate old API keys in respective service dashboards
          - Revoke new API keys if they were created

          ### 5. Sync Restored Secrets
          - Re-run sync-github-secrets job with restored secrets
          - Re-run sync-kubernetes-secrets job
          - Restart workloads to pick up restored secrets

          ### 6. Verify Rollback
          - Test application functionality
          - Check logs for authentication errors
          - Verify database connectivity
          - Test external API integrations

          ## Support
          Contact DevOps team for assistance: devops@citadelbuy.com
          EOF

          echo "Rollback instructions created"
          cat rollback-instructions.md

      - name: Upload Rollback Instructions
        if: steps.status.outputs.overall_status == 'failed'
        uses: actions/upload-artifact@v4
        with:
          name: rollback-instructions-${{ needs.prepare-rotation.outputs.rotation-id }}
          path: rollback-instructions.md
          retention-days: 90
