import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Query,
  UseGuards,
} from '@nestjs/common';
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiBearerAuth,
  ApiParam,
  ApiQuery,
} from '@nestjs/swagger';
import { UserRole } from '@prisma/client';
import { JwtAuthGuard } from '@/common/guards/jwt-auth.guard';
import { RolesGuard } from '@/common/guards/roles.guard';
import { Roles } from '@/common/decorators/roles.decorator';
import { AiSeoService } from './ai-seo.service';
import {
  ContentOptimizationDto,
  KeywordSuggestionDto,
  ContentGapAnalysisDto,
  AutoGeneratedMetaDto,
  SeoRecommendationDto,
  TopicClusterDto,
  ContentBriefDto,
  SeoTaskDto,
  AnalyzeContentRequestDto,
  GenerateKeywordsRequestDto,
  ContentGapRequestDto,
  AutoGenerateMetaRequestDto,
  ContentBriefRequestDto,
  TopicClusterRequestDto,
  QueueTaskRequestDto,
} from '../dto/ai-seo.dto';

@ApiTags('SEO - AI Automation')
@Controller('seo/ai')
@UseGuards(JwtAuthGuard, RolesGuard)
@Roles(UserRole.ADMIN, UserRole.MARKETING)
@ApiBearerAuth()
export class AiSeoController {
  constructor(private readonly aiSeoService: AiSeoService) {}

  @Post('analyze-content')
  @ApiOperation({ summary: 'Analyze content for SEO optimization' })
  @ApiResponse({ status: 200, description: 'Content analysis results', type: ContentOptimizationDto })
  async analyzeContent(@Body() dto: AnalyzeContentRequestDto) {
    return this.aiSeoService.analyzeContent(
      dto.content,
      dto.targetKeywords,
      dto.contentType,
    );
  }

  @Post('keywords')
  @ApiOperation({ summary: 'Generate keyword suggestions' })
  @ApiResponse({ status: 200, description: 'Keyword suggestions', type: [KeywordSuggestionDto] })
  async generateKeywords(@Body() dto: GenerateKeywordsRequestDto) {
    return this.aiSeoService.generateKeywordSuggestions(
      dto.seedKeywords,
      dto.industry,
      dto.locale,
    );
  }

  @Post('content-gaps')
  @ApiOperation({ summary: 'Analyze content gaps vs competitors' })
  @ApiResponse({ status: 200, description: 'Content gap analysis', type: ContentGapAnalysisDto })
  async analyzeContentGaps(@Body() dto: ContentGapRequestDto) {
    return this.aiSeoService.analyzeContentGaps(
      dto.siteUrl,
      dto.competitorUrls,
      dto.targetKeywords,
    );
  }

  @Post('generate-meta')
  @ApiOperation({ summary: 'Auto-generate optimized meta tags' })
  @ApiResponse({ status: 200, description: 'Generated meta tags', type: AutoGeneratedMetaDto })
  async generateMeta(@Body() dto: AutoGenerateMetaRequestDto) {
    return this.aiSeoService.autoGenerateMeta(dto.content, dto.productInfo);
  }

  @Post('content-brief')
  @ApiOperation({ summary: 'Generate content brief for new content' })
  @ApiResponse({ status: 200, description: 'Content brief', type: ContentBriefDto })
  async generateContentBrief(@Body() dto: ContentBriefRequestDto) {
    return this.aiSeoService.generateContentBrief(
      dto.topic,
      dto.targetKeywords,
      dto.contentType,
    );
  }

  @Post('topic-clusters')
  @ApiOperation({ summary: 'Generate topic cluster strategy' })
  @ApiResponse({ status: 200, description: 'Topic cluster', type: TopicClusterDto })
  async generateTopicClusters(@Body() dto: TopicClusterRequestDto) {
    return this.aiSeoService.generateTopicClusters(dto.pillarTopic, dto.industry);
  }

  @Get('recommendations')
  @ApiOperation({ summary: 'Get AI-powered SEO recommendations' })
  @ApiQuery({ name: 'siteUrl', required: true })
  @ApiQuery({ name: 'focusArea', required: false, enum: ['content', 'technical', 'local', 'all'] })
  @ApiResponse({ status: 200, description: 'SEO recommendations', type: [SeoRecommendationDto] })
  async getRecommendations(
    @Query('siteUrl') siteUrl: string,
    @Query('focusArea') focusArea?: 'content' | 'technical' | 'local' | 'all',
  ) {
    return this.aiSeoService.getRecommendations(siteUrl, focusArea);
  }

  @Post('tasks')
  @ApiOperation({ summary: 'Queue an AI SEO task' })
  @ApiResponse({ status: 201, description: 'Task created', type: SeoTaskDto })
  async queueTask(@Body() dto: QueueTaskRequestDto) {
    return this.aiSeoService.queueTask(dto.type, dto.data);
  }

  @Get('tasks/:id')
  @ApiOperation({ summary: 'Get task status' })
  @ApiParam({ name: 'id', description: 'Task ID' })
  @ApiResponse({ status: 200, description: 'Task status', type: SeoTaskDto })
  async getTaskStatus(@Param('id') id: string) {
    return this.aiSeoService.getTaskStatus(id);
  }
}
