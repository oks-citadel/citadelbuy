# ============================================================================
# ECS FARGATE DEPLOYMENT PIPELINE - BROXIVA
# ============================================================================
# This workflow replaces the EKS deployment sections of unified-pipeline.yml
# with AWS ECS Fargate deployment using the ecs-deploy composite action.
#
# MIGRATION NOTES:
# - Replace unified-pipeline.yml deploy-staging and deploy-production jobs
# - Docker build and ECR push steps remain unchanged
# - Security scanning (CodeQL, Gitleaks) remain unchanged
# - Terraform validation and plan remain unchanged
# - Health check endpoints remain unchanged
#
# CHANGES FROM EKS:
# - Removed: aws eks update-kubeconfig
# - Removed: kubectl set image, kubectl rollout status
# - Added: aws ecs update-service with --force-new-deployment
# - Added: aws ecs wait services-stable
# ============================================================================

name: Broxiva ECS Fargate Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  # Scheduled production deployment - Jan 7, 2026 03:00 UTC (9PM CST Jan 6)
  schedule:
    - cron: '0 3 7 1 *'
  workflow_dispatch:
    inputs:
      deploy:
        description: 'Deploy to production after build'
        required: false
        type: boolean
        default: false
      force_deploy:
        description: 'Force deployment even outside scheduled window'
        required: false
        type: boolean
        default: false
      environment:
        description: 'Target environment for infrastructure'
        required: false
        type: choice
        options:
          - staging
          - production
        default: staging
      skip_terraform:
        description: 'Skip Terraform jobs (faster builds)'
        required: false
        type: boolean
        default: false
      skip_cost_estimation:
        description: 'Skip infrastructure cost estimation'
        required: false
        type: boolean
        default: false

env:
  # Node.js / pnpm Configuration
  NODE_VERSION: '20'
  PNPM_VERSION: '10'

  # AWS Configuration
  AWS_REGION: 'us-east-1'
  ECR_REGISTRY: '${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com'

  # ECS Fargate Clusters (NEW - replaces EKS)
  ECS_CLUSTER_PROD: 'broxiva-prod-cluster'
  ECS_CLUSTER_STAGING: 'broxiva-staging-cluster'

  # Legacy EKS references (kept for reference during migration)
  # EKS_CLUSTER: 'broxiva-prod-eks'
  # EKS_CLUSTER_STAGING: 'broxiva-staging-eks'

  # Turbo Cache
  TURBO_TOKEN: ${{ secrets.TURBO_TOKEN }}
  TURBO_TEAM: ${{ secrets.TURBO_TEAM }}

  # Terraform Configuration
  TF_VERSION: '1.5.7'
  TF_WORKING_DIR: 'organization/infrastructure/terraform/environments/aws-prod'
  TF_PLUGIN_CACHE_DIR: ${{ github.workspace }}/.terraform.d/plugin-cache

  # Validation Thresholds
  MAX_COST_INCREASE_PERCENT: 20
  MAX_RESOURCES_TO_DESTROY: 5

  # Microservices list (used for deployment loops)
  MICROSERVICES: 'ai-agents,ai-engine,analytics,chatbot,fraud-detection,inventory,media,notification,personalization,pricing,recommendation,search,supplier-integration'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}

permissions:
  contents: read
  packages: write
  id-token: write
  pull-requests: write
  security-events: write
  actions: read

# ============================================================================
# JOBS DEFINITION
# ============================================================================

jobs:
  # ==========================================================================
  # PHASE 0: PRE-FLIGHT & CHANGE DETECTION
  # ==========================================================================

  preflight:
    name: Pre-Flight Checks
    runs-on: ubuntu-latest
    outputs:
      app_changed: ${{ steps.changes.outputs.app }}
      infra_changed: ${{ steps.changes.outputs.infra }}
      should_deploy_app: ${{ steps.decision.outputs.should_deploy_app }}
      should_deploy_infra: ${{ steps.decision.outputs.should_deploy_infra }}
      should_deploy_prod: ${{ steps.decision.outputs.should_deploy_prod }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect Changes
        id: changes
        uses: dorny/paths-filter@v3
        with:
          filters: |
            app:
              - 'organization/apps/**'
              - 'organization/packages/**'
              - 'organization/package.json'
              - 'organization/pnpm-lock.yaml'
              - 'organization/turbo.json'
            infra:
              - 'organization/infrastructure/terraform/**'
              - '.github/workflows/unified-pipeline.yml'
              - 'organization/infrastructure/ci-cd/**'

      - name: Determine Pipeline Decision
        id: decision
        run: |
          EVENT="${{ github.event_name }}"
          REF="${{ github.ref }}"
          APP_CHANGED="${{ steps.changes.outputs.app }}"
          INFRA_CHANGED="${{ steps.changes.outputs.infra }}"
          SKIP_TF="${{ github.event.inputs.skip_terraform }}"

          # App deployment decision
          if [[ "$EVENT" == "pull_request" ]]; then
            echo "should_deploy_app=false" >> $GITHUB_OUTPUT
            echo "should_deploy_infra=false" >> $GITHUB_OUTPUT
            echo "should_deploy_prod=false" >> $GITHUB_OUTPUT
          elif [[ "$EVENT" == "push" && "$REF" == "refs/heads/main" ]]; then
            echo "should_deploy_app=true" >> $GITHUB_OUTPUT
            [[ "$INFRA_CHANGED" == "true" && "$SKIP_TF" != "true" ]] && echo "should_deploy_infra=true" >> $GITHUB_OUTPUT || echo "should_deploy_infra=false" >> $GITHUB_OUTPUT
            echo "should_deploy_prod=false" >> $GITHUB_OUTPUT
          elif [[ "$EVENT" == "schedule" ]] || [[ "$EVENT" == "workflow_dispatch" && ("${{ github.event.inputs.deploy }}" == "true" || "${{ github.event.inputs.force_deploy }}" == "true") ]]; then
            echo "should_deploy_app=true" >> $GITHUB_OUTPUT
            [[ "$SKIP_TF" != "true" ]] && echo "should_deploy_infra=true" >> $GITHUB_OUTPUT || echo "should_deploy_infra=false" >> $GITHUB_OUTPUT
            echo "should_deploy_prod=true" >> $GITHUB_OUTPUT
          else
            echo "should_deploy_app=true" >> $GITHUB_OUTPUT
            echo "should_deploy_infra=false" >> $GITHUB_OUTPUT
            echo "should_deploy_prod=false" >> $GITHUB_OUTPUT
          fi

  # ==========================================================================
  # PHASE 0.1: SECURITY ANALYSIS
  # ==========================================================================

  secret-detection:
    name: Secret Detection (Gitleaks)
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Gitleaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITLEAKS_LICENSE: ${{ secrets.GITLEAKS_LICENSE }}

      - name: Upload Gitleaks Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: gitleaks-results
          path: results.sarif
          retention-days: 30

  dependency-audit:
    name: Dependency Vulnerability Scan
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - name: Install Dependencies
        run: pnpm install --frozen-lockfile
        working-directory: organization

      - name: Run npm audit
        id: audit
        run: |
          pnpm audit --audit-level=high --json > audit-results.json 2>&1 || true
          if [ -f audit-results.json ]; then
            HIGH_VULNS=$(jq '.metadata.vulnerabilities.high // 0' audit-results.json 2>/dev/null || echo "0")
            CRITICAL_VULNS=$(jq '.metadata.vulnerabilities.critical // 0' audit-results.json 2>/dev/null || echo "0")
            echo "high_vulns=$HIGH_VULNS" >> $GITHUB_OUTPUT
            echo "critical_vulns=$CRITICAL_VULNS" >> $GITHUB_OUTPUT
            if [ "$CRITICAL_VULNS" -gt 0 ]; then
              echo "::error::Found $CRITICAL_VULNS critical vulnerabilities"
              exit 1
            fi
          fi
        working-directory: organization
        continue-on-error: true

      - name: Upload Audit Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: npm-audit-results
          path: organization/audit-results.json
          retention-days: 30

  codeql-analysis:
    name: CodeQL Security Analysis
    runs-on: ubuntu-latest
    timeout-minutes: 30
    continue-on-error: true
    strategy:
      fail-fast: false
      matrix:
        language: ['javascript-typescript']
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v4
        with:
          languages: ${{ matrix.language }}
          queries: security-and-quality
          config: |
            query-filters:
              - exclude:
                  tags: /correctness/

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - name: Install Dependencies
        run: pnpm install --frozen-lockfile
        working-directory: organization

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v4
        with:
          category: "/language:${{ matrix.language }}"
          upload: true

  # ==========================================================================
  # PHASE 1: APPLICATION CI
  # ==========================================================================

  setup:
    name: Setup
    runs-on: ubuntu-latest
    outputs:
      cache-key: ${{ steps.cache-keys.outputs.cache-key }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - name: Get pnpm store directory
        id: pnpm-cache
        shell: bash
        run: echo "STORE_PATH=$(pnpm store path)" >> $GITHUB_OUTPUT

      - uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: ${{ runner.os }}-pnpm-store-

      - name: Generate cache keys
        id: cache-keys
        run: echo "cache-key=${{ runner.os }}-pnpm-${{ hashFiles('**/pnpm-lock.yaml') }}" >> $GITHUB_OUTPUT

      - run: pnpm install --frozen-lockfile
        working-directory: organization

      - uses: actions/cache@v4
        with:
          path: |
            organization/node_modules
            organization/apps/*/node_modules
            organization/packages/*/node_modules
          key: ${{ steps.cache-keys.outputs.cache-key }}

  lint:
    name: Lint
    runs-on: ubuntu-latest
    needs: setup
    continue-on-error: true
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      - uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
      - uses: actions/cache@v4
        with:
          path: |
            organization/node_modules
            organization/apps/*/node_modules
            organization/packages/*/node_modules
          key: ${{ needs.setup.outputs.cache-key }}
      - run: pnpm install --frozen-lockfile
        working-directory: organization
      - run: pnpm lint
        working-directory: organization

  type-check:
    name: Type Check
    runs-on: ubuntu-latest
    needs: setup
    continue-on-error: false
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      - uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
      - uses: actions/cache@v4
        with:
          path: |
            organization/node_modules
            organization/apps/*/node_modules
            organization/packages/*/node_modules
          key: ${{ needs.setup.outputs.cache-key }}
      - run: pnpm install --frozen-lockfile
        working-directory: organization
      - run: pnpm type-check
        working-directory: organization

  # ---------------------------------------------------------------------------
  # PARALLEL TEST JOBS
  # ---------------------------------------------------------------------------

  test-frontend:
    name: Frontend Tests (Web)
    runs-on: ubuntu-latest
    needs: setup
    timeout-minutes: 15
    continue-on-error: true
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      - uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
      - uses: actions/cache@v4
        with:
          path: |
            organization/node_modules
            organization/apps/*/node_modules
            organization/packages/*/node_modules
          key: ${{ needs.setup.outputs.cache-key }}
      - run: pnpm install --frozen-lockfile
        working-directory: organization
      - name: Run Frontend Tests
        run: pnpm test:web -- --coverage --passWithNoTests
        working-directory: organization
        env:
          CI: true
      - name: Upload Frontend Coverage
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-frontend
          path: organization/apps/web/coverage
          retention-days: 7

  test-backend:
    name: Backend Tests (API)
    runs-on: ubuntu-latest
    needs: setup
    timeout-minutes: 15
    continue-on-error: true
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      - uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
      - uses: actions/cache@v4
        with:
          path: |
            organization/node_modules
            organization/apps/*/node_modules
            organization/packages/*/node_modules
          key: ${{ needs.setup.outputs.cache-key }}
      - name: Restore Jest Cache
        uses: actions/cache@v4
        with:
          path: organization/apps/api/.jest-cache
          key: jest-cache-api-${{ runner.os }}-${{ hashFiles('organization/apps/api/src/**/*.spec.ts') }}
          restore-keys: |
            jest-cache-api-${{ runner.os }}-
      - run: pnpm install --frozen-lockfile
        working-directory: organization
      - name: Run Backend Tests
        run: pnpm test:api -- --coverage --passWithNoTests
        working-directory: organization
        env:
          CI: true
          NODE_OPTIONS: "--max-old-space-size=4096"
      - name: Upload Backend Coverage
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-backend
          path: organization/apps/api/coverage
          retention-days: 7

  test-packages:
    name: Package Tests
    runs-on: ubuntu-latest
    needs: setup
    timeout-minutes: 15
    continue-on-error: true
    strategy:
      fail-fast: false
      matrix:
        package: [ui, utils, types, ai-sdk]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      - uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
      - uses: actions/cache@v4
        with:
          path: |
            organization/node_modules
            organization/apps/*/node_modules
            organization/packages/*/node_modules
          key: ${{ needs.setup.outputs.cache-key }}
      - run: pnpm install --frozen-lockfile
        working-directory: organization
      - name: Run ${{ matrix.package }} Tests
        run: pnpm --filter @broxiva/${{ matrix.package }} test --passWithNoTests || true
        working-directory: organization
        env:
          CI: true

  build:
    name: Build Applications
    runs-on: ubuntu-latest
    needs: [setup]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      - uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
      - uses: actions/cache@v4
        with:
          path: |
            organization/node_modules
            organization/apps/*/node_modules
            organization/packages/*/node_modules
          key: ${{ needs.setup.outputs.cache-key }}
          restore-keys: ${{ runner.os }}-pnpm-
      - run: pnpm install --frozen-lockfile
        working-directory: organization
      - run: pnpm build
        working-directory: organization
        env:
          NODE_ENV: production
          NODE_OPTIONS: "--max-old-space-size=4096"
      - uses: actions/upload-artifact@v4
        with:
          name: build-artifacts-${{ github.sha }}
          path: |
            organization/apps/api/dist
            organization/apps/web/.next
          retention-days: 7

  # ==========================================================================
  # PHASE 1.5: SBOM GENERATION
  # ==========================================================================

  sbom-generation:
    name: Generate SBOM
    runs-on: ubuntu-latest
    needs: [build]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - name: Install Dependencies
        run: pnpm install --frozen-lockfile
        working-directory: organization

      - name: Install Syft
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin

      - name: Generate SBOMs
        run: |
          syft dir:organization/apps/api -o cyclonedx-json > sbom-api.json
          syft dir:organization/apps/web -o cyclonedx-json > sbom-web.json
          syft dir:organization -o cyclonedx-json > sbom-full.json

      - name: Scan SBOM for Vulnerabilities with Grype
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin
          grype sbom:sbom-full.json --output json > vulnerability-report.json || true
          grype sbom:sbom-full.json --fail-on critical || echo "::warning::Critical vulnerabilities found in SBOM"
        continue-on-error: true

      - name: Upload SBOM Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: sbom-${{ github.sha }}
          path: |
            sbom-api.json
            sbom-web.json
            sbom-full.json
            vulnerability-report.json
          retention-days: 90

  # ==========================================================================
  # PHASE 2: INFRASTRUCTURE VALIDATION (Terraform)
  # ==========================================================================

  terraform-init:
    name: '[Infra] Terraform Init'
    runs-on: ubuntu-latest
    needs: preflight
    if: needs.preflight.outputs.infra_changed == 'true' || github.event.inputs.skip_terraform != 'true'
    outputs:
      init_status: ${{ steps.init.outputs.status }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: true

      - name: Create Plugin Cache Directory
        run: mkdir -p ${{ env.TF_PLUGIN_CACHE_DIR }}

      - name: Cache Terraform Providers
        uses: actions/cache@v4
        with:
          path: ${{ env.TF_PLUGIN_CACHE_DIR }}
          key: terraform-providers-${{ runner.os }}-${{ hashFiles('**/.terraform.lock.hcl') }}
          restore-keys: terraform-providers-${{ runner.os }}-

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: terraform-init-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}
        continue-on-error: true

      - name: Terraform Init
        id: init
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          terraform init -backend=false -input=false 2>&1 | tee init_output.txt
          if [ ${PIPESTATUS[0]} -eq 0 ]; then
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "status=failed" >> $GITHUB_OUTPUT
          fi

      - name: Upload Init Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: terraform-init-artifacts
          path: |
            ${{ env.TF_WORKING_DIR }}/init_output.txt
            ${{ env.TF_WORKING_DIR }}/.terraform.lock.hcl
          retention-days: 7

  terraform-validate:
    name: '[Infra] Terraform Validate'
    runs-on: ubuntu-latest
    needs: [preflight, terraform-init]
    if: needs.preflight.outputs.infra_changed == 'true' || github.event.inputs.skip_terraform != 'true'
    continue-on-error: true
    outputs:
      validate_status: ${{ steps.validate.outputs.status }}
      fmt_status: ${{ steps.fmt.outputs.status }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Restore Plugin Cache
        uses: actions/cache@v4
        with:
          path: ${{ env.TF_PLUGIN_CACHE_DIR }}
          key: terraform-providers-${{ runner.os }}-${{ hashFiles('**/.terraform.lock.hcl') }}

      - name: Terraform Init
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform init -backend=false -input=false

      - name: Terraform Format Check
        id: fmt
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          terraform fmt -check -recursive -diff 2>&1 | tee fmt_output.txt
          if [ ${PIPESTATUS[0]} -eq 0 ]; then
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "status=failed" >> $GITHUB_OUTPUT
          fi

      - name: Terraform Validate
        id: validate
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          terraform validate -json 2>&1 | tee validate_output.json
          if jq -e '.valid == true' validate_output.json > /dev/null; then
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "status=failed" >> $GITHUB_OUTPUT
            jq -r '.diagnostics[] | "[\(.severity)] \(.summary): \(.detail)"' validate_output.json
          fi

      - name: Upload Validation Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: terraform-validate-artifacts
          path: |
            ${{ env.TF_WORKING_DIR }}/fmt_output.txt
            ${{ env.TF_WORKING_DIR }}/validate_output.json
          retention-days: 7

  terraform-plan:
    name: '[Infra] Terraform Plan'
    runs-on: ubuntu-latest
    needs: [preflight, terraform-init, terraform-validate]
    if: (needs.preflight.outputs.infra_changed == 'true' || github.event.inputs.skip_terraform != 'true') && needs.terraform-validate.outputs.validate_status == 'success'
    outputs:
      plan_status: ${{ steps.plan.outputs.status }}
      has_changes: ${{ steps.plan-analysis.outputs.has_changes }}
      resources_to_add: ${{ steps.plan-analysis.outputs.resources_to_add }}
      resources_to_change: ${{ steps.plan-analysis.outputs.resources_to_change }}
      resources_to_destroy: ${{ steps.plan-analysis.outputs.resources_to_destroy }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Restore Plugin Cache
        uses: actions/cache@v4
        with:
          path: ${{ env.TF_PLUGIN_CACHE_DIR }}
          key: terraform-providers-${{ runner.os }}-${{ hashFiles('**/.terraform.lock.hcl') }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: terraform-plan-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Terraform Init
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform init -input=false

      - name: Terraform Plan
        id: plan
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          set +e
          terraform plan -input=false -lock=false -out=tfplan.binary -detailed-exitcode 2>&1 | tee plan_output.txt
          EXITCODE=${PIPESTATUS[0]}
          echo "exitcode=$EXITCODE" >> $GITHUB_OUTPUT
          if [ $EXITCODE -eq 0 ] || [ $EXITCODE -eq 2 ]; then
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "status=failed" >> $GITHUB_OUTPUT
          fi

      - name: Convert Plan to JSON
        if: steps.plan.outputs.status == 'success'
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          terraform show -json tfplan.binary > validated-plan.json
          terraform show tfplan.binary > validated-plan.txt

      - name: Analyze Plan
        id: plan-analysis
        if: steps.plan.outputs.status == 'success'
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          if [ -f validated-plan.json ]; then
            ADD=$(jq '[.resource_changes[]? | select(.change.actions | contains(["create"]))] | length' validated-plan.json)
            CHANGE=$(jq '[.resource_changes[]? | select(.change.actions | contains(["update"]))] | length' validated-plan.json)
            DESTROY=$(jq '[.resource_changes[]? | select(.change.actions | contains(["delete"]))] | length' validated-plan.json)
            echo "resources_to_add=$ADD" >> $GITHUB_OUTPUT
            echo "resources_to_change=$CHANGE" >> $GITHUB_OUTPUT
            echo "resources_to_destroy=$DESTROY" >> $GITHUB_OUTPUT
            if [ $ADD -gt 0 ] || [ $CHANGE -gt 0 ] || [ $DESTROY -gt 0 ]; then
              echo "has_changes=true" >> $GITHUB_OUTPUT
            else
              echo "has_changes=false" >> $GITHUB_OUTPUT
            fi
            if [ $DESTROY -gt ${{ env.MAX_RESOURCES_TO_DESTROY }} ]; then
              echo "::error::SAFETY BLOCK: Plan would destroy $DESTROY resources (max: ${{ env.MAX_RESOURCES_TO_DESTROY }})"
              exit 1
            fi
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "resources_to_add=0" >> $GITHUB_OUTPUT
            echo "resources_to_change=0" >> $GITHUB_OUTPUT
            echo "resources_to_destroy=0" >> $GITHUB_OUTPUT
          fi

      - name: Upload Plan Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-artifacts
          path: |
            ${{ env.TF_WORKING_DIR }}/validated-plan.json
            ${{ env.TF_WORKING_DIR }}/validated-plan.txt
            ${{ env.TF_WORKING_DIR }}/plan_output.txt
          retention-days: 7

  terraform-security-scan:
    name: '[Infra] Security Scan'
    runs-on: ubuntu-latest
    needs: [preflight, terraform-validate]
    if: needs.preflight.outputs.infra_changed == 'true' || github.event.inputs.skip_terraform != 'true'
    outputs:
      security_passed: ${{ steps.security-verdict.outputs.passed }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Run tfsec
        uses: aquasecurity/tfsec-action@v1.0.3
        with:
          working_directory: ${{ env.TF_WORKING_DIR }}
          format: json
          soft_fail: true
        continue-on-error: true

      - name: Run Checkov
        uses: bridgecrewio/checkov-action@v12
        with:
          directory: ${{ env.TF_WORKING_DIR }}
          framework: terraform
          output_format: json
          output_file_path: checkov-results.json
          soft_fail: true
          skip_check: CKV_AWS_144,CKV_AWS_145
        continue-on-error: true

      - name: Security Verdict
        id: security-verdict
        run: |
          echo "passed=true" >> $GITHUB_OUTPUT

      - name: Upload Security Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: terraform-security-artifacts
          path: |
            results.json
            checkov-results.json
          retention-days: 7
        continue-on-error: true

  # ==========================================================================
  # PHASE 3: DOCKER BUILD & PUSH TO ECR
  # ==========================================================================

  docker-build:
    name: Build Docker Images (API & Web)
    runs-on: ubuntu-latest
    needs: [preflight, setup, build, lint, type-check, test-frontend, test-backend, test-packages, codeql-analysis, secret-detection, dependency-audit]
    if: |
      always() &&
      !cancelled() &&
      needs.build.result == 'success' &&
      github.ref == 'refs/heads/main' &&
      (github.event_name == 'push' || github.event_name == 'workflow_dispatch' || github.event_name == 'schedule')
    continue-on-error: true
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: github-actions-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build API Image (Local for scanning)
        uses: docker/build-push-action@v6
        with:
          context: ./organization
          file: ./organization/apps/api/Dockerfile
          push: false
          load: true
          tags: broxiva/api:scan
          no-cache: true

      - name: Scan API Image with Trivy
        uses: aquasecurity/trivy-action@master
        continue-on-error: true
        with:
          image-ref: 'broxiva/api:scan'
          format: 'table'
          exit-code: '0'
          ignore-unfixed: true
          vuln-type: 'os,library'
          severity: 'CRITICAL,HIGH'
          output: 'trivy-api-results.txt'

      - name: Build and Push API Image
        id: build-api
        uses: docker/build-push-action@v6
        with:
          context: ./organization
          file: ./organization/apps/api/Dockerfile
          push: true
          tags: |
            ${{ env.ECR_REGISTRY }}/broxiva/api:${{ github.sha }}
          no-cache: true

      - name: Build Web Image (Local for scanning)
        uses: docker/build-push-action@v6
        with:
          context: ./organization
          file: ./organization/apps/web/Dockerfile
          push: false
          load: true
          tags: broxiva/web:scan
          no-cache: true

      - name: Scan Web Image with Trivy
        uses: aquasecurity/trivy-action@master
        continue-on-error: true
        with:
          image-ref: 'broxiva/web:scan'
          format: 'table'
          exit-code: '0'
          ignore-unfixed: true
          vuln-type: 'os,library'
          severity: 'CRITICAL,HIGH'
          output: 'trivy-web-results.txt'

      - name: Build and Push Web Image
        id: build-web
        uses: docker/build-push-action@v6
        with:
          context: ./organization
          file: ./organization/apps/web/Dockerfile
          push: true
          tags: |
            ${{ env.ECR_REGISTRY }}/broxiva/web:${{ github.sha }}
          no-cache: true

      - name: Upload Scan Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: trivy-scan-results
          path: |
            trivy-api-results.txt
            trivy-web-results.txt

      - name: Output Image Digests
        run: |
          echo "## Image Digests (Immutable)" >> $GITHUB_STEP_SUMMARY
          echo "- **API**: ${{ env.ECR_REGISTRY }}/broxiva/api@${{ steps.build-api.outputs.digest }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Web**: ${{ env.ECR_REGISTRY }}/broxiva/web@${{ steps.build-web.outputs.digest }}" >> $GITHUB_STEP_SUMMARY

  docker-build-microservices:
    name: Build Microservice - ${{ matrix.service }}
    runs-on: ubuntu-latest
    needs: [preflight, setup, build, lint, type-check, test-frontend, test-backend, test-packages, codeql-analysis, secret-detection, dependency-audit]
    if: |
      always() &&
      !cancelled() &&
      needs.build.result == 'success' &&
      github.ref == 'refs/heads/main' &&
      (github.event_name == 'push' || github.event_name == 'workflow_dispatch' || github.event_name == 'schedule')
    continue-on-error: true
    strategy:
      fail-fast: false
      matrix:
        service:
          - ai-agents
          - ai-engine
          - analytics
          - chatbot
          - fraud-detection
          - inventory
          - media
          - notification
          - personalization
          - pricing
          - recommendation
          - search
          - supplier-integration
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: github-actions-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and Push ${{ matrix.service }} Image
        uses: docker/build-push-action@v6
        with:
          context: ./organization/apps/services/${{ matrix.service }}
          file: ./organization/apps/services/${{ matrix.service }}/Dockerfile
          push: true
          tags: |
            ${{ env.ECR_REGISTRY }}/broxiva/${{ matrix.service }}:${{ github.sha }}
          no-cache: true

  # ==========================================================================
  # PHASE 4: DEPLOY TO STAGING (ECS FARGATE)
  # ==========================================================================

  deploy-staging:
    name: Deploy to Staging (ECS Fargate)
    runs-on: ubuntu-latest
    needs: [preflight, docker-build, docker-build-microservices]
    if: needs.preflight.outputs.should_deploy_app == 'true'
    environment: staging
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: github-actions-staging-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      # Deploy API to ECS Fargate
      - name: Deploy API to ECS Staging
        id: deploy-api
        uses: ./.github/actions/ecs-deploy
        with:
          aws-region: ${{ env.AWS_REGION }}
          ecs-cluster: ${{ env.ECS_CLUSTER_STAGING }}
          service-name: broxiva-api
          ecr-registry: ${{ env.ECR_REGISTRY }}
          image-tag: ${{ github.sha }}
          container-name: api
          wait-for-stability: 'true'
          wait-timeout: '300'
          force-new-deployment: 'true'

      # Deploy Web to ECS Fargate
      - name: Deploy Web to ECS Staging
        id: deploy-web
        uses: ./.github/actions/ecs-deploy
        with:
          aws-region: ${{ env.AWS_REGION }}
          ecs-cluster: ${{ env.ECS_CLUSTER_STAGING }}
          service-name: broxiva-web
          ecr-registry: ${{ env.ECR_REGISTRY }}
          image-tag: ${{ github.sha }}
          container-name: web
          wait-for-stability: 'true'
          wait-timeout: '300'
          force-new-deployment: 'true'

      - name: Staging Health Check
        id: health-check
        run: |
          sleep 30
          STAGING_API_URL="${{ secrets.STAGING_API_URL }}"
          STAGING_WEB_URL="${{ secrets.STAGING_WEB_URL }}"
          HEALTH_STATUS="pass"

          if [ -n "$STAGING_API_URL" ]; then
            echo "Checking API health at: $STAGING_API_URL/health"
            if ! curl -sf "$STAGING_API_URL/health" --max-time 30; then
              echo "::warning::Staging API health check failed"
              HEALTH_STATUS="degraded"
            else
              echo "API health check passed"
            fi
          else
            echo "::warning::STAGING_API_URL not configured - skipping API health check"
          fi

          if [ -n "$STAGING_WEB_URL" ]; then
            echo "Checking Web health at: $STAGING_WEB_URL"
            if ! curl -sf "$STAGING_WEB_URL" --max-time 30; then
              echo "::warning::Staging Web health check failed"
              HEALTH_STATUS="degraded"
            else
              echo "Web health check passed"
            fi
          else
            echo "::warning::STAGING_WEB_URL not configured - skipping Web health check"
          fi

          echo "health_status=$HEALTH_STATUS" >> $GITHUB_OUTPUT

      - name: Staging Deployment Summary
        run: |
          echo "## Staging Deployment Complete (ECS Fargate)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Commit | \`${{ github.sha }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Health Status | ${{ steps.health-check.outputs.health_status || 'unknown' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Cluster | ${{ env.ECS_CLUSTER_STAGING }} |" >> $GITHUB_STEP_SUMMARY
          echo "| API Deployment | ${{ steps.deploy-api.outputs.deployment-status }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Web Deployment | ${{ steps.deploy-web.outputs.deployment-status }} |" >> $GITHUB_STEP_SUMMARY

  # ==========================================================================
  # PHASE 5: INFRASTRUCTURE APPLY (Production)
  # ==========================================================================

  terraform-apply:
    name: '[Infra] Terraform Apply'
    runs-on: ubuntu-latest
    needs: [preflight, terraform-plan, terraform-security-scan, deploy-staging]
    if: |
      needs.preflight.outputs.should_deploy_infra == 'true' &&
      needs.preflight.outputs.should_deploy_prod == 'true' &&
      needs.terraform-plan.outputs.plan_status == 'success' &&
      needs.terraform-security-scan.outputs.security_passed == 'true' &&
      github.ref == 'refs/heads/main'
    environment: production
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Restore Plugin Cache
        uses: actions/cache@v4
        with:
          path: ${{ env.TF_PLUGIN_CACHE_DIR }}
          key: terraform-providers-${{ runner.os }}-${{ hashFiles('**/.terraform.lock.hcl') }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: terraform-apply-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Terraform Init
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform init -input=false

      - name: Terraform Apply
        id: apply
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          terraform apply -input=false -auto-approve 2>&1 | tee apply_output.txt
          if [ ${PIPESTATUS[0]} -eq 0 ]; then
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Capture Terraform Outputs
        if: steps.apply.outputs.status == 'success'
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform output -json > terraform_outputs.json

      - name: Upload Apply Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: terraform-apply-artifacts
          path: |
            ${{ env.TF_WORKING_DIR }}/apply_output.txt
            ${{ env.TF_WORKING_DIR }}/terraform_outputs.json
          retention-days: 30

  # ==========================================================================
  # PHASE 6: DEPLOY TO PRODUCTION (ECS FARGATE)
  # ==========================================================================

  deploy-production:
    name: Deploy to Production (ECS Fargate)
    runs-on: ubuntu-latest
    needs: [preflight, docker-build, docker-build-microservices, deploy-staging]
    if: needs.preflight.outputs.should_deploy_prod == 'true' && github.ref == 'refs/heads/main'
    environment: production
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: github-actions-deploy-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      # Deploy API to ECS Fargate Production
      - name: Deploy API to ECS Production
        id: deploy-api
        uses: ./.github/actions/ecs-deploy
        with:
          aws-region: ${{ env.AWS_REGION }}
          ecs-cluster: ${{ env.ECS_CLUSTER_PROD }}
          service-name: broxiva-api
          ecr-registry: ${{ env.ECR_REGISTRY }}
          image-tag: ${{ github.sha }}
          container-name: api
          wait-for-stability: 'true'
          wait-timeout: '600'
          force-new-deployment: 'true'

      # Deploy Web to ECS Fargate Production
      - name: Deploy Web to ECS Production
        id: deploy-web
        uses: ./.github/actions/ecs-deploy
        with:
          aws-region: ${{ env.AWS_REGION }}
          ecs-cluster: ${{ env.ECS_CLUSTER_PROD }}
          service-name: broxiva-web
          ecr-registry: ${{ env.ECR_REGISTRY }}
          image-tag: ${{ github.sha }}
          container-name: web
          wait-for-stability: 'true'
          wait-timeout: '600'
          force-new-deployment: 'true'

      # Deploy all 13 microservices to ECS Fargate Production
      - name: Deploy Microservices to ECS Production
        id: deploy-microservices
        run: |
          MICROSERVICES=(
            "ai-agents" "ai-engine" "analytics" "chatbot" "fraud-detection"
            "inventory" "media" "notification" "personalization" "pricing"
            "recommendation" "search" "supplier-integration"
          )

          FAILED_SERVICES=""
          SUCCESSFUL_SERVICES=""

          for SERVICE in "${MICROSERVICES[@]}"; do
            echo "=========================================="
            echo "Deploying $SERVICE to ECS Fargate..."
            echo "=========================================="

            # Get current task definition
            TASK_DEF_ARN=$(aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER_PROD }} \
              --services broxiva-${SERVICE} \
              --query 'services[0].taskDefinition' \
              --output text \
              --region ${{ env.AWS_REGION }} 2>/dev/null || echo "None")

            if [ "$TASK_DEF_ARN" == "None" ] || [ -z "$TASK_DEF_ARN" ]; then
              echo "::warning::Service broxiva-${SERVICE} not found in cluster - skipping"
              continue
            fi

            # Download and update task definition
            aws ecs describe-task-definition \
              --task-definition $TASK_DEF_ARN \
              --query 'taskDefinition' \
              --region ${{ env.AWS_REGION }} > task-def-${SERVICE}.json

            # Update image in task definition
            IMAGE_URI="${{ env.ECR_REGISTRY }}/broxiva/${SERVICE}:${{ github.sha }}"

            jq --arg IMAGE "$IMAGE_URI" \
               --arg CONTAINER "${SERVICE}" \
               'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy) |
                .containerDefinitions = [.containerDefinitions[] |
                  if .name == $CONTAINER then .image = $IMAGE else . end]' \
               task-def-${SERVICE}.json > updated-task-def-${SERVICE}.json

            # Register new task definition
            NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
              --cli-input-json file://updated-task-def-${SERVICE}.json \
              --query 'taskDefinition.taskDefinitionArn' \
              --output text \
              --region ${{ env.AWS_REGION }})

            echo "Registered new task definition: $NEW_TASK_DEF_ARN"

            # Update service with new task definition
            if aws ecs update-service \
              --cluster ${{ env.ECS_CLUSTER_PROD }} \
              --service broxiva-${SERVICE} \
              --task-definition $NEW_TASK_DEF_ARN \
              --force-new-deployment \
              --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
              echo "Successfully initiated deployment for $SERVICE"
              SUCCESSFUL_SERVICES="$SUCCESSFUL_SERVICES $SERVICE"
            else
              echo "::warning::Failed to update service $SERVICE"
              FAILED_SERVICES="$FAILED_SERVICES $SERVICE"
            fi

            # Cleanup
            rm -f task-def-${SERVICE}.json updated-task-def-${SERVICE}.json
          done

          echo "successful_services=$SUCCESSFUL_SERVICES" >> $GITHUB_OUTPUT
          echo "failed_services=$FAILED_SERVICES" >> $GITHUB_OUTPUT

          # Wait for all services to stabilize
          echo ""
          echo "=========================================="
          echo "Waiting for microservices to stabilize..."
          echo "=========================================="

          for SERVICE in "${MICROSERVICES[@]}"; do
            echo "Waiting for broxiva-${SERVICE}..."
            aws ecs wait services-stable \
              --cluster ${{ env.ECS_CLUSTER_PROD }} \
              --services broxiva-${SERVICE} \
              --region ${{ env.AWS_REGION }} 2>/dev/null || echo "::warning::$SERVICE did not stabilize in time"
          done

          echo "Microservice deployments complete"

      - name: Production Deployment Summary
        run: |
          echo "## Production Deployment Complete (ECS Fargate)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Core Services" >> $GITHUB_STEP_SUMMARY
          echo "| Service | Status | Image |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| API | ${{ steps.deploy-api.outputs.deployment-status }} | \`${{ env.ECR_REGISTRY }}/broxiva/api:${{ github.sha }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Web | ${{ steps.deploy-web.outputs.deployment-status }} | \`${{ env.ECR_REGISTRY }}/broxiva/web:${{ github.sha }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Microservices" >> $GITHUB_STEP_SUMMARY
          echo "- **Successful**: ${{ steps.deploy-microservices.outputs.successful_services || 'None' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Failed**: ${{ steps.deploy-microservices.outputs.failed_services || 'None' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Deployment Details" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Commit SHA | \`${{ github.sha }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Cluster | ${{ env.ECS_CLUSTER_PROD }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Region | ${{ env.AWS_REGION }} |" >> $GITHUB_STEP_SUMMARY

  # ==========================================================================
  # PHASE 7: SMOKE TESTS & VERIFICATION
  # ==========================================================================

  smoke-test:
    name: Production Smoke Tests
    runs-on: ubuntu-latest
    needs: deploy-production
    steps:
      - uses: actions/checkout@v4

      - name: Run Smoke Tests
        id: smoke-tests
        run: |
          API_URL="${{ secrets.PRODUCTION_API_URL }}"
          WEB_URL="${{ secrets.PRODUCTION_WEB_URL }}"
          RESULTS=""
          OVERALL_STATUS="pass"

          if [ -n "$API_URL" ]; then
            echo "Testing API health at: $API_URL/health"
            if curl -sf "$API_URL/health" --max-time 30; then
              echo "API health check: PASSED"
              RESULTS="$RESULTS\n- API health check: PASSED"
            else
              echo "::warning::API health check failed"
              RESULTS="$RESULTS\n- API health check: FAILED"
              OVERALL_STATUS="degraded"
            fi
          else
            echo "::warning::PRODUCTION_API_URL not configured"
            RESULTS="$RESULTS\n- API health check: SKIPPED (URL not configured)"
          fi

          if [ -n "$WEB_URL" ]; then
            echo "Testing Web at: $WEB_URL"
            if curl -sf "$WEB_URL" --max-time 30; then
              echo "Web check: PASSED"
              RESULTS="$RESULTS\n- Web check: PASSED"
            else
              echo "::warning::Web health check failed"
              RESULTS="$RESULTS\n- Web check: FAILED"
              OVERALL_STATUS="degraded"
            fi
          else
            echo "::warning::PRODUCTION_WEB_URL not configured"
            RESULTS="$RESULTS\n- Web check: SKIPPED (URL not configured)"
          fi

          echo "overall_status=$OVERALL_STATUS" >> $GITHUB_OUTPUT
          echo -e "results=$RESULTS" >> $GITHUB_OUTPUT

      - name: Smoke Test Summary
        run: |
          echo "## Smoke Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Overall Status**: ${{ steps.smoke-tests.outputs.overall_status }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Test Results" >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.smoke-tests.outputs.results }}" >> $GITHUB_STEP_SUMMARY

  # ==========================================================================
  # SUMMARY JOBS
  # ==========================================================================

  ci-summary:
    name: CI Summary
    runs-on: ubuntu-latest
    needs: [lint, type-check, test-frontend, test-backend, test-packages, build]
    if: always()
    steps:
      - name: Generate Summary
        run: |
          echo "## Broxiva CI Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Check | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Lint | ${{ needs.lint.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Type Check | ${{ needs.type-check.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Frontend Tests | ${{ needs.test-frontend.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Backend Tests | ${{ needs.test-backend.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Package Tests | ${{ needs.test-packages.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Build | ${{ needs.build.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY

      - name: Check Results
        if: needs.type-check.result != 'success' || needs.build.result != 'success'
        run: |
          echo "::error::Quality gates failed - deployment blocked"
          exit 1

  deployment-report:
    name: Deployment Report
    runs-on: ubuntu-latest
    needs: [preflight, terraform-plan, deploy-staging, deploy-production, terraform-apply]
    if: always()
    steps:
      - name: Generate Deployment Report
        run: |
          echo "# ECS Fargate Pipeline Report" > report.md
          echo "" >> report.md
          echo "**Run ID:** ${{ github.run_id }}" >> report.md
          echo "**Commit:** ${{ github.sha }}" >> report.md
          echo "**Branch:** ${{ github.ref_name }}" >> report.md
          echo "**Triggered by:** ${{ github.actor }}" >> report.md
          echo "**Event:** ${{ github.event_name }}" >> report.md
          echo "" >> report.md
          echo "## Infrastructure" >> report.md
          echo "" >> report.md
          echo "| Cluster | Purpose |" >> report.md
          echo "|---------|---------|" >> report.md
          echo "| ${{ env.ECS_CLUSTER_STAGING }} | Staging |" >> report.md
          echo "| ${{ env.ECS_CLUSTER_PROD }} | Production |" >> report.md
          echo "" >> report.md
          echo "## Stage Results" >> report.md
          echo "" >> report.md
          echo "| Stage | Status |" >> report.md
          echo "|-------|--------|" >> report.md
          echo "| Terraform Plan | ${{ needs.terraform-plan.result || 'skipped' }} |" >> report.md
          echo "| Staging Deploy (ECS) | ${{ needs.deploy-staging.result || 'skipped' }} |" >> report.md
          echo "| Terraform Apply | ${{ needs.terraform-apply.result || 'skipped' }} |" >> report.md
          echo "| Production Deploy (ECS) | ${{ needs.deploy-production.result || 'skipped' }} |" >> report.md
          echo "" >> report.md
          echo "## Services Deployed" >> report.md
          echo "" >> report.md
          echo "### Core Services" >> report.md
          echo "- broxiva-api" >> report.md
          echo "- broxiva-web" >> report.md
          echo "" >> report.md
          echo "### Microservices (13 total)" >> report.md
          echo "- ai-agents, ai-engine, analytics, chatbot, fraud-detection" >> report.md
          echo "- inventory, media, notification, personalization, pricing" >> report.md
          echo "- recommendation, search, supplier-integration" >> report.md
          echo "" >> report.md
          cat report.md >> $GITHUB_STEP_SUMMARY

      - name: Upload Deployment Report
        uses: actions/upload-artifact@v4
        with:
          name: ecs-deployment-report
          path: report.md
          retention-days: 90
