import { Injectable, Logger } from '@nestjs/common';
import { PrismaService } from '@/common/prisma/prisma.service';
import { CacheService, CacheTTL } from '@/common/redis/cache.service';
import {
  ContentOptimizationDto,
  KeywordSuggestionDto,
  ContentGapAnalysisDto,
  CompetitorAnalysisDto,
  AutoGeneratedMetaDto,
  SeoRecommendationDto,
  ContentScoreDto,
  TopicClusterDto,
  SearchIntentDto,
  ContentBriefDto,
  SeoTaskDto,
  SeoTaskStatus,
} from '../dto/ai-seo.dto';

@Injectable()
export class AiSeoService {
  private readonly logger = new Logger(AiSeoService.name);
  private readonly cachePrefix = 'seo:ai:';

  // In-memory task queue for AI processing
  private taskQueue: Map<string, SeoTaskDto> = new Map();

  // Simulated AI model config
  private readonly AI_CONFIG = {
    modelVersion: 'seo-optimizer-v2',
    maxTokens: 4000,
    temperature: 0.7,
  };

  constructor(
    private readonly prisma: PrismaService,
    private readonly cacheService: CacheService,
  ) {}

  /**
   * Analyze content and provide optimization suggestions
   */
  async analyzeContent(
    content: string,
    targetKeywords: string[],
    contentType: 'product' | 'category' | 'blog' | 'page' = 'page',
  ): Promise<ContentOptimizationDto> {
    const cacheKey = `${this.cachePrefix}content:${this.hashContent(content)}:${targetKeywords.join(',')}`;
    const cached = await this.cacheService.get<ContentOptimizationDto>(cacheKey);
    if (cached) return cached;

    // Analyze content
    const wordCount = content.split(/\s+/).length;
    const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);
    const avgSentenceLength = wordCount / sentences.length;

    // Keyword analysis
    const contentLower = content.toLowerCase();
    const keywordAnalysis = targetKeywords.map(keyword => {
      const keywordLower = keyword.toLowerCase();
      const count = (contentLower.match(new RegExp(keywordLower, 'g')) || []).length;
      const density = (count / wordCount) * 100;
      const inTitle = content.slice(0, 100).toLowerCase().includes(keywordLower);
      const inFirstParagraph = content.slice(0, 500).toLowerCase().includes(keywordLower);

      return {
        keyword,
        count,
        density: Math.round(density * 100) / 100,
        isOptimal: density >= 0.5 && density <= 2.5,
        inTitle,
        inFirstParagraph,
        suggestions: this.getKeywordSuggestions(keyword, density, inTitle, inFirstParagraph),
      };
    });

    // Readability analysis
    const readabilityScore = this.calculateReadability(content);
    const readabilityGrade = this.getReadabilityGrade(readabilityScore);

    // Structure analysis
    const hasHeaders = /#{1,6}\s|<h[1-6]>/i.test(content);
    const hasLists = /[-*]\s|<[ou]l>/i.test(content);
    const hasLinks = /\[.*\]\(.*\)|<a\s/i.test(content);
    const hasImages = /!\[.*\]\(.*\)|<img/i.test(content);

    // Generate optimization suggestions
    const suggestions: string[] = [];
    const opportunities: string[] = [];
    const warnings: string[] = [];

    // Content length
    const idealLength = this.getIdealLength(contentType);
    if (wordCount < idealLength.min) {
      suggestions.push(`Content is short (${wordCount} words). Aim for ${idealLength.min}-${idealLength.max} words for better rankings.`);
    } else if (wordCount > idealLength.max) {
      warnings.push(`Content may be too long (${wordCount} words). Consider breaking into multiple pages.`);
    }

    // Readability
    if (readabilityScore < 60) {
      suggestions.push('Improve readability by using shorter sentences and simpler words.');
    }

    // Structure
    if (!hasHeaders) {
      suggestions.push('Add headings (H2, H3) to structure your content and improve scannability.');
    }
    if (!hasLists && wordCount > 300) {
      opportunities.push('Consider adding bullet points or numbered lists to break up content.');
    }
    if (!hasImages) {
      opportunities.push('Add relevant images to increase engagement and visual appeal.');
    }
    if (!hasLinks) {
      opportunities.push('Add internal and external links to provide additional value and context.');
    }

    // Keyword optimization
    for (const kw of keywordAnalysis) {
      if (!kw.isOptimal) {
        if (kw.density < 0.5) {
          suggestions.push(`Increase usage of "${kw.keyword}" (currently ${kw.density}%, aim for 0.5-2.5%).`);
        } else if (kw.density > 2.5) {
          warnings.push(`"${kw.keyword}" appears too frequently (${kw.density}%). Reduce to avoid keyword stuffing.`);
        }
      }
      if (!kw.inTitle) {
        suggestions.push(`Include "${kw.keyword}" in your title or first heading.`);
      }
      if (!kw.inFirstParagraph) {
        opportunities.push(`Mention "${kw.keyword}" in the first paragraph for better relevance signals.`);
      }
    }

    // Calculate overall score
    let score = 100;
    score -= suggestions.length * 5;
    score -= warnings.length * 10;
    score -= opportunities.length * 2;
    score = Math.max(0, Math.min(100, score));

    const result: ContentOptimizationDto = {
      score,
      grade: this.getGrade(score),
      wordCount,
      readability: {
        score: readabilityScore,
        grade: readabilityGrade,
        avgSentenceLength: Math.round(avgSentenceLength),
      },
      keywords: keywordAnalysis,
      structure: {
        hasHeaders,
        hasLists,
        hasLinks,
        hasImages,
        paragraphCount: sentences.length,
      },
      suggestions,
      opportunities,
      warnings,
      estimatedImpact: this.estimateImpact(suggestions.length, warnings.length),
    };

    await this.cacheService.set(cacheKey, result, { ttl: CacheTTL.SHORT });
    return result;
  }

  /**
   * Generate keyword suggestions based on seed keywords
   */
  async generateKeywordSuggestions(
    seedKeywords: string[],
    industry?: string,
    locale: string = 'en-US',
  ): Promise<KeywordSuggestionDto[]> {
    const suggestions: KeywordSuggestionDto[] = [];

    for (const seed of seedKeywords) {
      // Generate long-tail variations
      const variations = this.generateKeywordVariations(seed);

      for (const variation of variations) {
        suggestions.push({
          keyword: variation.keyword,
          searchVolume: Math.floor(Math.random() * 10000) + 100,
          difficulty: Math.floor(Math.random() * 100),
          cpc: Math.round((Math.random() * 5 + 0.5) * 100) / 100,
          intent: this.classifySearchIntent(variation.keyword),
          trend: Math.random() > 0.5 ? 'rising' : 'stable',
          relatedKeywords: this.getRelatedKeywords(variation.keyword),
          serp: {
            hasFeatureSnippet: Math.random() > 0.7,
            hasPeopleAlsoAsk: Math.random() > 0.5,
            hasLocalPack: Math.random() > 0.8,
            hasImages: Math.random() > 0.6,
            hasVideos: Math.random() > 0.7,
          },
        });
      }
    }

    // Sort by opportunity score (volume / difficulty)
    suggestions.sort((a, b) => {
      const scoreA = a.searchVolume / (a.difficulty + 1);
      const scoreB = b.searchVolume / (b.difficulty + 1);
      return scoreB - scoreA;
    });

    return suggestions.slice(0, 50);
  }

  /**
   * Analyze content gaps compared to competitors
   */
  async analyzeContentGaps(
    siteUrl: string,
    competitorUrls: string[],
    targetKeywords?: string[],
  ): Promise<ContentGapAnalysisDto> {
    // Simulate content gap analysis
    const gaps: ContentGapAnalysisDto['gaps'] = [];
    const commonKeywords = [
      'buying guide', 'comparison', 'review', 'best', 'how to',
      'tutorial', 'tips', 'examples', 'alternatives', 'vs',
    ];

    for (const keyword of commonKeywords) {
      const inSite = Math.random() > 0.5;
      const inCompetitors = Math.floor(Math.random() * competitorUrls.length);

      if (!inSite && inCompetitors > 0) {
        gaps.push({
          keyword,
          yourCoverage: inSite,
          competitorsCovering: inCompetitors,
          searchVolume: Math.floor(Math.random() * 5000) + 500,
          difficulty: Math.floor(Math.random() * 100),
          priority: inCompetitors >= competitorUrls.length / 2 ? 'high' : 'medium',
          suggestedContentType: this.suggestContentType(keyword),
        });
      }
    }

    // Generate topic opportunities
    const topicOpportunities = [
      {
        topic: 'Ultimate Buying Guide',
        description: 'Comprehensive guide to help customers make informed decisions',
        estimatedTraffic: Math.floor(Math.random() * 10000) + 1000,
        competitionLevel: 'medium',
      },
      {
        topic: 'Product Comparisons',
        description: 'Side-by-side comparisons of popular products',
        estimatedTraffic: Math.floor(Math.random() * 8000) + 800,
        competitionLevel: 'high',
      },
      {
        topic: 'How-To Tutorials',
        description: 'Step-by-step guides for using products',
        estimatedTraffic: Math.floor(Math.random() * 5000) + 500,
        competitionLevel: 'low',
      },
    ];

    return {
      siteUrl,
      competitors: competitorUrls,
      gaps: gaps.sort((a, b) => {
        const priorityOrder = { high: 0, medium: 1, low: 2 };
        return priorityOrder[a.priority] - priorityOrder[b.priority];
      }),
      topicOpportunities,
      totalGaps: gaps.length,
      highPriorityGaps: gaps.filter(g => g.priority === 'high').length,
      estimatedTrafficOpportunity: gaps.reduce((sum, g) => sum + g.searchVolume, 0),
    };
  }

  /**
   * Auto-generate optimized meta tags
   */
  async autoGenerateMeta(
    content: string,
    productInfo?: {
      name: string;
      price?: number;
      brand?: string;
      category?: string;
    },
  ): Promise<AutoGeneratedMetaDto> {
    // Extract key information from content
    const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 20);
    const words = content.toLowerCase().split(/\s+/);

    // Extract potential keywords
    const keywords = this.extractKeywords(content);

    // Generate title
    let title = '';
    if (productInfo?.name) {
      title = `${productInfo.name}`;
      if (productInfo.brand) {
        title += ` by ${productInfo.brand}`;
      }
      title += ' | Buy Online';
    } else {
      // Use first meaningful sentence as base
      title = sentences[0]?.slice(0, 50) || 'Page Title';
    }

    // Ensure title is optimal length
    if (title.length > 60) {
      title = title.slice(0, 57) + '...';
    } else if (title.length < 30) {
      title += ' - Best Deals & Free Shipping';
    }

    // Generate description
    let description = '';
    if (productInfo?.name) {
      description = `Shop ${productInfo.name}`;
      if (productInfo.price) {
        description += ` at $${productInfo.price}`;
      }
      description += '. ';
      if (sentences[0]) {
        description += sentences[0].slice(0, 100);
      }
      description += ' Free shipping on orders over $50.';
    } else {
      description = sentences.slice(0, 2).join('. ').slice(0, 155);
    }

    // Ensure description is optimal length
    if (description.length > 160) {
      description = description.slice(0, 157) + '...';
    } else if (description.length < 120) {
      description += ' Shop now for the best deals.';
    }

    // Generate Open Graph data
    const openGraph = {
      title: title.replace(' | Buy Online', ''),
      description: description.slice(0, 200),
      type: productInfo ? 'product' : 'website',
    };

    // Generate Twitter Card
    const twitterCard = {
      card: 'summary_large_image' as const,
      title: title.slice(0, 70),
      description: description.slice(0, 200),
    };

    // Calculate confidence scores
    const titleScore = this.scoreMeta(title, 30, 60);
    const descriptionScore = this.scoreMeta(description, 120, 160);

    return {
      title,
      description,
      keywords: keywords.slice(0, 10),
      openGraph,
      twitterCard,
      confidence: {
        title: titleScore,
        description: descriptionScore,
        overall: Math.round((titleScore + descriptionScore) / 2),
      },
      alternatives: {
        titles: [
          title,
          `Buy ${productInfo?.name || 'Products'} Online - Best Prices`,
          `${productInfo?.name || 'Quality Products'} - Free Shipping`,
        ],
        descriptions: [
          description,
          `Discover ${productInfo?.name || 'our products'}. ${keywords.slice(0, 3).join(', ')}. Shop now!`,
        ],
      },
    };
  }

  /**
   * Generate content brief for new content
   */
  async generateContentBrief(
    topic: string,
    targetKeywords: string[],
    contentType: 'blog' | 'product' | 'category' | 'landing' = 'blog',
  ): Promise<ContentBriefDto> {
    // Analyze topic
    const intent = this.classifySearchIntent(topic);

    // Generate outline
    const outline = this.generateOutline(topic, contentType, intent);

    // Generate related questions
    const relatedQuestions = this.generateRelatedQuestions(topic);

    // Calculate ideal metrics
    const idealMetrics = this.getContentMetrics(contentType, intent);

    return {
      topic,
      targetKeywords,
      searchIntent: intent,
      contentType,
      suggestedOutline: outline,
      relatedQuestions,
      recommendedLength: idealMetrics.wordCount,
      keywordTargets: targetKeywords.map(kw => ({
        keyword: kw,
        targetDensity: '1-2%',
        placement: ['title', 'first paragraph', 'headings', 'conclusion'],
      })),
      competitorInsights: {
        avgWordCount: idealMetrics.wordCount,
        commonHeadings: outline.map(s => s.heading),
        topRankingFactors: ['Comprehensive content', 'Good structure', 'Internal linking', 'Expert authorship'],
      },
      contentGuidelines: [
        'Start with a compelling introduction that addresses user intent',
        'Use H2 and H3 headings to structure content logically',
        'Include relevant internal and external links',
        'Add images with descriptive alt text',
        'End with a clear call-to-action',
        'Ensure mobile-friendly formatting',
      ],
      estimatedTime: `${Math.ceil(idealMetrics.wordCount / 500)} hours`,
    };
  }

  /**
   * Generate topic clusters for content strategy
   */
  async generateTopicClusters(
    pillarTopic: string,
    industry?: string,
  ): Promise<TopicClusterDto> {
    // Generate pillar content ideas
    const pillarContent = {
      title: `Ultimate Guide to ${pillarTopic}`,
      description: `Comprehensive resource covering everything about ${pillarTopic}`,
      targetKeywords: [pillarTopic, `${pillarTopic} guide`, `what is ${pillarTopic}`],
      estimatedWordCount: 3000,
    };

    // Generate cluster topics
    const clusterTopics = [
      { prefix: 'How to', suffix: '' },
      { prefix: 'Best', suffix: 'practices' },
      { prefix: '', suffix: 'tips' },
      { prefix: '', suffix: 'examples' },
      { prefix: '', suffix: 'benefits' },
      { prefix: '', suffix: 'mistakes to avoid' },
      { prefix: '', suffix: 'vs alternatives' },
      { prefix: '', suffix: 'for beginners' },
    ].map(template => ({
      title: `${template.prefix} ${pillarTopic} ${template.suffix}`.trim(),
      keywords: [`${template.prefix} ${pillarTopic} ${template.suffix}`.trim().toLowerCase()],
      searchVolume: Math.floor(Math.random() * 5000) + 500,
      priority: (Math.random() > 0.6 ? 'high' : Math.random() > 0.3 ? 'medium' : 'low') as 'high' | 'medium' | 'low',
      status: 'not_started' as const,
    }));

    return {
      pillarTopic,
      pillarContent,
      clusters: clusterTopics,
      totalSearchVolume: clusterTopics.reduce((sum, c) => sum + c.searchVolume, 0),
      internalLinkingStrategy: [
        'Link all cluster content to pillar page',
        'Cross-link related cluster topics',
        'Use keyword-rich anchor text',
        'Update pillar page with new cluster links',
      ],
    };
  }

  /**
   * Get AI-powered SEO recommendations
   */
  async getRecommendations(
    siteUrl: string,
    focusArea?: 'content' | 'technical' | 'local' | 'all',
  ): Promise<SeoRecommendationDto[]> {
    const recommendations: SeoRecommendationDto[] = [];

    // Content recommendations
    if (!focusArea || focusArea === 'content' || focusArea === 'all') {
      recommendations.push(
        {
          id: 'rec_1',
          category: 'content',
          priority: 'high',
          title: 'Create cornerstone content',
          description: 'Develop comprehensive guides for your main product categories to establish topical authority.',
          impact: 'High traffic potential',
          effort: 'high',
          estimatedTrafficGain: 5000,
          implementation: [
            'Identify top 5 product categories',
            'Research competitor content',
            'Create 2000+ word guides',
            'Add internal links to product pages',
          ],
        },
        {
          id: 'rec_2',
          category: 'content',
          priority: 'medium',
          title: 'Optimize product descriptions',
          description: 'Enhance product descriptions with unique, keyword-rich content.',
          impact: 'Improved conversions and rankings',
          effort: 'medium',
          estimatedTrafficGain: 2000,
          implementation: [
            'Audit existing product descriptions',
            'Identify duplicate or thin content',
            'Add unique selling points',
            'Include customer benefits',
          ],
        },
      );
    }

    // Technical recommendations
    if (!focusArea || focusArea === 'technical' || focusArea === 'all') {
      recommendations.push(
        {
          id: 'rec_3',
          category: 'technical',
          priority: 'high',
          title: 'Improve Core Web Vitals',
          description: 'Optimize page speed metrics to improve user experience and rankings.',
          impact: 'Better rankings and user experience',
          effort: 'high',
          implementation: [
            'Optimize images (WebP, lazy loading)',
            'Minimize JavaScript bundle size',
            'Implement proper caching',
            'Use CDN for static assets',
          ],
        },
        {
          id: 'rec_4',
          category: 'technical',
          priority: 'medium',
          title: 'Fix broken internal links',
          description: 'Identify and fix broken internal links to improve crawlability.',
          impact: 'Better crawl efficiency',
          effort: 'low',
          implementation: [
            'Run site audit for broken links',
            'Update or remove dead links',
            'Implement proper 301 redirects',
            'Set up monitoring alerts',
          ],
        },
      );
    }

    // Local SEO recommendations
    if (!focusArea || focusArea === 'local' || focusArea === 'all') {
      recommendations.push(
        {
          id: 'rec_5',
          category: 'local',
          priority: 'high',
          title: 'Optimize Google Business Profile',
          description: 'Complete and optimize your Google Business Profile for local visibility.',
          impact: 'Increased local visibility',
          effort: 'low',
          implementation: [
            'Complete all profile sections',
            'Add high-quality photos',
            'Respond to all reviews',
            'Post regular updates',
          ],
        },
      );
    }

    return recommendations.sort((a, b) => {
      const priorityOrder = { high: 0, medium: 1, low: 2 };
      return priorityOrder[a.priority] - priorityOrder[b.priority];
    });
  }

  /**
   * Queue an AI SEO task for processing
   */
  async queueTask(
    type: 'content_optimization' | 'meta_generation' | 'keyword_research' | 'audit',
    data: Record<string, any>,
  ): Promise<SeoTaskDto> {
    const taskId = 'task_' + Math.random().toString(36).substring(2, 15);

    const task: SeoTaskDto = {
      id: taskId,
      type,
      status: SeoTaskStatus.QUEUED,
      data,
      createdAt: new Date().toISOString(),
      progress: 0,
    };

    this.taskQueue.set(taskId, task);

    // Simulate async processing
    this.processTask(taskId);

    return task;
  }

  /**
   * Get task status
   */
  async getTaskStatus(taskId: string): Promise<SeoTaskDto | null> {
    return this.taskQueue.get(taskId) || null;
  }

  // Helper methods

  private async processTask(taskId: string): Promise<void> {
    const task = this.taskQueue.get(taskId);
    if (!task) return;

    task.status = SeoTaskStatus.PROCESSING;
    task.startedAt = new Date().toISOString();

    // Simulate processing
    for (let i = 1; i <= 10; i++) {
      await new Promise(resolve => setTimeout(resolve, 500));
      task.progress = i * 10;
    }

    task.status = SeoTaskStatus.COMPLETED;
    task.completedAt = new Date().toISOString();
    task.result = { success: true, message: 'Task completed successfully' };
  }

  private hashContent(content: string): string {
    let hash = 0;
    for (let i = 0; i < Math.min(content.length, 1000); i++) {
      hash = ((hash << 5) - hash) + content.charCodeAt(i);
      hash = hash & hash;
    }
    return Math.abs(hash).toString(16);
  }

  private calculateReadability(text: string): number {
    const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
    const words = text.split(/\s+/).filter(w => w.length > 0);
    const syllables = words.reduce((count, word) => count + this.countSyllables(word), 0);

    if (sentences.length === 0 || words.length === 0) return 0;

    const avgSentenceLength = words.length / sentences.length;
    const avgSyllablesPerWord = syllables / words.length;

    const score = 206.835 - (1.015 * avgSentenceLength) - (84.6 * avgSyllablesPerWord);
    return Math.max(0, Math.min(100, Math.round(score)));
  }

  private countSyllables(word: string): number {
    word = word.toLowerCase();
    if (word.length <= 3) return 1;
    word = word.replace(/(?:[^laeiouy]es|ed|[^laeiouy]e)$/, '');
    word = word.replace(/^y/, '');
    const matches = word.match(/[aeiouy]{1,2}/g);
    return matches ? matches.length : 1;
  }

  private getReadabilityGrade(score: number): string {
    if (score >= 90) return 'Very Easy';
    if (score >= 80) return 'Easy';
    if (score >= 70) return 'Fairly Easy';
    if (score >= 60) return 'Standard';
    if (score >= 50) return 'Fairly Difficult';
    if (score >= 30) return 'Difficult';
    return 'Very Difficult';
  }

  private getGrade(score: number): string {
    if (score >= 90) return 'A+';
    if (score >= 80) return 'A';
    if (score >= 70) return 'B';
    if (score >= 60) return 'C';
    if (score >= 50) return 'D';
    return 'F';
  }

  private getIdealLength(contentType: string): { min: number; max: number } {
    const lengths: Record<string, { min: number; max: number }> = {
      product: { min: 300, max: 1000 },
      category: { min: 200, max: 500 },
      blog: { min: 1500, max: 3000 },
      page: { min: 500, max: 2000 },
    };
    return lengths[contentType] || lengths.page;
  }

  private getKeywordSuggestions(
    keyword: string,
    density: number,
    inTitle: boolean,
    inFirstParagraph: boolean,
  ): string[] {
    const suggestions: string[] = [];
    if (density < 0.5) suggestions.push('Increase keyword usage');
    if (density > 2.5) suggestions.push('Reduce keyword usage to avoid stuffing');
    if (!inTitle) suggestions.push('Add to title or main heading');
    if (!inFirstParagraph) suggestions.push('Include in first paragraph');
    return suggestions;
  }

  private estimateImpact(suggestionsCount: number, warningsCount: number): string {
    const score = suggestionsCount + warningsCount * 2;
    if (score > 10) return 'High impact potential - addressing these issues could significantly improve rankings';
    if (score > 5) return 'Medium impact potential - recommended improvements for better performance';
    return 'Low impact - content is well optimized';
  }

  private generateKeywordVariations(seed: string): Array<{ keyword: string }> {
    const prefixes = ['best', 'top', 'cheap', 'buy', 'how to'];
    const suffixes = ['online', 'near me', 'reviews', 'guide', 'tips'];

    const variations: Array<{ keyword: string }> = [{ keyword: seed }];

    for (const prefix of prefixes) {
      variations.push({ keyword: `${prefix} ${seed}` });
    }

    for (const suffix of suffixes) {
      variations.push({ keyword: `${seed} ${suffix}` });
    }

    return variations;
  }

  private classifySearchIntent(keyword: string): SearchIntentDto {
    const keywordLower = keyword.toLowerCase();

    if (/buy|price|cheap|discount|deal|shop|order/.test(keywordLower)) {
      return { type: 'transactional', confidence: 0.85 };
    }
    if (/how|what|why|when|where|guide|tutorial|tips/.test(keywordLower)) {
      return { type: 'informational', confidence: 0.85 };
    }
    if (/best|top|review|comparison|vs|alternative/.test(keywordLower)) {
      return { type: 'commercial', confidence: 0.80 };
    }
    if (/login|sign in|website|contact|address/.test(keywordLower)) {
      return { type: 'navigational', confidence: 0.90 };
    }

    return { type: 'informational', confidence: 0.60 };
  }

  private getRelatedKeywords(keyword: string): string[] {
    return [
      `${keyword} for beginners`,
      `${keyword} examples`,
      `${keyword} alternatives`,
      `${keyword} vs`,
    ];
  }

  private suggestContentType(keyword: string): string {
    if (/guide|how to|tutorial/.test(keyword)) return 'tutorial';
    if (/comparison|vs|alternative/.test(keyword)) return 'comparison';
    if (/review|best/.test(keyword)) return 'review';
    if (/tip|advice/.test(keyword)) return 'listicle';
    return 'article';
  }

  private extractKeywords(content: string): string[] {
    const words = content.toLowerCase().split(/\s+/);
    const stopWords = new Set(['the', 'a', 'an', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should', 'may', 'might', 'must', 'shall', 'can', 'to', 'of', 'in', 'for', 'on', 'with', 'at', 'by', 'from', 'as', 'into', 'through', 'during', 'before', 'after', 'above', 'below', 'between', 'under', 'again', 'further', 'then', 'once']);

    const wordFreq = new Map<string, number>();
    for (const word of words) {
      if (word.length > 3 && !stopWords.has(word)) {
        wordFreq.set(word, (wordFreq.get(word) || 0) + 1);
      }
    }

    return Array.from(wordFreq.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 20)
      .map(([word]) => word);
  }

  private scoreMeta(text: string, minLength: number, maxLength: number): number {
    if (text.length < minLength) return Math.round((text.length / minLength) * 70);
    if (text.length > maxLength) return Math.round(90 - ((text.length - maxLength) / 20) * 10);
    return 95;
  }

  private generateOutline(topic: string, contentType: string, intent: SearchIntentDto): Array<{ heading: string; subheadings: string[] }> {
    if (contentType === 'blog' || intent.type === 'informational') {
      return [
        { heading: `What is ${topic}?`, subheadings: ['Definition', 'Key concepts'] },
        { heading: `Why ${topic} Matters`, subheadings: ['Benefits', 'Use cases'] },
        { heading: `How to ${topic}`, subheadings: ['Step 1', 'Step 2', 'Step 3'] },
        { heading: `Best Practices for ${topic}`, subheadings: ['Tips', 'Common mistakes'] },
        { heading: 'Conclusion', subheadings: ['Summary', 'Next steps'] },
      ];
    }

    return [
      { heading: `Overview of ${topic}`, subheadings: [] },
      { heading: 'Key Features', subheadings: [] },
      { heading: 'Benefits', subheadings: [] },
      { heading: 'How to Get Started', subheadings: [] },
    ];
  }

  private generateRelatedQuestions(topic: string): string[] {
    return [
      `What is ${topic}?`,
      `How does ${topic} work?`,
      `What are the benefits of ${topic}?`,
      `How much does ${topic} cost?`,
      `Is ${topic} worth it?`,
      `What are alternatives to ${topic}?`,
    ];
  }

  private getContentMetrics(contentType: string, intent: SearchIntentDto): { wordCount: number } {
    const metrics: Record<string, number> = {
      blog: 2000,
      product: 500,
      category: 300,
      landing: 1000,
    };

    let wordCount = metrics[contentType] || 1500;

    if (intent.type === 'informational') wordCount *= 1.5;
    if (intent.type === 'transactional') wordCount *= 0.7;

    return { wordCount: Math.round(wordCount) };
  }
}
