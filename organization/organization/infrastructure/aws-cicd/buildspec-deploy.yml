# ==============================================================================
# AWS CodeBuild Build Specification - EKS Deployment
# Broxiva E-Commerce Platform - Deploy to EKS
# ==============================================================================
# This buildspec handles deploying services to EKS:
# - Updates API deployment with new image tag
# - Updates Web deployment with new image tag
# - Updates all microservice deployments with new image tags
# - Performs rollout status checks
# ==============================================================================

version: 0.2

env:
  variables:
    # Default environment settings
    KUBECTL_VERSION: "1.28.0"
  exported-variables:
    - DEPLOYMENT_STATUS
    - IMAGE_TAG

phases:
  install:
    commands:
      - echo "=== Installing Dependencies ==="

      # Install kubectl
      - echo "Installing kubectl..."
      - curl -LO "https://dl.k8s.io/release/v${KUBECTL_VERSION}/bin/linux/amd64/kubectl"
      - chmod +x kubectl
      - mv kubectl /usr/local/bin/
      - kubectl version --client

      # Install AWS CLI v2 if not present
      - |
        if ! command -v aws &> /dev/null; then
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          unzip -q awscliv2.zip
          ./aws/install --update
        fi
      - aws --version

  pre_build:
    commands:
      - echo "=== Pre-Build Phase ==="
      - echo "Deployment started on $(date)"

      # Set build variables
      - export COMMIT_HASH=$(echo $CODEBUILD_RESOLVED_SOURCE_VERSION | cut -c 1-8)
      - export BUILD_DATE=$(date +%Y%m%d)
      - export IMAGE_TAG="${BUILD_DATE}-${COMMIT_HASH}"
      - echo "Image tag:" $IMAGE_TAG

      # Configure kubectl for EKS
      - echo "Configuring kubectl for EKS cluster ${EKS_CLUSTER_NAME}..."
      - aws eks update-kubeconfig --name $EKS_CLUSTER_NAME --region $AWS_DEFAULT_REGION

      # Verify cluster connectivity
      - echo "Verifying cluster connectivity..."
      - kubectl cluster-info
      - kubectl get nodes

      # Verify namespace exists
      - echo "Verifying namespace ${KUBERNETES_NAMESPACE}..."
      - kubectl get namespace $KUBERNETES_NAMESPACE || kubectl create namespace $KUBERNETES_NAMESPACE

  build:
    commands:
      - echo "=== Deployment Phase ==="
      - export DEPLOYMENT_STATUS="SUCCESS"

      # Define the ECR image URIs
      - export API_IMAGE="${ECR_REGISTRY}/${PROJECT_NAME}/api:${IMAGE_TAG}"
      - export WEB_IMAGE="${ECR_REGISTRY}/${PROJECT_NAME}/web:${IMAGE_TAG}"

      # List of Node.js services
      - export NODEJS_SERVICES="api web"

      # List of Python microservices
      - |
        export MICROSERVICES="ai-agents ai-engine analytics chatbot fraud-detection inventory media notification personalization pricing recommendation search supplier-integration"

      # Update Node.js services (API and Web)
      - echo "=== Updating Node.js Services ==="
      - |
        for SERVICE in $NODEJS_SERVICES; do
          echo "Updating ${SERVICE} deployment..."
          DEPLOYMENT_NAME="${PROJECT_NAME}-${SERVICE}"
          IMAGE_URI="${ECR_REGISTRY}/${PROJECT_NAME}/${SERVICE}:${IMAGE_TAG}"

          # Check if deployment exists
          if kubectl get deployment $DEPLOYMENT_NAME -n $KUBERNETES_NAMESPACE > /dev/null 2>&1; then
            echo "Updating deployment ${DEPLOYMENT_NAME} with image ${IMAGE_URI}"
            kubectl set image deployment/$DEPLOYMENT_NAME \
              ${SERVICE}=${IMAGE_URI} \
              -n $KUBERNETES_NAMESPACE

            # Add deployment annotation for tracking
            kubectl annotate deployment/$DEPLOYMENT_NAME \
              kubernetes.io/change-cause="Deployed via CodePipeline - Image: ${IMAGE_URI}" \
              -n $KUBERNETES_NAMESPACE --overwrite
          else
            echo "Warning: Deployment ${DEPLOYMENT_NAME} not found, skipping..."
          fi
        done

      # Update Python microservices
      - echo "=== Updating Microservices ==="
      - |
        for SERVICE in $MICROSERVICES; do
          echo "Checking ${SERVICE} deployment..."
          DEPLOYMENT_NAME="${PROJECT_NAME}-${SERVICE}"
          IMAGE_URI="${ECR_REGISTRY}/${PROJECT_NAME}/${SERVICE}:${IMAGE_TAG}"

          # Check if deployment exists
          if kubectl get deployment $DEPLOYMENT_NAME -n $KUBERNETES_NAMESPACE > /dev/null 2>&1; then
            echo "Updating deployment ${DEPLOYMENT_NAME} with image ${IMAGE_URI}"
            kubectl set image deployment/$DEPLOYMENT_NAME \
              ${SERVICE}=${IMAGE_URI} \
              -n $KUBERNETES_NAMESPACE

            # Add deployment annotation for tracking
            kubectl annotate deployment/$DEPLOYMENT_NAME \
              kubernetes.io/change-cause="Deployed via CodePipeline - Image: ${IMAGE_URI}" \
              -n $KUBERNETES_NAMESPACE --overwrite
          else
            echo "Note: Deployment ${DEPLOYMENT_NAME} not found, skipping..."
          fi
        done

  post_build:
    commands:
      - echo "=== Post-Deployment Phase ==="
      - echo "Verifying deployments..."

      # Wait for rollouts to complete
      - echo "=== Checking Rollout Status for Node.js Services ==="
      - |
        for SERVICE in $NODEJS_SERVICES; do
          DEPLOYMENT_NAME="${PROJECT_NAME}-${SERVICE}"
          if kubectl get deployment $DEPLOYMENT_NAME -n $KUBERNETES_NAMESPACE > /dev/null 2>&1; then
            echo "Waiting for ${DEPLOYMENT_NAME} rollout to complete..."
            if kubectl rollout status deployment/$DEPLOYMENT_NAME -n $KUBERNETES_NAMESPACE --timeout=300s; then
              echo "${DEPLOYMENT_NAME} rollout completed successfully"
            else
              echo "ERROR: ${DEPLOYMENT_NAME} rollout failed"
              export DEPLOYMENT_STATUS="FAILED"
            fi
          fi
        done

      # Check rollout status for microservices (with shorter timeout as they may not all exist)
      - echo "=== Checking Rollout Status for Microservices ==="
      - |
        for SERVICE in $MICROSERVICES; do
          DEPLOYMENT_NAME="${PROJECT_NAME}-${SERVICE}"
          if kubectl get deployment $DEPLOYMENT_NAME -n $KUBERNETES_NAMESPACE > /dev/null 2>&1; then
            echo "Waiting for ${DEPLOYMENT_NAME} rollout to complete..."
            if kubectl rollout status deployment/$DEPLOYMENT_NAME -n $KUBERNETES_NAMESPACE --timeout=180s; then
              echo "${DEPLOYMENT_NAME} rollout completed successfully"
            else
              echo "WARNING: ${DEPLOYMENT_NAME} rollout may have issues"
            fi
          fi
        done

      # Display deployment summary
      - echo "=== Deployment Summary ==="
      - kubectl get deployments -n $KUBERNETES_NAMESPACE -o wide
      - echo ""
      - kubectl get pods -n $KUBERNETES_NAMESPACE -o wide
      - echo ""
      - echo "Deployment completed on $(date)"
      - echo "Deployment Status:" $DEPLOYMENT_STATUS

      # Generate deployment summary artifact
      - |
        cat > deployment-summary.json << EOF
        {
          "deploymentId": "$CODEBUILD_BUILD_ID",
          "buildNumber": "$CODEBUILD_BUILD_NUMBER",
          "sourceVersion": "$CODEBUILD_RESOLVED_SOURCE_VERSION",
          "imageTag": "$IMAGE_TAG",
          "cluster": "$EKS_CLUSTER_NAME",
          "namespace": "$KUBERNETES_NAMESPACE",
          "status": "$DEPLOYMENT_STATUS",
          "deploymentDate": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
          "deployedServices": {
            "nodejs": ["api", "web"],
            "microservices": ["ai-agents", "ai-engine", "analytics", "chatbot", "fraud-detection", "inventory", "media", "notification", "personalization", "pricing", "recommendation", "search", "supplier-integration"]
          }
        }
        EOF
      - cat deployment-summary.json

      # Fail the build if deployment failed
      - |
        if [ "$DEPLOYMENT_STATUS" != "SUCCESS" ]; then
          echo "Deployment failed. Rolling back..."
          for SERVICE in $NODEJS_SERVICES; do
            DEPLOYMENT_NAME="${PROJECT_NAME}-${SERVICE}"
            if kubectl get deployment $DEPLOYMENT_NAME -n $KUBERNETES_NAMESPACE > /dev/null 2>&1; then
              kubectl rollout undo deployment/$DEPLOYMENT_NAME -n $KUBERNETES_NAMESPACE || true
            fi
          done
          exit 1
        fi

artifacts:
  files:
    - deployment-summary.json
  discard-paths: yes
