# Reusable AKS Deployment Job Template
# Can be used across dev, staging, and production environments

parameters:
  - name: environment
    type: string
    displayName: 'Target Environment'
    values:
      - dev
      - staging
      - production

  - name: aksResourceGroup
    type: string
    displayName: 'AKS Resource Group'

  - name: aksClusterName
    type: string
    displayName: 'AKS Cluster Name'

  - name: namespace
    type: string
    displayName: 'Kubernetes Namespace'

  - name: manifestPath
    type: string
    displayName: 'Path to Kubernetes Manifests'

  - name: imageTag
    type: string
    displayName: 'Docker Image Tag'

  - name: serviceConnection
    type: string
    displayName: 'Azure Service Connection'
    default: 'CitadelBuyAzure'

  - name: acrName
    type: string
    displayName: 'Azure Container Registry'
    default: 'citadelbuyacr.azurecr.io'

  - name: runMigrations
    type: boolean
    displayName: 'Run Database Migrations'
    default: true

  - name: healthCheckUrl
    type: string
    displayName: 'Health Check URL'
    default: ''

  - name: deploymentTimeout
    type: string
    displayName: 'Deployment Timeout'
    default: '10m'

jobs:
  - deployment: DeployToAKS_${{ parameters.environment }}
    displayName: 'Deploy to AKS - ${{ parameters.environment }}'
    pool:
      vmImage: 'ubuntu-latest'
    environment: ${{ parameters.environment }}
    variables:
      - name: timestamp
        value: $[format('{0:yyyy}-{0:MM}-{0:dd}T{0:HH}:{0:mm}:{0:ss}Z', pipeline.startTime)]
    strategy:
      runOnce:
        deploy:
          steps:
            - checkout: self
              displayName: 'Checkout Source Code'

            - task: AzureCLI@2
              displayName: 'Install and Configure kubectl'
              inputs:
                azureSubscription: '${{ parameters.serviceConnection }}'
                scriptType: 'bash'
                scriptLocation: 'inlineScript'
                inlineScript: |
                  echo "Checking kubectl version..."
                  kubectl version --client

                  echo "Configuring kubectl for Azure..."
                  az aks install-cli || true

            - task: AzureCLI@2
              displayName: 'Get AKS Credentials'
              inputs:
                azureSubscription: '${{ parameters.serviceConnection }}'
                scriptType: 'bash'
                scriptLocation: 'inlineScript'
                inlineScript: |
                  echo "========================================="
                  echo "Getting AKS Credentials"
                  echo "========================================="
                  echo "Resource Group: ${{ parameters.aksResourceGroup }}"
                  echo "Cluster Name:   ${{ parameters.aksClusterName }}"
                  echo "Environment:    ${{ parameters.environment }}"
                  echo ""

                  # Get credentials
                  az aks get-credentials \
                    --resource-group ${{ parameters.aksResourceGroup }} \
                    --name ${{ parameters.aksClusterName }} \
                    --overwrite-existing \
                    --file ~/.kube/config

                  # Verify connection
                  echo "Verifying cluster connection..."
                  kubectl cluster-info

                  echo ""
                  echo "Cluster nodes:"
                  kubectl get nodes -o wide

                  echo ""
                  echo "AKS credentials configured successfully"

            - task: AzureCLI@2
              displayName: 'Prepare Namespace'
              inputs:
                azureSubscription: '${{ parameters.serviceConnection }}'
                scriptType: 'bash'
                scriptLocation: 'inlineScript'
                inlineScript: |
                  echo "========================================="
                  echo "Preparing Namespace: ${{ parameters.namespace }}"
                  echo "========================================="

                  # Create namespace if it doesn't exist
                  if kubectl get namespace ${{ parameters.namespace }} >/dev/null 2>&1; then
                    echo "Namespace ${{ parameters.namespace }} already exists"
                  else
                    echo "Creating namespace ${{ parameters.namespace }}"
                    kubectl create namespace ${{ parameters.namespace }}
                  fi

                  # Label namespace
                  kubectl label namespace ${{ parameters.namespace }} \
                    environment=${{ parameters.environment }} \
                    managed-by=azure-devops \
                    --overwrite

                  # Set current context
                  kubectl config set-context --current --namespace=${{ parameters.namespace }}

                  echo "Namespace prepared successfully"

            - task: AzureCLI@2
              displayName: 'Apply Kubernetes Manifests'
              inputs:
                azureSubscription: '${{ parameters.serviceConnection }}'
                scriptType: 'bash'
                scriptLocation: 'inlineScript'
                inlineScript: |
                  echo "========================================="
                  echo "Applying Kubernetes Manifests"
                  echo "========================================="
                  echo "Manifest Path: ${{ parameters.manifestPath }}"
                  echo "Namespace:     ${{ parameters.namespace }}"
                  echo ""

                  # Check if manifest path exists
                  if [ ! -d "${{ parameters.manifestPath }}" ]; then
                    echo "Error: Manifest path does not exist: ${{ parameters.manifestPath }}"
                    exit 1
                  fi

                  # Apply manifests in order
                  RESOURCE_ORDER=(
                    "namespace"
                    "configmap"
                    "secret"
                    "pvc"
                    "pv"
                    "storageclass"
                    "serviceaccount"
                    "role"
                    "rolebinding"
                    "service"
                    "deployment"
                    "statefulset"
                    "daemonset"
                    "ingress"
                    "hpa"
                  )

                  for resource_type in "${RESOURCE_ORDER[@]}"; do
                    echo "Looking for ${resource_type} manifests..."

                    # Find files matching the resource type
                    files=$(find ${{ parameters.manifestPath }} -type f \( -name "*${resource_type}*.yml" -o -name "*${resource_type}*.yaml" \) 2>/dev/null)

                    if [ -n "$files" ]; then
                      echo "Applying ${resource_type} manifests:"
                      echo "$files"
                      echo "$files" | while read -r file; do
                        echo "  Applying: $file"
                        kubectl apply -f "$file" -n ${{ parameters.namespace }}
                      done
                      echo ""
                    fi
                  done

                  # Apply any remaining manifests
                  echo "Applying any remaining manifests..."
                  kubectl apply -f ${{ parameters.manifestPath }}/ -n ${{ parameters.namespace }} --recursive

                  echo "Manifests applied successfully"

            - task: AzureCLI@2
              displayName: 'Update Deployment Images'
              inputs:
                azureSubscription: '${{ parameters.serviceConnection }}'
                scriptType: 'bash'
                scriptLocation: 'inlineScript'
                inlineScript: |
                  echo "========================================="
                  echo "Updating Deployment Images"
                  echo "========================================="
                  echo "Image Tag: ${{ parameters.imageTag }}"
                  echo "ACR:       ${{ parameters.acrName }}"
                  echo ""

                  # Update API deployment
                  if kubectl get deployment citadelbuy-api -n ${{ parameters.namespace }} >/dev/null 2>&1; then
                    echo "Updating citadelbuy-api deployment..."
                    kubectl set image deployment/citadelbuy-api \
                      citadelbuy-api=${{ parameters.acrName }}/citadelbuy-api:${{ parameters.imageTag }} \
                      -n ${{ parameters.namespace }} \
                      --record

                    # Add annotations
                    kubectl annotate deployment/citadelbuy-api \
                      buildId="$(Build.BuildId)" \
                      buildNumber="$(Build.BuildNumber)" \
                      commitSha="$(Build.SourceVersion)" \
                      deployedAt="$(timestamp)" \
                      imageTag="${{ parameters.imageTag }}" \
                      -n ${{ parameters.namespace }} \
                      --overwrite
                  else
                    echo "Warning: citadelbuy-api deployment not found"
                  fi

                  # Update Frontend deployment
                  if kubectl get deployment citadelbuy-frontend -n ${{ parameters.namespace }} >/dev/null 2>&1; then
                    echo "Updating citadelbuy-frontend deployment..."
                    kubectl set image deployment/citadelbuy-frontend \
                      citadelbuy-frontend=${{ parameters.acrName }}/citadelbuy-frontend:${{ parameters.imageTag }} \
                      -n ${{ parameters.namespace }} \
                      --record

                    # Add annotations
                    kubectl annotate deployment/citadelbuy-frontend \
                      buildId="$(Build.BuildId)" \
                      buildNumber="$(Build.BuildNumber)" \
                      commitSha="$(Build.SourceVersion)" \
                      deployedAt="$(timestamp)" \
                      imageTag="${{ parameters.imageTag }}" \
                      -n ${{ parameters.namespace }} \
                      --overwrite
                  else
                    echo "Warning: citadelbuy-frontend deployment not found"
                  fi

                  echo "Deployment images updated successfully"

            - task: AzureCLI@2
              displayName: 'Wait for Rollout Completion'
              inputs:
                azureSubscription: '${{ parameters.serviceConnection }}'
                scriptType: 'bash'
                scriptLocation: 'inlineScript'
                inlineScript: |
                  echo "========================================="
                  echo "Waiting for Rollout Completion"
                  echo "========================================="
                  echo "Timeout: ${{ parameters.deploymentTimeout }}"
                  echo ""

                  DEPLOYMENTS=(
                    "citadelbuy-api"
                    "citadelbuy-frontend"
                  )

                  for deployment in "${DEPLOYMENTS[@]}"; do
                    if kubectl get deployment $deployment -n ${{ parameters.namespace }} >/dev/null 2>&1; then
                      echo "Waiting for $deployment rollout..."
                      kubectl rollout status deployment/$deployment \
                        -n ${{ parameters.namespace }} \
                        --timeout=${{ parameters.deploymentTimeout }}

                      # Get rollout history
                      echo "Rollout history for $deployment:"
                      kubectl rollout history deployment/$deployment -n ${{ parameters.namespace }}
                      echo ""
                    else
                      echo "Warning: Deployment $deployment not found, skipping..."
                    fi
                  done

                  echo "All deployments rolled out successfully"

            - task: AzureCLI@2
              displayName: 'Run Database Migrations'
              condition: eq('${{ parameters.runMigrations }}', 'true')
              inputs:
                azureSubscription: '${{ parameters.serviceConnection }}'
                scriptType: 'bash'
                scriptLocation: 'inlineScript'
                inlineScript: |
                  echo "========================================="
                  echo "Running Database Migrations"
                  echo "========================================="

                  # Wait for API pods to be ready
                  echo "Waiting for API pods to be ready..."
                  kubectl wait --for=condition=ready pod \
                    -l app=citadelbuy-api \
                    -n ${{ parameters.namespace }} \
                    --timeout=5m

                  # Get API pod name
                  API_POD=$(kubectl get pods -n ${{ parameters.namespace }} \
                    -l app=citadelbuy-api \
                    -o jsonpath='{.items[0].metadata.name}')

                  if [ -z "$API_POD" ]; then
                    echo "Error: No API pod found"
                    exit 1
                  fi

                  echo "Running migrations on pod: $API_POD"

                  # Check if Prisma is installed
                  if kubectl exec -n ${{ parameters.namespace }} $API_POD -- which npx >/dev/null 2>&1; then
                    # Generate Prisma Client
                    echo "Generating Prisma Client..."
                    kubectl exec -n ${{ parameters.namespace }} $API_POD -- npx prisma generate || true

                    # Run migrations
                    echo "Deploying database migrations..."
                    kubectl exec -n ${{ parameters.namespace }} $API_POD -- npx prisma migrate deploy

                    # Check migration status
                    echo "Checking migration status..."
                    kubectl exec -n ${{ parameters.namespace }} $API_POD -- npx prisma migrate status || true

                    echo "Database migrations completed successfully"
                  else
                    echo "Warning: npx not found in pod, skipping migrations"
                  fi

            - task: AzureCLI@2
              displayName: 'Verify Pod Health'
              inputs:
                azureSubscription: '${{ parameters.serviceConnection }}'
                scriptType: 'bash'
                scriptLocation: 'inlineScript'
                inlineScript: |
                  echo "========================================="
                  echo "Verifying Pod Health"
                  echo "========================================="

                  echo "Current pod status:"
                  kubectl get pods -n ${{ parameters.namespace }} -o wide

                  echo ""
                  echo "Waiting for all pods to be ready..."

                  # Wait for API pods
                  if kubectl get deployment citadelbuy-api -n ${{ parameters.namespace }} >/dev/null 2>&1; then
                    kubectl wait --for=condition=ready pod \
                      -l app=citadelbuy-api \
                      -n ${{ parameters.namespace }} \
                      --timeout=5m
                  fi

                  # Wait for Frontend pods
                  if kubectl get deployment citadelbuy-frontend -n ${{ parameters.namespace }} >/dev/null 2>&1; then
                    kubectl wait --for=condition=ready pod \
                      -l app=citadelbuy-frontend \
                      -n ${{ parameters.namespace }} \
                      --timeout=5m
                  fi

                  echo ""
                  echo "Checking for failed pods..."
                  FAILED_PODS=$(kubectl get pods -n ${{ parameters.namespace }} \
                    --field-selector=status.phase!=Running,status.phase!=Succeeded \
                    -o jsonpath='{.items[*].metadata.name}')

                  if [ -n "$FAILED_PODS" ]; then
                    echo "Warning: Found failed pods:"
                    echo "$FAILED_PODS"
                    echo ""
                    echo "Pod details:"
                    kubectl describe pods -n ${{ parameters.namespace }} $FAILED_PODS
                    exit 1
                  fi

                  echo "All pods are healthy"

            - task: Bash@3
              displayName: 'Health Check Endpoint'
              condition: ne('${{ parameters.healthCheckUrl }}', '')
              inputs:
                targetType: 'inline'
                script: |
                  echo "========================================="
                  echo "Running Health Check"
                  echo "========================================="
                  echo "URL: ${{ parameters.healthCheckUrl }}"
                  echo ""

                  # Wait for DNS/ingress propagation
                  echo "Waiting for DNS/ingress propagation..."
                  sleep 30

                  # Health check with retries
                  MAX_RETRIES=15
                  RETRY_COUNT=0

                  while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
                    echo "Health check attempt $((RETRY_COUNT + 1))/$MAX_RETRIES"

                    RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "${{ parameters.healthCheckUrl }}" || echo "000")

                    if [ "$RESPONSE" = "200" ]; then
                      echo "Health check passed! Status: 200"

                      # Display response
                      echo "Response:"
                      curl -s "${{ parameters.healthCheckUrl }}" | jq '.' 2>/dev/null || curl -s "${{ parameters.healthCheckUrl }}"

                      exit 0
                    fi

                    echo "Health check failed with status: $RESPONSE"
                    RETRY_COUNT=$((RETRY_COUNT + 1))

                    if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                      echo "Retrying in 20 seconds..."
                      sleep 20
                    fi
                  done

                  echo "Health check failed after $MAX_RETRIES attempts"
                  exit 1

            - task: AzureCLI@2
              displayName: 'Display Deployment Summary'
              condition: always()
              inputs:
                azureSubscription: '${{ parameters.serviceConnection }}'
                scriptType: 'bash'
                scriptLocation: 'inlineScript'
                inlineScript: |
                  echo "================================================================"
                  echo "         DEPLOYMENT SUMMARY - ${{ parameters.environment }}"
                  echo "================================================================"
                  echo ""
                  echo "Environment:     ${{ parameters.environment }}"
                  echo "Namespace:       ${{ parameters.namespace }}"
                  echo "Cluster:         ${{ parameters.aksClusterName }}"
                  echo "Resource Group:  ${{ parameters.aksResourceGroup }}"
                  echo "Image Tag:       ${{ parameters.imageTag }}"
                  echo "Build ID:        $(Build.BuildId)"
                  echo "Build Number:    $(Build.BuildNumber)"
                  echo "Commit SHA:      $(Build.SourceVersion)"
                  echo "Deployed At:     $(timestamp)"
                  echo ""

                  echo "=== Deployments ==="
                  kubectl get deployments -n ${{ parameters.namespace }} -o wide

                  echo ""
                  echo "=== Pods ==="
                  kubectl get pods -n ${{ parameters.namespace }} -o wide

                  echo ""
                  echo "=== Services ==="
                  kubectl get services -n ${{ parameters.namespace }} -o wide

                  echo ""
                  echo "=== Ingress ==="
                  kubectl get ingress -n ${{ parameters.namespace }} -o wide 2>/dev/null || echo "No ingress resources found"

                  echo ""
                  echo "=== Recent Events ==="
                  kubectl get events -n ${{ parameters.namespace }} \
                    --sort-by='.lastTimestamp' \
                    --field-selector type!=Normal \
                    | tail -20

                  echo ""
                  echo "================================================================"
                  echo "Deployment to ${{ parameters.environment }} completed!"
                  echo "================================================================"
