# Reusable Terraform Apply Job Template
# Can be used across multiple pipelines for consistent Terraform operations

parameters:
- name: environment
  type: string
  displayName: 'Target Environment'
  values:
  - dev
  - staging
  - prod

- name: workingDirectory
  type: string
  displayName: 'Terraform Working Directory'

- name: serviceConnection
  type: string
  displayName: 'Azure Service Connection'
  default: 'CitadelBuy-Azure-ServiceConnection'

- name: terraformVersion
  type: string
  displayName: 'Terraform Version'
  default: '1.6.0'

- name: backendResourceGroup
  type: string
  displayName: 'Backend Resource Group'
  default: 'citadelbuy-tfstate-rg'

- name: backendStorageAccount
  type: string
  displayName: 'Backend Storage Account'
  default: 'citadelbuytfstate'

- name: backendContainer
  type: string
  displayName: 'Backend Container'
  default: 'tfstate'

- name: backendKey
  type: string
  displayName: 'Backend State File Key'
  default: 'terraform.tfstate'

- name: tfVars
  type: object
  displayName: 'Additional Terraform Variables'
  default: {}

- name: variableGroup
  type: string
  displayName: 'Variable Group Name'
  default: ''

- name: runPlan
  type: boolean
  displayName: 'Run Terraform Plan'
  default: true

- name: runApply
  type: boolean
  displayName: 'Run Terraform Apply'
  default: true

- name: requireApproval
  type: boolean
  displayName: 'Require Manual Approval'
  default: true

- name: additionalArgs
  type: string
  displayName: 'Additional Terraform Arguments'
  default: ''

jobs:
- job: TerraformApply_${{ parameters.environment }}
  displayName: 'Terraform Apply - ${{ upper(parameters.environment) }}'
  pool:
    vmImage: 'ubuntu-latest'

  # Use environment for approval gates if required
  ${{ if eq(parameters.requireApproval, true) }}:
    environment: '${{ parameters.environment }}'

  variables:
  # Load variable group if specified
  ${{ if ne(parameters.variableGroup, '') }}:
  - group: '${{ parameters.variableGroup }}'

  # Standard Azure ARM variables
  - name: ARM_SUBSCRIPTION_ID
    value: 'ba233460-2dbe-4603-a594-68f93ec9deb3'
  - name: ARM_TENANT_ID
    value: '$(AZURE_TENANT_ID)'  # Should be set in variable group
  - name: ARM_CLIENT_ID
    value: '$(AZURE_CLIENT_ID)'  # Should be set in variable group or from service connection
  # ARM_CLIENT_SECRET should come from secure variable group

  # Terraform configuration
  - name: TF_IN_AUTOMATION
    value: 'true'
  - name: TF_INPUT
    value: 'false'
  - name: TF_CLI_ARGS
    value: '-no-color'

  steps:
  - checkout: self
    displayName: 'Checkout Repository'
    fetchDepth: 1

  - task: TerraformInstaller@0
    displayName: 'Install Terraform ${{ parameters.terraformVersion }}'
    inputs:
      terraformVersion: '${{ parameters.terraformVersion }}'

  - task: Bash@3
    displayName: 'Verify Working Directory'
    inputs:
      targetType: 'inline'
      script: |
        echo "##[section]Verifying Terraform working directory..."
        echo "Working Directory: ${{ parameters.workingDirectory }}"

        if [ ! -d "${{ parameters.workingDirectory }}" ]; then
          echo "##vso[task.logissue type=error]Working directory does not exist: ${{ parameters.workingDirectory }}"
          exit 1
        fi

        if [ ! -f "${{ parameters.workingDirectory }}/main.tf" ] && [ ! -f "${{ parameters.workingDirectory }}/terraform.tf" ]; then
          echo "##vso[task.logissue type=warning]No main.tf or terraform.tf found in working directory"
        fi

        ls -la "${{ parameters.workingDirectory }}"

  - task: AzureCLI@2
    displayName: 'Terraform Init'
    inputs:
      azureSubscription: '${{ parameters.serviceConnection }}'
      scriptType: 'bash'
      scriptLocation: 'inlineScript'
      workingDirectory: '${{ parameters.workingDirectory }}'
      addSpnToEnvironment: true
      inlineScript: |
        echo "##[section]Initializing Terraform backend..."

        # Set Azure provider credentials from service principal
        export ARM_SUBSCRIPTION_ID="$(ARM_SUBSCRIPTION_ID)"
        export ARM_TENANT_ID="$(ARM_TENANT_ID)"
        export ARM_CLIENT_ID="$servicePrincipalId"
        export ARM_CLIENT_SECRET="$servicePrincipalKey"
        export TF_IN_AUTOMATION="true"

        # Display backend configuration (without sensitive values)
        echo "Backend Configuration:"
        echo "  Resource Group: ${{ parameters.backendResourceGroup }}"
        echo "  Storage Account: ${{ parameters.backendStorageAccount }}"
        echo "  Container: ${{ parameters.backendContainer }}"
        echo "  Key: ${{ parameters.environment }}/${{ parameters.backendKey }}"

        # Initialize Terraform with backend configuration
        terraform init \
          -backend-config="resource_group_name=${{ parameters.backendResourceGroup }}" \
          -backend-config="storage_account_name=${{ parameters.backendStorageAccount }}" \
          -backend-config="container_name=${{ parameters.backendContainer }}" \
          -backend-config="key=${{ parameters.environment }}/${{ parameters.backendKey }}" \
          -backend-config="subscription_id=$(ARM_SUBSCRIPTION_ID)" \
          -reconfigure \
          -upgrade

        echo "##[section]Terraform backend initialized successfully"

  - task: AzureCLI@2
    displayName: 'Terraform Validate'
    inputs:
      azureSubscription: '${{ parameters.serviceConnection }}'
      scriptType: 'bash'
      scriptLocation: 'inlineScript'
      workingDirectory: '${{ parameters.workingDirectory }}'
      addSpnToEnvironment: true
      inlineScript: |
        echo "##[section]Validating Terraform configuration..."

        export ARM_SUBSCRIPTION_ID="$(ARM_SUBSCRIPTION_ID)"
        export ARM_TENANT_ID="$(ARM_TENANT_ID)"
        export ARM_CLIENT_ID="$servicePrincipalId"
        export ARM_CLIENT_SECRET="$servicePrincipalKey"

        terraform validate

        if [ $? -eq 0 ]; then
          echo "##[section]Terraform configuration is valid"
        else
          echo "##vso[task.logissue type=error]Terraform validation failed"
          exit 1
        fi

  - ${{ if eq(parameters.runPlan, true) }}:
    - task: AzureCLI@2
      displayName: 'Terraform Plan'
      inputs:
        azureSubscription: '${{ parameters.serviceConnection }}'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        workingDirectory: '${{ parameters.workingDirectory }}'
        addSpnToEnvironment: true
        inlineScript: |
          echo "##[section]Creating Terraform execution plan..."

          export ARM_SUBSCRIPTION_ID="$(ARM_SUBSCRIPTION_ID)"
          export ARM_TENANT_ID="$(ARM_TENANT_ID)"
          export ARM_CLIENT_ID="$servicePrincipalId"
          export ARM_CLIENT_SECRET="$servicePrincipalKey"

          # Set environment-specific variables
          export TF_VAR_environment="${{ parameters.environment }}"
          export TF_VAR_azure_subscription_id="$(ARM_SUBSCRIPTION_ID)"

          # Set additional custom variables
          ${{ each var in parameters.tfVars }}:
          export TF_VAR_${{ var.key }}="${{ var.value }}"

          # Create execution plan
          terraform plan \
            -out=tfplan \
            -input=false \
            ${{ parameters.additionalArgs }}

          # Display plan in readable format
          echo "##[section]Terraform Plan Output:"
          terraform show -no-color tfplan | tee tfplan.txt

          # Check for changes
          if terraform show -json tfplan | jq -e '.resource_changes == null or (.resource_changes | length == 0)' > /dev/null; then
            echo "##[warning]No changes detected in Terraform plan"
            echo "##vso[task.setvariable variable=TerraformHasChanges]false"
          else
            echo "##[section]Changes detected in Terraform plan"
            echo "##vso[task.setvariable variable=TerraformHasChanges]true"

            # Output change summary
            echo "##[section]Change Summary:"
            terraform show -json tfplan | jq -r '
              .resource_changes[] |
              "\(.change.actions[0] | ascii_upcase): \(.type).\(.name)"
            '
          fi

    - task: PublishPipelineArtifact@1
      displayName: 'Publish Terraform Plan'
      condition: and(succeeded(), eq(variables['TerraformHasChanges'], 'true'))
      inputs:
        targetPath: '${{ parameters.workingDirectory }}/tfplan'
        artifact: 'tfplan-${{ parameters.environment }}-$(Build.BuildId)'
        publishLocation: 'pipeline'

    - task: PublishPipelineArtifact@1
      displayName: 'Publish Plan Output'
      condition: and(succeeded(), eq(variables['TerraformHasChanges'], 'true'))
      inputs:
        targetPath: '${{ parameters.workingDirectory }}/tfplan.txt'
        artifact: 'tfplan-output-${{ parameters.environment }}-$(Build.BuildId)'
        publishLocation: 'pipeline'

  - ${{ if eq(parameters.runApply, true) }}:
    - task: AzureCLI@2
      displayName: 'Terraform Apply'
      condition: and(succeeded(), or(eq(variables['TerraformHasChanges'], 'true'), eq('${{ parameters.runPlan }}', 'false')))
      inputs:
        azureSubscription: '${{ parameters.serviceConnection }}'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        workingDirectory: '${{ parameters.workingDirectory }}'
        addSpnToEnvironment: true
        inlineScript: |
          echo "##[section]Applying Terraform changes..."

          export ARM_SUBSCRIPTION_ID="$(ARM_SUBSCRIPTION_ID)"
          export ARM_TENANT_ID="$(ARM_TENANT_ID)"
          export ARM_CLIENT_ID="$servicePrincipalId"
          export ARM_CLIENT_SECRET="$servicePrincipalKey"

          # Set environment-specific variables
          export TF_VAR_environment="${{ parameters.environment }}"
          export TF_VAR_azure_subscription_id="$(ARM_SUBSCRIPTION_ID)"

          # Set additional custom variables
          ${{ each var in parameters.tfVars }}:
          export TF_VAR_${{ var.key }}="${{ var.value }}"

          # Apply the plan if it exists, otherwise run direct apply
          if [ -f "tfplan" ]; then
            echo "Applying saved plan..."
            terraform apply -auto-approve tfplan
          else
            echo "Running direct apply..."
            terraform apply -auto-approve ${{ parameters.additionalArgs }}
          fi

          if [ $? -eq 0 ]; then
            echo "##[section]Terraform apply completed successfully"
          else
            echo "##vso[task.logissue type=error]Terraform apply failed"
            exit 1
          fi

    - task: AzureCLI@2
      displayName: 'Terraform Output'
      condition: and(succeeded(), eq('${{ parameters.runApply }}', 'true'))
      inputs:
        azureSubscription: '${{ parameters.serviceConnection }}'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        workingDirectory: '${{ parameters.workingDirectory }}'
        addSpnToEnvironment: true
        inlineScript: |
          echo "##[section]Retrieving Terraform outputs..."

          export ARM_SUBSCRIPTION_ID="$(ARM_SUBSCRIPTION_ID)"
          export ARM_TENANT_ID="$(ARM_TENANT_ID)"
          export ARM_CLIENT_ID="$servicePrincipalId"
          export ARM_CLIENT_SECRET="$servicePrincipalKey"

          # Get outputs in both JSON and human-readable format
          terraform output -json > terraform-outputs.json
          terraform output > terraform-outputs.txt

          echo "##[section]Terraform Outputs:"
          cat terraform-outputs.txt

          # Set pipeline variables from outputs (for downstream jobs)
          for key in $(terraform output -json | jq -r 'keys[]'); do
            value=$(terraform output -json | jq -r ".\"$key\".value")
            echo "##vso[task.setvariable variable=TF_OUTPUT_$key;isOutput=true]$value"
            echo "Set pipeline variable: TF_OUTPUT_$key"
          done

    - task: PublishPipelineArtifact@1
      displayName: 'Publish Terraform Outputs'
      condition: and(succeeded(), eq('${{ parameters.runApply }}', 'true'))
      inputs:
        targetPath: '${{ parameters.workingDirectory }}/terraform-outputs.json'
        artifact: 'terraform-outputs-${{ parameters.environment }}-$(Build.BuildId)'
        publishLocation: 'pipeline'

  - task: Bash@3
    displayName: 'Cleanup Sensitive Files'
    condition: always()
    inputs:
      targetType: 'inline'
      workingDirectory: '${{ parameters.workingDirectory }}'
      script: |
        echo "##[section]Cleaning up sensitive files..."

        # Remove plan files that might contain sensitive data
        rm -f tfplan tfplan.txt terraform-outputs.json terraform-outputs.txt

        # Remove any .terraform directories from build agent
        # (these will be recreated on next run)
        rm -rf .terraform

        echo "##[section]Cleanup completed"
