name: Terraform Deploy Production

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Terraform action'
        required: true
        default: 'plan'
        type: choice
        options:
          - plan
          - apply
          - destroy
      confirm_production:
        description: 'Type "DEPLOY-TO-PRODUCTION" to confirm'
        required: false
        type: string
  workflow_run:
    workflows: ["Docker Build & Push to ACR"]
    types: [completed]
    branches: [main]

permissions:
  contents: read
  id-token: write
  pull-requests: write

env:
  TF_VERSION: '1.6.0'
  ARM_USE_OIDC: true
  ARM_SKIP_PROVIDER_REGISTRATION: true

jobs:
  validate:
    name: Validate & Plan
    runs-on: ubuntu-latest
    environment: production
    outputs:
      plan_exit_code: ${{ steps.plan.outputs.exitcode }}
    steps:
      - name: Check confirmation for apply/destroy
        if: github.event.inputs.action == 'apply' || github.event.inputs.action == 'destroy'
        run: |
          if [ "${{ github.event.inputs.confirm_production }}" != "DEPLOY-TO-PRODUCTION" ]; then
            echo "::error::Production deployment not confirmed. Type 'DEPLOY-TO-PRODUCTION' to confirm."
            exit 1
          fi

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Azure Login via OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Terraform Init
        id: init
        working-directory: infrastructure/terraform/environments/prod
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ secrets.TF_STATE_RESOURCE_GROUP }}" \
            -backend-config="storage_account_name=${{ secrets.TF_STATE_STORAGE_ACCOUNT }}" \
            -backend-config="container_name=${{ secrets.TF_STATE_CONTAINER }}" \
            -backend-config="key=prod.terraform.tfstate"
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Terraform Validate
        working-directory: infrastructure/terraform/environments/prod
        run: terraform validate

      - name: Terraform Plan
        id: plan
        working-directory: infrastructure/terraform/environments/prod
        run: |
          terraform plan \
            -var="subscription_id=${{ secrets.AZURE_SUBSCRIPTION_ID }}" \
            -var="tenant_id=${{ secrets.AZURE_TENANT_ID }}" \
            -var="db_admin_username=${{ secrets.DB_ADMIN_USERNAME }}" \
            -var="db_admin_password=${{ secrets.DB_ADMIN_PASSWORD }}" \
            -var="jwt_secret=${{ secrets.JWT_SECRET }}" \
            -var="oncall_email=${{ secrets.ONCALL_EMAIL }}" \
            -var="team_email=${{ secrets.TEAM_EMAIL }}" \
            -var="slack_webhook_url=${{ secrets.SLACK_WEBHOOK_URL }}" \
            -detailed-exitcode \
            -out=tfplan \
            || echo "exitcode=$?" >> $GITHUB_OUTPUT
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Upload Terraform Plan
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan-prod
          path: infrastructure/terraform/environments/prod/tfplan
          retention-days: 7

      - name: Generate Plan Summary
        working-directory: infrastructure/terraform/environments/prod
        run: |
          echo "### Terraform Plan Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          terraform show -no-color tfplan >> $GITHUB_STEP_SUMMARY 2>/dev/null || echo "Plan details not available" >> $GITHUB_STEP_SUMMARY

  apply:
    name: Apply to Production
    runs-on: ubuntu-latest
    needs: validate
    if: github.event.inputs.action == 'apply' && needs.validate.result == 'success'
    environment: production
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Azure Login via OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Download Terraform Plan
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan-prod
          path: infrastructure/terraform/environments/prod

      - name: Terraform Init
        working-directory: infrastructure/terraform/environments/prod
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ secrets.TF_STATE_RESOURCE_GROUP }}" \
            -backend-config="storage_account_name=${{ secrets.TF_STATE_STORAGE_ACCOUNT }}" \
            -backend-config="container_name=${{ secrets.TF_STATE_CONTAINER }}" \
            -backend-config="key=prod.terraform.tfstate"
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Terraform Apply
        working-directory: infrastructure/terraform/environments/prod
        run: terraform apply -auto-approve tfplan
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Save Terraform Outputs
        id: outputs
        working-directory: infrastructure/terraform/environments/prod
        run: |
          terraform output -json > terraform-outputs.json
          echo "aks_cluster_name=$(terraform output -raw aks_cluster_name 2>/dev/null || echo 'N/A')" >> $GITHUB_OUTPUT
          echo "acr_login_server=$(terraform output -raw acr_login_server 2>/dev/null || echo 'N/A')" >> $GITHUB_OUTPUT
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Upload Terraform Outputs
        uses: actions/upload-artifact@v4
        with:
          name: terraform-outputs-prod
          path: infrastructure/terraform/environments/prod/terraform-outputs.json
          retention-days: 90

  deploy-to-aks:
    name: Deploy Services to AKS
    runs-on: ubuntu-latest
    needs: apply
    if: needs.apply.result == 'success'
    environment: production
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group broxiva-prod-rg \
            --name broxiva-prod-aks \
            --overwrite-existing

      - name: Deploy services to AKS
        run: |
          # Apply Kubernetes manifests
          if [ -d "infrastructure/kubernetes/production" ]; then
            kubectl apply -f infrastructure/kubernetes/production/ --recursive
          fi

          # Update deployments with new images
          VERSION=$(date +%Y%m%d)-$(git rev-parse --short HEAD)
          SERVICES=("api" "web")

          for service in "${SERVICES[@]}"; do
            kubectl set image deployment/broxiva-$service \
              $service=broxivaprodacr.azurecr.io/broxiva/$service:$VERSION \
              -n broxiva || echo "Deployment broxiva-$service not found, skipping..."
          done

      - name: Wait for deployments
        run: |
          kubectl rollout status deployment/broxiva-api -n broxiva --timeout=300s || true
          kubectl rollout status deployment/broxiva-web -n broxiva --timeout=300s || true

      - name: Verify deployment health
        run: |
          echo "### Deployment Health Check" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          kubectl get pods -n broxiva -o wide >> $GITHUB_STEP_SUMMARY 2>/dev/null || echo "Could not get pods" >> $GITHUB_STEP_SUMMARY

          # Health check endpoints
          API_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://api.broxiva.com/api/health || echo "000")
          WEB_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://broxiva.com/health || echo "000")

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Service | Endpoint | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| API | https://api.broxiva.com/api/health | $API_STATUS |" >> $GITHUB_STEP_SUMMARY
          echo "| Web | https://broxiva.com/health | $WEB_STATUS |" >> $GITHUB_STEP_SUMMARY

  verify-production:
    name: Verify Production Deployment
    runs-on: ubuntu-latest
    needs: deploy-to-aks
    if: always() && needs.deploy-to-aks.result == 'success'
    steps:
      - name: Comprehensive health checks
        run: |
          echo "### Production Verification" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp:** $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Test critical endpoints
          ENDPOINTS=(
            "https://api.broxiva.com/api/health"
            "https://api.broxiva.com/api/health/ready"
            "https://broxiva.com"
          )

          ALL_HEALTHY=true
          echo "| Endpoint | Status | Response Time |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|--------|---------------|" >> $GITHUB_STEP_SUMMARY

          for endpoint in "${ENDPOINTS[@]}"; do
            START=$(date +%s%3N)
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$endpoint" || echo "000")
            END=$(date +%s%3N)
            DURATION=$((END - START))

            if [ "$STATUS" -ge 200 ] && [ "$STATUS" -lt 400 ]; then
              echo "| $endpoint | $STATUS | ${DURATION}ms |" >> $GITHUB_STEP_SUMMARY
            else
              echo "| $endpoint | $STATUS | ${DURATION}ms |" >> $GITHUB_STEP_SUMMARY
              ALL_HEALTHY=false
            fi
          done

          if [ "$ALL_HEALTHY" = false ]; then
            echo "::warning::Some endpoints are not healthy"
          fi

      - name: Generate deployment certificate
        run: |
          cat > deployment-certificate.json << EOF
          {
            "platform": "Broxiva E-Commerce Platform",
            "environment": "production",
            "deployment_time": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "commit": "${{ github.sha }}",
            "workflow_run": "${{ github.run_id }}",
            "deployer": "${{ github.actor }}",
            "infrastructure": {
              "cloud": "Azure",
              "region": "eastus",
              "aks_cluster": "broxiva-prod-aks",
              "acr": "broxivaprodacr.azurecr.io"
            },
            "services_deployed": [
              "api", "web", "ai-agents", "ai-engine", "analytics", "chatbot",
              "fraud-detection", "inventory", "media", "notification",
              "personalization", "pricing", "recommendation", "search", "supplier-integration"
            ],
            "verified": true
          }
          EOF

      - name: Upload deployment certificate
        uses: actions/upload-artifact@v4
        with:
          name: production-deployment-certificate
          path: deployment-certificate.json
          retention-days: 365

  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [validate, apply, deploy-to-aks, verify-production]
    if: always()
    steps:
      - name: Send Slack notification
        uses: slackapi/slack-github-action@v1.26.0
        with:
          payload: |
            {
              "text": "Production Deployment Complete",
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "Broxiva Production Deployment"
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {"type": "mrkdwn", "text": "*Terraform:*\n${{ needs.apply.result || 'skipped' }}"},
                    {"type": "mrkdwn", "text": "*AKS Deploy:*\n${{ needs.deploy-to-aks.result || 'skipped' }}"},
                    {"type": "mrkdwn", "text": "*Verification:*\n${{ needs.verify-production.result || 'skipped' }}"},
                    {"type": "mrkdwn", "text": "*Deployer:*\n${{ github.actor }}"}
                  ]
                },
                {
                  "type": "actions",
                  "elements": [
                    {
                      "type": "button",
                      "text": {"type": "plain_text", "text": "View Deployment"},
                      "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                    },
                    {
                      "type": "button",
                      "text": {"type": "plain_text", "text": "Azure Portal"},
                      "url": "https://portal.azure.com"
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK
        if: env.SLACK_WEBHOOK_URL != ''
