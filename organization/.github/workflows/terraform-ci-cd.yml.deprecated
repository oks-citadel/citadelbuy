# ============================================================================
# TERRAFORM CI/CD PIPELINE - STRICT DEV-PROD GATING
# ============================================================================
# ARCHITECTURE:
# - DEV Stage: Validation-only (NO real cloud resources deployed)
# - PROD Stage: Only runs if DEV passed with ZERO errors
# - Auto-fix: Autonomous remediation for common Dev failures
#
# SECURITY: Production deployment is IMPOSSIBLE unless Dev is fully validated
# ============================================================================

name: Terraform CI/CD Pipeline

on:
  push:
    branches:
      - main
    paths:
      - 'organization/infrastructure/terraform/**'
      - '.github/workflows/terraform-ci-cd.yml'
  pull_request:
    branches:
      - main
    paths:
      - 'organization/infrastructure/terraform/**'
      - '.github/workflows/terraform-ci-cd.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - aws-prod
        default: aws-prod
      force_apply:
        description: 'Force apply even if plan shows no changes'
        required: false
        type: boolean
        default: false
      skip_cost_estimation:
        description: 'Skip cost estimation (faster builds)'
        required: false
        type: boolean
        default: false

env:
  TF_VERSION: '1.5.7'
  TF_WORKING_DIR: 'organization/infrastructure/terraform/environments/aws-prod'
  TF_PLUGIN_CACHE_DIR: ${{ github.workspace }}/.terraform.d/plugin-cache
  AWS_REGION: 'us-east-1'
  # Validation thresholds
  MAX_COST_INCREASE_PERCENT: 20
  MAX_RESOURCES_TO_DESTROY: 5

concurrency:
  group: terraform-${{ github.ref }}
  cancel-in-progress: false  # Never cancel terraform runs mid-execution

permissions:
  contents: read
  pull-requests: write
  id-token: write
  security-events: write
  actions: read

jobs:
  # ============================================================================
  # STAGE 0: PRE-FLIGHT CHECKS
  # ============================================================================

  preflight:
    name: Pre-Flight Checks
    runs-on: ubuntu-latest
    outputs:
      terraform_changed: ${{ steps.changes.outputs.terraform }}
      should_run_dev: ${{ steps.decision.outputs.should_run_dev }}
      should_run_prod: ${{ steps.decision.outputs.should_run_prod }}
      environment: ${{ steps.decision.outputs.environment }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect Terraform Changes
        id: changes
        uses: dorny/paths-filter@v3
        with:
          filters: |
            terraform:
              - 'organization/infrastructure/terraform/**'

      - name: Determine Pipeline Decision
        id: decision
        run: |
          # Always run dev validation for PR and push events
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "should_run_dev=true" >> $GITHUB_OUTPUT
            echo "should_run_prod=false" >> $GITHUB_OUTPUT
            echo "environment=aws-prod" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "should_run_dev=true" >> $GITHUB_OUTPUT
            echo "should_run_prod=true" >> $GITHUB_OUTPUT
            echo "environment=aws-prod" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "should_run_dev=true" >> $GITHUB_OUTPUT
            echo "should_run_prod=true" >> $GITHUB_OUTPUT
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          else
            echo "should_run_dev=false" >> $GITHUB_OUTPUT
            echo "should_run_prod=false" >> $GITHUB_OUTPUT
            echo "environment=aws-prod" >> $GITHUB_OUTPUT
          fi

  # ============================================================================
  # STAGE 1: DEV VALIDATION (NO REAL RESOURCES - SIMULATION ONLY)
  # ============================================================================
  # This stage performs comprehensive validation WITHOUT deploying any resources
  # Uses: -refresh=false, -lock=false, mock providers where applicable
  # ============================================================================

  dev-terraform-init:
    name: '[DEV] Terraform Init & Provider Lock'
    runs-on: ubuntu-latest
    needs: preflight
    if: needs.preflight.outputs.should_run_dev == 'true'
    outputs:
      init_status: ${{ steps.init.outputs.status }}
      providers_locked: ${{ steps.providers.outputs.locked }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: true

      - name: Create Plugin Cache Directory
        run: mkdir -p ${{ env.TF_PLUGIN_CACHE_DIR }}

      - name: Cache Terraform Providers
        uses: actions/cache@v4
        with:
          path: ${{ env.TF_PLUGIN_CACHE_DIR }}
          key: terraform-providers-${{ runner.os }}-${{ hashFiles('**/.terraform.lock.hcl') }}
          restore-keys: |
            terraform-providers-${{ runner.os }}-

      - name: Configure AWS Credentials (Read-Only for Validation)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: terraform-dev-validation-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}
        continue-on-error: true  # Allow init without AWS for syntax validation

      - name: Terraform Init (Dev - Backend Disabled for Validation)
        id: init
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          # Initialize without backend for pure syntax/provider validation
          terraform init -backend=false -input=false 2>&1 | tee init_output.txt
          if [ ${PIPESTATUS[0]} -eq 0 ]; then
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "status=failed" >> $GITHUB_OUTPUT
            # Auto-fix: Try to resolve provider issues
            echo "::warning::Init failed, attempting auto-fix..."
          fi

      - name: Terraform Providers Lock
        id: providers
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          terraform providers lock -platform=linux_amd64 -platform=darwin_amd64 -platform=darwin_arm64 2>&1 | tee providers_output.txt
          if [ ${PIPESTATUS[0]} -eq 0 ]; then
            echo "locked=true" >> $GITHUB_OUTPUT
          else
            echo "locked=false" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true

      - name: Upload Init Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dev-init-artifacts
          path: |
            ${{ env.TF_WORKING_DIR }}/init_output.txt
            ${{ env.TF_WORKING_DIR }}/providers_output.txt
            ${{ env.TF_WORKING_DIR }}/.terraform.lock.hcl
          retention-days: 7

  dev-terraform-validate:
    name: '[DEV] Terraform Validate & Format'
    runs-on: ubuntu-latest
    needs: [preflight, dev-terraform-init]
    if: needs.preflight.outputs.should_run_dev == 'true'
    outputs:
      validate_status: ${{ steps.validate.outputs.status }}
      fmt_status: ${{ steps.fmt.outputs.status }}
      fmt_diff: ${{ steps.fmt.outputs.diff }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Restore Plugin Cache
        uses: actions/cache@v4
        with:
          path: ${{ env.TF_PLUGIN_CACHE_DIR }}
          key: terraform-providers-${{ runner.os }}-${{ hashFiles('**/.terraform.lock.hcl') }}

      - name: Terraform Init (Backend Disabled)
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform init -backend=false -input=false

      - name: Terraform Format Check
        id: fmt
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          terraform fmt -check -recursive -diff 2>&1 | tee fmt_output.txt
          if [ ${PIPESTATUS[0]} -eq 0 ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "diff=" >> $GITHUB_OUTPUT
          else
            echo "status=failed" >> $GITHUB_OUTPUT
            # Capture diff for auto-fix
            terraform fmt -recursive -diff > fmt_diff.txt 2>&1 || true
            echo "diff<<EOF" >> $GITHUB_OUTPUT
            cat fmt_diff.txt >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi

      - name: Terraform Validate
        id: validate
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          terraform validate -json 2>&1 | tee validate_output.json
          if jq -e '.valid == true' validate_output.json > /dev/null; then
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "::error::Terraform validation failed"
            jq -r '.diagnostics[] | "[\(.severity)] \(.summary): \(.detail)"' validate_output.json
          fi

      - name: Upload Validation Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dev-validate-artifacts
          path: |
            ${{ env.TF_WORKING_DIR }}/fmt_output.txt
            ${{ env.TF_WORKING_DIR }}/validate_output.json
          retention-days: 7

  dev-terraform-plan:
    name: '[DEV] Terraform Plan (Simulation Only)'
    runs-on: ubuntu-latest
    needs: [preflight, dev-terraform-init, dev-terraform-validate]
    if: needs.preflight.outputs.should_run_dev == 'true' && needs.dev-terraform-validate.outputs.validate_status == 'success'
    outputs:
      plan_status: ${{ steps.plan.outputs.status }}
      plan_exitcode: ${{ steps.plan.outputs.exitcode }}
      has_changes: ${{ steps.plan-analysis.outputs.has_changes }}
      resources_to_add: ${{ steps.plan-analysis.outputs.resources_to_add }}
      resources_to_change: ${{ steps.plan-analysis.outputs.resources_to_change }}
      resources_to_destroy: ${{ steps.plan-analysis.outputs.resources_to_destroy }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false  # Required for plan JSON output

      - name: Restore Plugin Cache
        uses: actions/cache@v4
        with:
          path: ${{ env.TF_PLUGIN_CACHE_DIR }}
          key: terraform-providers-${{ runner.os }}-${{ hashFiles('**/.terraform.lock.hcl') }}

      - name: Configure AWS Credentials (Read-Only)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: terraform-dev-plan-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Terraform Init (With Backend - Read Only)
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform init -input=false

      - name: Terraform Plan (No Lock, No Refresh Option for Dev)
        id: plan
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          set +e
          # Run plan with lock=false for dev validation (no state locking)
          terraform plan \
            -input=false \
            -lock=false \
            -out=tfplan.binary \
            -detailed-exitcode \
            2>&1 | tee plan_output.txt

          EXITCODE=${PIPESTATUS[0]}
          echo "exitcode=$EXITCODE" >> $GITHUB_OUTPUT

          if [ $EXITCODE -eq 0 ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "No changes detected"
          elif [ $EXITCODE -eq 1 ]; then
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "::error::Terraform plan failed"
          elif [ $EXITCODE -eq 2 ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "Changes detected"
          fi

      - name: Convert Plan to JSON
        if: steps.plan.outputs.status == 'success'
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          terraform show -json tfplan.binary > validated-plan.json
          # Create human-readable plan
          terraform show tfplan.binary > validated-plan.txt

      - name: Analyze Plan
        id: plan-analysis
        if: steps.plan.outputs.status == 'success'
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          if [ -f validated-plan.json ]; then
            # Extract resource change counts
            ADD=$(jq '[.resource_changes[]? | select(.change.actions | contains(["create"]))] | length' validated-plan.json)
            CHANGE=$(jq '[.resource_changes[]? | select(.change.actions | contains(["update"]))] | length' validated-plan.json)
            DESTROY=$(jq '[.resource_changes[]? | select(.change.actions | contains(["delete"]))] | length' validated-plan.json)

            echo "resources_to_add=$ADD" >> $GITHUB_OUTPUT
            echo "resources_to_change=$CHANGE" >> $GITHUB_OUTPUT
            echo "resources_to_destroy=$DESTROY" >> $GITHUB_OUTPUT

            if [ $ADD -gt 0 ] || [ $CHANGE -gt 0 ] || [ $DESTROY -gt 0 ]; then
              echo "has_changes=true" >> $GITHUB_OUTPUT
            else
              echo "has_changes=false" >> $GITHUB_OUTPUT
            fi

            # Safety check: Alert if too many resources being destroyed
            if [ $DESTROY -gt ${{ env.MAX_RESOURCES_TO_DESTROY }} ]; then
              echo "::error::SAFETY BLOCK: Plan would destroy $DESTROY resources (max: ${{ env.MAX_RESOURCES_TO_DESTROY }})"
              exit 1
            fi
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "resources_to_add=0" >> $GITHUB_OUTPUT
            echo "resources_to_change=0" >> $GITHUB_OUTPUT
            echo "resources_to_destroy=0" >> $GITHUB_OUTPUT
          fi

      - name: Upload Plan Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dev-plan-artifacts
          path: |
            ${{ env.TF_WORKING_DIR }}/validated-plan.json
            ${{ env.TF_WORKING_DIR }}/validated-plan.txt
            ${{ env.TF_WORKING_DIR }}/plan_output.txt
          retention-days: 7

  dev-security-scan:
    name: '[DEV] Security Scanning (tfsec/checkov)'
    runs-on: ubuntu-latest
    needs: [preflight, dev-terraform-validate]
    if: needs.preflight.outputs.should_run_dev == 'true'
    outputs:
      tfsec_status: ${{ steps.tfsec.outputs.status }}
      checkov_status: ${{ steps.checkov.outputs.status }}
      security_passed: ${{ steps.security-verdict.outputs.passed }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Run tfsec
        id: tfsec
        uses: aquasecurity/tfsec-action@v1.0.3
        with:
          working_directory: ${{ env.TF_WORKING_DIR }}
          format: json
          soft_fail: true
        continue-on-error: true

      - name: Process tfsec Results
        run: |
          if [ -f results.json ]; then
            CRITICAL=$(jq '[.results[]? | select(.severity == "CRITICAL")] | length' results.json 2>/dev/null || echo "0")
            HIGH=$(jq '[.results[]? | select(.severity == "HIGH")] | length' results.json 2>/dev/null || echo "0")
            if [ "$CRITICAL" -gt 0 ]; then
              echo "status=failed" >> $GITHUB_OUTPUT
              echo "::error::tfsec found $CRITICAL critical issues"
            elif [ "$HIGH" -gt 5 ]; then
              echo "status=warning" >> $GITHUB_OUTPUT
              echo "::warning::tfsec found $HIGH high-severity issues"
            else
              echo "status=success" >> $GITHUB_OUTPUT
            fi
          else
            echo "status=success" >> $GITHUB_OUTPUT
          fi

      - name: Run Checkov
        id: checkov
        uses: bridgecrewio/checkov-action@v12
        with:
          directory: ${{ env.TF_WORKING_DIR }}
          framework: terraform
          output_format: json
          output_file_path: checkov-results.json
          soft_fail: true
          skip_check: CKV_AWS_144,CKV_AWS_145  # Skip cross-region replication checks if not applicable
        continue-on-error: true

      - name: Process Checkov Results
        run: |
          if [ -f checkov-results.json ]; then
            FAILED=$(jq '.results.failed_checks | length' checkov-results.json 2>/dev/null || echo "0")
            if [ "$FAILED" -gt 10 ]; then
              echo "status=failed" >> $GITHUB_OUTPUT
            else
              echo "status=success" >> $GITHUB_OUTPUT
            fi
          else
            echo "status=success" >> $GITHUB_OUTPUT
          fi

      - name: Security Verdict
        id: security-verdict
        run: |
          TFSEC="${{ steps.tfsec.outputs.status }}"
          CHECKOV="${{ steps.checkov.outputs.status }}"

          if [[ "$TFSEC" == "failed" ]] || [[ "$CHECKOV" == "failed" ]]; then
            echo "passed=false" >> $GITHUB_OUTPUT
            echo "::error::Security scan failed - blocking deployment"
          else
            echo "passed=true" >> $GITHUB_OUTPUT
          fi

      - name: Upload Security Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dev-security-artifacts
          path: |
            results.json
            checkov-results.json
          retention-days: 7
        continue-on-error: true

  dev-policy-check:
    name: '[DEV] Policy-as-Code (OPA/Conftest)'
    runs-on: ubuntu-latest
    needs: [preflight, dev-terraform-plan]
    if: needs.preflight.outputs.should_run_dev == 'true' && needs.dev-terraform-plan.outputs.plan_status == 'success'
    outputs:
      policy_status: ${{ steps.policy.outputs.status }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Plan Artifact
        uses: actions/download-artifact@v4
        with:
          name: dev-plan-artifacts
          path: ${{ env.TF_WORKING_DIR }}

      - name: Setup OPA
        uses: open-policy-agent/setup-opa@v2
        with:
          version: latest

      - name: Create OPA Policies
        run: |
          mkdir -p ${{ env.TF_WORKING_DIR }}/policies

          # Create baseline security policies
          cat > ${{ env.TF_WORKING_DIR }}/policies/terraform.rego << 'EOF'
          package terraform.security

          import future.keywords.in

          # Deny resources without required tags
          deny[msg] {
            resource := input.resource_changes[_]
            resource.change.actions[_] == "create"
            not resource.change.after.tags.Project
            msg := sprintf("Resource %s missing required tag: Project", [resource.address])
          }

          deny[msg] {
            resource := input.resource_changes[_]
            resource.change.actions[_] == "create"
            not resource.change.after.tags.Environment
            msg := sprintf("Resource %s missing required tag: Environment", [resource.address])
          }

          # Deny unencrypted S3 buckets
          deny[msg] {
            resource := input.resource_changes[_]
            resource.type == "aws_s3_bucket"
            resource.change.actions[_] == "create"
            not resource.change.after.server_side_encryption_configuration
            msg := sprintf("S3 bucket %s must have encryption enabled", [resource.address])
          }

          # Deny public security group rules
          deny[msg] {
            resource := input.resource_changes[_]
            resource.type == "aws_security_group_rule"
            resource.change.actions[_] == "create"
            resource.change.after.cidr_blocks[_] == "0.0.0.0/0"
            resource.change.after.type == "ingress"
            msg := sprintf("Security group rule %s allows unrestricted inbound access", [resource.address])
          }

          # Deny unencrypted RDS instances
          deny[msg] {
            resource := input.resource_changes[_]
            resource.type == "aws_db_instance"
            resource.change.actions[_] == "create"
            resource.change.after.storage_encrypted == false
            msg := sprintf("RDS instance %s must have encryption enabled", [resource.address])
          }

          # Warn on large instance types in production
          warn[msg] {
            resource := input.resource_changes[_]
            resource.type == "aws_instance"
            resource.change.actions[_] == "create"
            contains(resource.change.after.instance_type, "xlarge")
            msg := sprintf("Instance %s uses xlarge type - verify cost implications", [resource.address])
          }

          # Naming convention enforcement
          deny[msg] {
            resource := input.resource_changes[_]
            resource.change.actions[_] == "create"
            not startswith(resource.name, "broxiva")
            not contains(resource.address, "module.")
            msg := sprintf("Resource %s does not follow naming convention (must start with 'broxiva')", [resource.address])
          }
          EOF

      - name: Run OPA Policy Check
        id: policy
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          if [ -f validated-plan.json ]; then
            opa eval \
              --data policies/ \
              --input validated-plan.json \
              --format pretty \
              'data.terraform.security.deny' > policy_results.txt 2>&1

            VIOLATIONS=$(grep -c "deny" policy_results.txt || echo "0")

            if [ "$VIOLATIONS" -gt 0 ]; then
              echo "status=failed" >> $GITHUB_OUTPUT
              echo "::warning::OPA policy violations detected"
              cat policy_results.txt
            else
              echo "status=success" >> $GITHUB_OUTPUT
            fi
          else
            echo "status=skipped" >> $GITHUB_OUTPUT
            echo "::warning::No plan file found for policy check"
          fi

      - name: Upload Policy Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dev-policy-artifacts
          path: |
            ${{ env.TF_WORKING_DIR }}/policy_results.txt
            ${{ env.TF_WORKING_DIR }}/policies/
          retention-days: 7
        continue-on-error: true

  dev-cost-estimation:
    name: '[DEV] Cost Estimation'
    runs-on: ubuntu-latest
    needs: [preflight, dev-terraform-plan]
    if: |
      needs.preflight.outputs.should_run_dev == 'true' &&
      needs.dev-terraform-plan.outputs.plan_status == 'success' &&
      github.event.inputs.skip_cost_estimation != 'true'
    outputs:
      estimated_monthly_cost: ${{ steps.cost.outputs.monthly_cost }}
      cost_increase_percent: ${{ steps.cost.outputs.increase_percent }}
      cost_status: ${{ steps.cost.outputs.status }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Plan Artifact
        uses: actions/download-artifact@v4
        with:
          name: dev-plan-artifacts
          path: ${{ env.TF_WORKING_DIR }}

      - name: Setup Infracost
        uses: infracost/actions/setup@v3
        with:
          api-key: ${{ secrets.INFRACOST_API_KEY }}
        continue-on-error: true

      - name: Run Infracost Analysis
        id: cost
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          if command -v infracost &> /dev/null && [ -n "${{ secrets.INFRACOST_API_KEY }}" ]; then
            infracost breakdown \
              --path validated-plan.json \
              --format json \
              --out-file cost-estimate.json 2>&1 || true

            if [ -f cost-estimate.json ]; then
              MONTHLY_COST=$(jq -r '.totalMonthlyCost // "0"' cost-estimate.json)
              DIFF_COST=$(jq -r '.diffMonthlyCost // "0"' cost-estimate.json)
              PREV_COST=$(jq -r '.pastTotalMonthlyCost // "0"' cost-estimate.json)

              echo "monthly_cost=$MONTHLY_COST" >> $GITHUB_OUTPUT

              # Calculate percentage increase
              if [ "$PREV_COST" != "0" ] && [ "$PREV_COST" != "null" ]; then
                INCREASE=$(echo "scale=2; ($DIFF_COST / $PREV_COST) * 100" | bc)
                echo "increase_percent=$INCREASE" >> $GITHUB_OUTPUT

                if (( $(echo "$INCREASE > ${{ env.MAX_COST_INCREASE_PERCENT }}" | bc -l) )); then
                  echo "status=warning" >> $GITHUB_OUTPUT
                  echo "::warning::Cost increase exceeds threshold: $INCREASE%"
                else
                  echo "status=success" >> $GITHUB_OUTPUT
                fi
              else
                echo "increase_percent=0" >> $GITHUB_OUTPUT
                echo "status=success" >> $GITHUB_OUTPUT
              fi

              # Generate summary
              infracost output --path cost-estimate.json --format table > cost-summary.txt
            else
              echo "monthly_cost=unknown" >> $GITHUB_OUTPUT
              echo "increase_percent=0" >> $GITHUB_OUTPUT
              echo "status=skipped" >> $GITHUB_OUTPUT
            fi
          else
            echo "::notice::Infracost not configured - skipping cost estimation"
            echo "monthly_cost=unknown" >> $GITHUB_OUTPUT
            echo "increase_percent=0" >> $GITHUB_OUTPUT
            echo "status=skipped" >> $GITHUB_OUTPUT
          fi

      - name: Upload Cost Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dev-cost-artifacts
          path: |
            ${{ env.TF_WORKING_DIR }}/cost-estimate.json
            ${{ env.TF_WORKING_DIR }}/cost-summary.txt
          retention-days: 7
        continue-on-error: true

  dev-drift-detection:
    name: '[DEV] Drift Risk Detection'
    runs-on: ubuntu-latest
    needs: [preflight, dev-terraform-plan]
    if: needs.preflight.outputs.should_run_dev == 'true' && needs.dev-terraform-plan.outputs.plan_status == 'success'
    outputs:
      drift_detected: ${{ steps.drift.outputs.detected }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download Plan Artifact
        uses: actions/download-artifact@v4
        with:
          name: dev-plan-artifacts
          path: ${{ env.TF_WORKING_DIR }}

      - name: Analyze Drift Risk
        id: drift
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          if [ -f validated-plan.json ]; then
            # Check for resources with drift-prone configurations
            DRIFT_RISKS=$(jq '[.resource_changes[]? | select(
              (.change.actions | contains(["update"])) and
              (.change.before != .change.after)
            )] | length' validated-plan.json)

            if [ "$DRIFT_RISKS" -gt 0 ]; then
              echo "detected=true" >> $GITHUB_OUTPUT
              echo "::notice::$DRIFT_RISKS resources show state drift"
            else
              echo "detected=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "detected=false" >> $GITHUB_OUTPUT
          fi

  # ============================================================================
  # STAGE 1.5: AUTO-FIX (Autonomous Remediation for Dev Failures)
  # ============================================================================

  dev-auto-fix:
    name: '[DEV] Auto-Fix Attempt'
    runs-on: ubuntu-latest
    needs: [preflight, dev-terraform-validate]
    if: |
      needs.preflight.outputs.should_run_dev == 'true' &&
      (needs.dev-terraform-validate.outputs.fmt_status == 'failed')
    outputs:
      fix_applied: ${{ steps.auto-fix.outputs.applied }}
      fix_type: ${{ steps.auto-fix.outputs.type }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ github.head_ref || github.ref_name }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Auto-Fix Formatting Issues
        id: auto-fix
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          # Auto-fix formatting
          if [[ "${{ needs.dev-terraform-validate.outputs.fmt_status }}" == "failed" ]]; then
            echo "Attempting to auto-fix formatting..."
            terraform fmt -recursive

            # Check if any files were modified
            if git diff --quiet; then
              echo "applied=false" >> $GITHUB_OUTPUT
              echo "type=none" >> $GITHUB_OUTPUT
            else
              echo "applied=true" >> $GITHUB_OUTPUT
              echo "type=formatting" >> $GITHUB_OUTPUT

              # Create auto-fix commit
              git config user.name "github-actions[bot]"
              git config user.email "github-actions[bot]@users.noreply.github.com"
              git add -A
              git commit -m "fix(terraform): Auto-fix formatting issues

              Automatically formatted Terraform files to match canonical style.

              [auto-generated by terraform-ci-cd pipeline]"

              # Push only on PR branches
              if [[ "${{ github.event_name }}" == "pull_request" ]]; then
                git push
                echo "::notice::Auto-fix applied and pushed to branch"
              else
                echo "::warning::Auto-fix ready but not pushed (main branch protection)"
              fi
            fi
          else
            echo "applied=false" >> $GITHUB_OUTPUT
            echo "type=none" >> $GITHUB_OUTPUT
          fi

  # ============================================================================
  # STAGE 2: DEV VALIDATION VERDICT
  # ============================================================================

  dev-validation-verdict:
    name: '[DEV] Validation Verdict'
    runs-on: ubuntu-latest
    needs: [
      preflight,
      dev-terraform-init,
      dev-terraform-validate,
      dev-terraform-plan,
      dev-security-scan,
      dev-policy-check,
      dev-cost-estimation,
      dev-drift-detection
    ]
    if: always() && needs.preflight.outputs.should_run_dev == 'true'
    outputs:
      verdict: ${{ steps.verdict.outputs.result }}
      can_proceed_to_prod: ${{ steps.verdict.outputs.can_proceed }}
      summary: ${{ steps.verdict.outputs.summary }}
    steps:
      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
        continue-on-error: true

      - name: Calculate Validation Verdict
        id: verdict
        run: |
          echo "## DEV Validation Results" > verdict.md
          echo "" >> verdict.md

          # Collect all statuses
          INIT_STATUS="${{ needs.dev-terraform-init.outputs.init_status }}"
          VALIDATE_STATUS="${{ needs.dev-terraform-validate.outputs.validate_status }}"
          FMT_STATUS="${{ needs.dev-terraform-validate.outputs.fmt_status }}"
          PLAN_STATUS="${{ needs.dev-terraform-plan.outputs.plan_status }}"
          SECURITY_PASSED="${{ needs.dev-security-scan.outputs.security_passed }}"
          POLICY_STATUS="${{ needs.dev-policy-check.outputs.policy_status }}"

          # Determine verdict
          ALL_PASS=true

          echo "| Check | Status |" >> verdict.md
          echo "|-------|--------|" >> verdict.md

          if [[ "$INIT_STATUS" != "success" ]]; then
            echo "| Terraform Init | FAILED |" >> verdict.md
            ALL_PASS=false
          else
            echo "| Terraform Init | PASSED |" >> verdict.md
          fi

          if [[ "$VALIDATE_STATUS" != "success" ]]; then
            echo "| Terraform Validate | FAILED |" >> verdict.md
            ALL_PASS=false
          else
            echo "| Terraform Validate | PASSED |" >> verdict.md
          fi

          if [[ "$FMT_STATUS" != "success" ]]; then
            echo "| Terraform Format | FAILED |" >> verdict.md
            ALL_PASS=false
          else
            echo "| Terraform Format | PASSED |" >> verdict.md
          fi

          if [[ "$PLAN_STATUS" != "success" ]]; then
            echo "| Terraform Plan | FAILED |" >> verdict.md
            ALL_PASS=false
          else
            echo "| Terraform Plan | PASSED |" >> verdict.md
          fi

          if [[ "$SECURITY_PASSED" != "true" ]]; then
            echo "| Security Scan | FAILED |" >> verdict.md
            ALL_PASS=false
          else
            echo "| Security Scan | PASSED |" >> verdict.md
          fi

          if [[ "$POLICY_STATUS" == "failed" ]]; then
            echo "| Policy Check | FAILED |" >> verdict.md
            ALL_PASS=false
          else
            echo "| Policy Check | PASSED |" >> verdict.md
          fi

          echo "" >> verdict.md

          # Plan summary
          echo "### Plan Summary" >> verdict.md
          echo "- Resources to add: ${{ needs.dev-terraform-plan.outputs.resources_to_add }}" >> verdict.md
          echo "- Resources to change: ${{ needs.dev-terraform-plan.outputs.resources_to_change }}" >> verdict.md
          echo "- Resources to destroy: ${{ needs.dev-terraform-plan.outputs.resources_to_destroy }}" >> verdict.md
          echo "" >> verdict.md

          # Cost summary
          echo "### Cost Estimate" >> verdict.md
          echo "- Estimated Monthly Cost: \$${{ needs.dev-cost-estimation.outputs.estimated_monthly_cost }}" >> verdict.md
          echo "- Cost Change: ${{ needs.dev-cost-estimation.outputs.cost_increase_percent }}%" >> verdict.md
          echo "" >> verdict.md

          # Final verdict
          if [[ "$ALL_PASS" == "true" ]]; then
            echo "result=PASS" >> $GITHUB_OUTPUT
            echo "can_proceed=true" >> $GITHUB_OUTPUT
            echo "### VERDICT: PASS" >> verdict.md
            echo "All validations passed. Ready for production deployment." >> verdict.md
          else
            echo "result=FAIL" >> $GITHUB_OUTPUT
            echo "can_proceed=false" >> $GITHUB_OUTPUT
            echo "### VERDICT: FAIL" >> verdict.md
            echo "One or more validations failed. Production deployment BLOCKED." >> verdict.md
          fi

          # Output summary
          echo "summary<<EOF" >> $GITHUB_OUTPUT
          cat verdict.md >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Post Verdict to PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const verdict = `${{ steps.verdict.outputs.summary }}`;
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: verdict
            });

      - name: Upload Verdict Artifact
        uses: actions/upload-artifact@v4
        with:
          name: dev-verdict
          path: verdict.md
          retention-days: 30

      - name: Block if Failed
        if: steps.verdict.outputs.result == 'FAIL'
        run: |
          echo "::error::DEV VALIDATION FAILED - Production deployment is BLOCKED"
          exit 1

  # ============================================================================
  # STAGE 3: PRODUCTION GATE (Explicit Approval Required)
  # ============================================================================

  prod-gate:
    name: '[GATE] Production Approval'
    runs-on: ubuntu-latest
    needs: [preflight, dev-validation-verdict]
    if: |
      needs.preflight.outputs.should_run_prod == 'true' &&
      needs.dev-validation-verdict.outputs.can_proceed_to_prod == 'true' &&
      github.ref == 'refs/heads/main'
    environment:
      name: production
      url: https://console.aws.amazon.com/console/home
    steps:
      - name: Production Gate Checkpoint
        run: |
          echo "============================================"
          echo "PRODUCTION GATE CHECKPOINT"
          echo "============================================"
          echo ""
          echo "DEV Validation: ${{ needs.dev-validation-verdict.outputs.verdict }}"
          echo "Proceeding to Production: APPROVED"
          echo ""
          echo "This deployment will apply REAL changes to production infrastructure."
          echo "============================================"

  # ============================================================================
  # STAGE 4: PRODUCTION DEPLOYMENT
  # ============================================================================

  prod-terraform-init:
    name: '[PROD] Terraform Init'
    runs-on: ubuntu-latest
    needs: [preflight, prod-gate]
    if: needs.preflight.outputs.should_run_prod == 'true'
    outputs:
      init_status: ${{ steps.init.outputs.status }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Restore Plugin Cache
        uses: actions/cache@v4
        with:
          path: ${{ env.TF_PLUGIN_CACHE_DIR }}
          key: terraform-providers-${{ runner.os }}-${{ hashFiles('**/.terraform.lock.hcl') }}

      - name: Configure AWS Credentials (Production)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: terraform-prod-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Terraform Init (Production Backend)
        id: init
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          terraform init -input=false
          if [ $? -eq 0 ]; then
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Verify Provider Lock
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "Verifying provider lock file..."
          if [ -f .terraform.lock.hcl ]; then
            echo "Provider lock file exists and will be used"
          else
            echo "::error::Provider lock file missing - aborting"
            exit 1
          fi

  prod-terraform-plan-verify:
    name: '[PROD] Plan Verification'
    runs-on: ubuntu-latest
    needs: [preflight, prod-terraform-init]
    if: needs.preflight.outputs.should_run_prod == 'true'
    outputs:
      plan_matches: ${{ steps.verify.outputs.matches }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Restore Plugin Cache
        uses: actions/cache@v4
        with:
          path: ${{ env.TF_PLUGIN_CACHE_DIR }}
          key: terraform-providers-${{ runner.os }}-${{ hashFiles('**/.terraform.lock.hcl') }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: terraform-prod-plan-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Download Dev Plan Artifact
        uses: actions/download-artifact@v4
        with:
          name: dev-plan-artifacts
          path: ${{ env.TF_WORKING_DIR }}/dev-artifacts

      - name: Terraform Init
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform init -input=false

      - name: Terraform Plan (Production - Fresh)
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          terraform plan \
            -input=false \
            -out=prod-plan.binary \
            -detailed-exitcode || true

          terraform show -json prod-plan.binary > prod-plan.json

      - name: Verify Plan Consistency
        id: verify
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          # Compare resource change counts between dev and prod plans
          DEV_ADD=$(jq '[.resource_changes[]? | select(.change.actions | contains(["create"]))] | length' dev-artifacts/validated-plan.json 2>/dev/null || echo "0")
          DEV_CHANGE=$(jq '[.resource_changes[]? | select(.change.actions | contains(["update"]))] | length' dev-artifacts/validated-plan.json 2>/dev/null || echo "0")
          DEV_DESTROY=$(jq '[.resource_changes[]? | select(.change.actions | contains(["delete"]))] | length' dev-artifacts/validated-plan.json 2>/dev/null || echo "0")

          PROD_ADD=$(jq '[.resource_changes[]? | select(.change.actions | contains(["create"]))] | length' prod-plan.json)
          PROD_CHANGE=$(jq '[.resource_changes[]? | select(.change.actions | contains(["update"]))] | length' prod-plan.json)
          PROD_DESTROY=$(jq '[.resource_changes[]? | select(.change.actions | contains(["delete"]))] | length' prod-plan.json)

          echo "Dev Plan:  +$DEV_ADD ~$DEV_CHANGE -$DEV_DESTROY"
          echo "Prod Plan: +$PROD_ADD ~$PROD_CHANGE -$PROD_DESTROY"

          # Allow minor drift but flag significant differences
          if [ "$DEV_ADD" == "$PROD_ADD" ] && [ "$DEV_CHANGE" == "$PROD_CHANGE" ] && [ "$DEV_DESTROY" == "$PROD_DESTROY" ]; then
            echo "matches=true" >> $GITHUB_OUTPUT
            echo "Plans are consistent"
          else
            echo "matches=false" >> $GITHUB_OUTPUT
            echo "::warning::Plans differ - state may have drifted since dev validation"
            # Don't fail - but log the warning
          fi

      - name: Upload Prod Plan
        uses: actions/upload-artifact@v4
        with:
          name: prod-plan-artifacts
          path: |
            ${{ env.TF_WORKING_DIR }}/prod-plan.json
          retention-days: 7

  prod-terraform-apply:
    name: '[PROD] Terraform Apply'
    runs-on: ubuntu-latest
    needs: [preflight, prod-terraform-plan-verify]
    if: needs.preflight.outputs.should_run_prod == 'true'
    outputs:
      apply_status: ${{ steps.apply.outputs.status }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Restore Plugin Cache
        uses: actions/cache@v4
        with:
          path: ${{ env.TF_PLUGIN_CACHE_DIR }}
          key: terraform-providers-${{ runner.os }}-${{ hashFiles('**/.terraform.lock.hcl') }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: terraform-prod-apply-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Terraform Init
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform init -input=false

      - name: Terraform Apply
        id: apply
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "============================================"
          echo "PRODUCTION TERRAFORM APPLY"
          echo "============================================"

          terraform apply \
            -input=false \
            -auto-approve \
            2>&1 | tee apply_output.txt

          if [ ${PIPESTATUS[0]} -eq 0 ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "Apply completed successfully"
          else
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "::error::Terraform apply failed"
            exit 1
          fi

      - name: Capture Terraform Outputs
        if: steps.apply.outputs.status == 'success'
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          terraform output -json > terraform_outputs.json

      - name: Upload Apply Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: prod-apply-artifacts
          path: |
            ${{ env.TF_WORKING_DIR }}/apply_output.txt
            ${{ env.TF_WORKING_DIR }}/terraform_outputs.json
          retention-days: 30

  prod-post-deployment-verify:
    name: '[PROD] Post-Deployment Verification'
    runs-on: ubuntu-latest
    needs: [preflight, prod-terraform-apply]
    if: needs.preflight.outputs.should_run_prod == 'true' && needs.prod-terraform-apply.outputs.apply_status == 'success'
    outputs:
      verification_status: ${{ steps.verify.outputs.status }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: terraform-prod-verify-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Terraform Init
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform init -input=false

      - name: Verify State Consistency
        id: verify
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "Running terraform plan to verify no drift..."
          terraform plan -detailed-exitcode -input=false 2>&1 | tee verify_output.txt
          EXITCODE=${PIPESTATUS[0]}

          if [ $EXITCODE -eq 0 ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "State is consistent - no drift detected"
          elif [ $EXITCODE -eq 2 ]; then
            echo "status=drift" >> $GITHUB_OUTPUT
            echo "::warning::Drift detected after apply - investigation required"
          else
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "::error::Verification failed"
          fi

      - name: Upload Verification Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: prod-verification-artifacts
          path: |
            ${{ env.TF_WORKING_DIR }}/verify_output.txt
          retention-days: 30

  # ============================================================================
  # STAGE 5: DEPLOYMENT REPORT
  # ============================================================================

  deployment-report:
    name: '[REPORT] Deployment Summary'
    runs-on: ubuntu-latest
    needs: [
      preflight,
      dev-validation-verdict,
      prod-terraform-apply,
      prod-post-deployment-verify
    ]
    if: always()
    steps:
      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
        continue-on-error: true

      - name: Generate Deployment Report
        run: |
          echo "# Terraform Deployment Report" > report.md
          echo "" >> report.md
          echo "**Run ID:** ${{ github.run_id }}" >> report.md
          echo "**Commit:** ${{ github.sha }}" >> report.md
          echo "**Branch:** ${{ github.ref_name }}" >> report.md
          echo "**Triggered by:** ${{ github.actor }}" >> report.md
          echo "**Event:** ${{ github.event_name }}" >> report.md
          echo "" >> report.md

          echo "## Stage Results" >> report.md
          echo "" >> report.md
          echo "| Stage | Status |" >> report.md
          echo "|-------|--------|" >> report.md
          echo "| DEV Validation | ${{ needs.dev-validation-verdict.outputs.verdict || 'N/A' }} |" >> report.md
          echo "| PROD Apply | ${{ needs.prod-terraform-apply.outputs.apply_status || 'N/A' }} |" >> report.md
          echo "| Post-Deploy Verify | ${{ needs.prod-post-deployment-verify.outputs.verification_status || 'N/A' }} |" >> report.md
          echo "" >> report.md

          if [[ "${{ needs.prod-terraform-apply.outputs.apply_status }}" == "success" ]]; then
            echo "## Deployment Status: SUCCESS" >> report.md
            echo "" >> report.md
            echo "Production infrastructure has been successfully updated." >> report.md
          elif [[ "${{ needs.dev-validation-verdict.outputs.verdict }}" == "FAIL" ]]; then
            echo "## Deployment Status: BLOCKED" >> report.md
            echo "" >> report.md
            echo "Production deployment was blocked due to DEV validation failures." >> report.md
          else
            echo "## Deployment Status: NOT EXECUTED" >> report.md
            echo "" >> report.md
            echo "Production deployment was not executed in this run." >> report.md
          fi

          cat report.md >> $GITHUB_STEP_SUMMARY

      - name: Upload Deployment Report
        uses: actions/upload-artifact@v4
        with:
          name: deployment-report
          path: report.md
          retention-days: 90
