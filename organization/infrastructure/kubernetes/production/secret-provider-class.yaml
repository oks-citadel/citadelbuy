# Azure Key Vault Provider for Secrets Store CSI Driver
# This provides an alternative to External Secrets Operator using CSI Driver
#
# IMPORTANT: This is an OPTIONAL alternative secret management approach.
# Primary deployment uses AWS Secrets Manager via Kubernetes secrets.
# Use this only if migrating to Azure or for hybrid cloud deployments.
#
# Prerequisites:
#   1. Secrets Store CSI Driver installed:
#      helm repo add secrets-store-csi-driver https://kubernetes-sigs.github.io/secrets-store-csi-driver/charts
#      helm install csi-secrets-store secrets-store-csi-driver/secrets-store-csi-driver --namespace kube-system
#
#   2. Azure Key Vault Provider installed:
#      helm repo add csi-secrets-store-provider-azure https://azure.github.io/secrets-store-csi-driver-provider-azure/charts
#      helm install csi-secrets-store-provider-azure csi-secrets-store-provider-azure/csi-secrets-store-provider-azure --namespace kube-system
#
#   3. Workload Identity configured for AKS
#
# Configuration Required (replace placeholder values):
#   - MANAGED_IDENTITY_CLIENT_ID: Azure Managed Identity Client ID
#   - AZURE_TENANT_ID: Azure Active Directory Tenant ID
#
# Usage:
#   # First, replace placeholders with actual values using envsubst or sed
#   envsubst < secret-provider-class.yaml | kubectl apply -f -
#
# Last Updated: 2026-01-04

---
# SecretProviderClass for Authentication & Session Secrets
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: broxiva-auth-secrets-csi
  namespace: broxiva
  labels:
    environment: production
    app: broxiva
    category: authentication
spec:
  provider: azure
  parameters:
    # Use workload identity for authentication
    usePodIdentity: "false"
    useVMManagedIdentity: "false"
    clientID: "${AZURE_MANAGED_IDENTITY_CLIENT_ID}"

    # Key Vault details
    keyvaultName: "broxiva-production-kv"
    tenantId: "${AZURE_TENANT_ID}"

    # Objects to sync from Key Vault
    objects: |
      array:
        - |
          objectName: jwt-access-secret
          objectType: secret
          objectAlias: JWT_SECRET
        - |
          objectName: jwt-refresh-secret
          objectType: secret
          objectAlias: JWT_REFRESH_SECRET
        - |
          objectName: session-secret
          objectType: secret
          objectAlias: SESSION_SECRET
        - |
          objectName: encryption-key
          objectType: secret
          objectAlias: ENCRYPTION_KEY
        - |
          objectName: kyc-encryption-key
          objectType: secret
          objectAlias: KYC_ENCRYPTION_KEY

  # Create Kubernetes secret from the CSI volume
  secretObjects:
    - secretName: broxiva-auth-secrets
      type: Opaque
      labels:
        environment: production
        app: broxiva
      data:
        - objectName: JWT_SECRET
          key: JWT_SECRET
        - objectName: JWT_REFRESH_SECRET
          key: JWT_REFRESH_SECRET
        - objectName: SESSION_SECRET
          key: SESSION_SECRET
        - objectName: ENCRYPTION_KEY
          key: ENCRYPTION_KEY
        - objectName: KYC_ENCRYPTION_KEY
          key: KYC_ENCRYPTION_KEY

---
# SecretProviderClass for Database Secrets
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: broxiva-database-secrets-csi
  namespace: broxiva
  labels:
    environment: production
    app: broxiva
    category: database
spec:
  provider: azure
  parameters:
    usePodIdentity: "false"
    useVMManagedIdentity: "false"
    clientID: "${AZURE_MANAGED_IDENTITY_CLIENT_ID}"
    keyvaultName: "broxiva-production-kv"
    tenantId: "${AZURE_TENANT_ID}"
    objects: |
      array:
        - |
          objectName: postgres-password
          objectType: secret
          objectAlias: POSTGRES_PASSWORD
        - |
          objectName: postgres-url
          objectType: secret
          objectAlias: DATABASE_URL

  secretObjects:
    - secretName: broxiva-database-secrets
      type: Opaque
      labels:
        environment: production
        app: broxiva
      data:
        - objectName: POSTGRES_PASSWORD
          key: POSTGRES_PASSWORD
        - objectName: DATABASE_URL
          key: DATABASE_URL

---
# SecretProviderClass for Cache/Redis Secrets
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: broxiva-cache-secrets-csi
  namespace: broxiva
  labels:
    environment: production
    app: broxiva
    category: cache
spec:
  provider: azure
  parameters:
    usePodIdentity: "false"
    useVMManagedIdentity: "false"
    clientID: "${AZURE_MANAGED_IDENTITY_CLIENT_ID}"
    keyvaultName: "broxiva-production-kv"
    tenantId: "${AZURE_TENANT_ID}"
    objects: |
      array:
        - |
          objectName: redis-password
          objectType: secret
          objectAlias: REDIS_PASSWORD
        - |
          objectName: redis-url
          objectType: secret
          objectAlias: REDIS_URL

  secretObjects:
    - secretName: broxiva-cache-secrets
      type: Opaque
      labels:
        environment: production
        app: broxiva
      data:
        - objectName: REDIS_PASSWORD
          key: REDIS_PASSWORD
        - objectName: REDIS_URL
          key: REDIS_URL

---
# SecretProviderClass for Payment Secrets
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: broxiva-payment-secrets-csi
  namespace: broxiva
  labels:
    environment: production
    app: broxiva
    category: payment
spec:
  provider: azure
  parameters:
    usePodIdentity: "false"
    useVMManagedIdentity: "false"
    clientID: "${AZURE_MANAGED_IDENTITY_CLIENT_ID}"
    keyvaultName: "broxiva-production-kv"
    tenantId: "${AZURE_TENANT_ID}"
    objects: |
      array:
        - |
          objectName: stripe-secret-key
          objectType: secret
          objectAlias: STRIPE_SECRET_KEY
        - |
          objectName: stripe-webhook-secret
          objectType: secret
          objectAlias: STRIPE_WEBHOOK_SECRET

  secretObjects:
    - secretName: broxiva-payment-secrets
      type: Opaque
      labels:
        environment: production
        app: broxiva
      data:
        - objectName: STRIPE_SECRET_KEY
          key: STRIPE_SECRET_KEY
        - objectName: STRIPE_WEBHOOK_SECRET
          key: STRIPE_WEBHOOK_SECRET

---
# SecretProviderClass for All Secrets Combined
# Use this if you want to mount all secrets in a single volume
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: broxiva-all-secrets-csi
  namespace: broxiva
  labels:
    environment: production
    app: broxiva
    category: all
spec:
  provider: azure
  parameters:
    usePodIdentity: "false"
    useVMManagedIdentity: "false"
    clientID: "${AZURE_MANAGED_IDENTITY_CLIENT_ID}"
    keyvaultName: "broxiva-production-kv"
    tenantId: "${AZURE_TENANT_ID}"
    objects: |
      array:
        # Authentication
        - |
          objectName: jwt-access-secret
          objectType: secret
          objectAlias: JWT_SECRET
        - |
          objectName: jwt-refresh-secret
          objectType: secret
          objectAlias: JWT_REFRESH_SECRET
        - |
          objectName: session-secret
          objectType: secret
          objectAlias: SESSION_SECRET
        - |
          objectName: encryption-key
          objectType: secret
          objectAlias: ENCRYPTION_KEY
        - |
          objectName: kyc-encryption-key
          objectType: secret
          objectAlias: KYC_ENCRYPTION_KEY
        # Database
        - |
          objectName: postgres-password
          objectType: secret
          objectAlias: POSTGRES_PASSWORD
        - |
          objectName: postgres-url
          objectType: secret
          objectAlias: DATABASE_URL
        # Cache
        - |
          objectName: redis-password
          objectType: secret
          objectAlias: REDIS_PASSWORD
        - |
          objectName: redis-url
          objectType: secret
          objectAlias: REDIS_URL
        # Payment
        - |
          objectName: stripe-secret-key
          objectType: secret
          objectAlias: STRIPE_SECRET_KEY
        - |
          objectName: stripe-webhook-secret
          objectType: secret
          objectAlias: STRIPE_WEBHOOK_SECRET
        # Email
        - |
          objectName: sendgrid-api-key
          objectType: secret
          objectAlias: SENDGRID_API_KEY
        # AI
        - |
          objectName: openai-api-key
          objectType: secret
          objectAlias: OPENAI_API_KEY
        # Internal
        - |
          objectName: internal-api-key
          objectType: secret
          objectAlias: INTERNAL_API_KEY

  secretObjects:
    - secretName: broxiva-secrets
      type: Opaque
      labels:
        environment: production
        app: broxiva
      data:
        - objectName: JWT_SECRET
          key: JWT_SECRET
        - objectName: JWT_REFRESH_SECRET
          key: JWT_REFRESH_SECRET
        - objectName: SESSION_SECRET
          key: SESSION_SECRET
        - objectName: ENCRYPTION_KEY
          key: ENCRYPTION_KEY
        - objectName: KYC_ENCRYPTION_KEY
          key: KYC_ENCRYPTION_KEY
        - objectName: POSTGRES_PASSWORD
          key: POSTGRES_PASSWORD
        - objectName: DATABASE_URL
          key: DATABASE_URL
        - objectName: REDIS_PASSWORD
          key: REDIS_PASSWORD
        - objectName: REDIS_URL
          key: REDIS_URL
        - objectName: STRIPE_SECRET_KEY
          key: STRIPE_SECRET_KEY
        - objectName: STRIPE_WEBHOOK_SECRET
          key: STRIPE_WEBHOOK_SECRET
        - objectName: SENDGRID_API_KEY
          key: SENDGRID_API_KEY
        - objectName: OPENAI_API_KEY
          key: OPENAI_API_KEY
        - objectName: INTERNAL_API_KEY
          key: INTERNAL_API_KEY

---
# Example Deployment using CSI Driver
# This shows how to mount secrets from Azure Key Vault using CSI Driver
apiVersion: apps/v1
kind: Deployment
metadata:
  name: broxiva-api-csi-example
  namespace: broxiva
  labels:
    app: broxiva-api
    secrets-method: csi-driver
spec:
  replicas: 3
  selector:
    matchLabels:
      app: broxiva-api
  template:
    metadata:
      labels:
        app: broxiva-api
        azure.workload.identity/use: "true"
    spec:
      serviceAccountName: broxiva-external-secrets-sa
      containers:
        - name: api
          # Image tag is updated dynamically during deployment via kubectl set image
          image: 992382449461.dkr.ecr.us-east-1.amazonaws.com/broxiva/api:${IMAGE_TAG:-latest}
          ports:
            - containerPort: 4000
              name: http

          # Option 1: Mount secrets as files
          volumeMounts:
            - name: secrets-store
              mountPath: "/mnt/secrets"
              readOnly: true

          # Option 2: Use envFrom to load secrets from the created Kubernetes secret
          envFrom:
            - secretRef:
                name: broxiva-secrets

          # Option 3: Load individual environment variables from files
          env:
            - name: JWT_SECRET
              valueFrom:
                secretKeyRef:
                  name: broxiva-secrets
                  key: JWT_SECRET

          resources:
            requests:
              memory: "256Mi"
              cpu: "250m"
            limits:
              memory: "512Mi"
              cpu: "500m"

      volumes:
        - name: secrets-store
          csi:
            driver: secrets-store.csi.k8s.io
            readOnly: true
            volumeAttributes:
              secretProviderClass: "broxiva-all-secrets-csi"
            nodePublishSecretRef:
              name: broxiva-external-secrets-sa

---
# Comparison: External Secrets Operator vs CSI Driver
#
# External Secrets Operator (ESO):
# Pros:
#   - Automatic sync on schedule (e.g., every 1 hour)
#   - Secrets stored as Kubernetes secrets (can be used by any pod)
#   - Better for multiple pods accessing same secrets
#   - Easier to manage and troubleshoot
#   - Works well with GitOps (ArgoCD, Flux)
#
# Cons:
#   - Requires External Secrets Operator to be installed
#   - Secrets are stored in etcd (encrypted at rest)
#   - Additional component to maintain
#
# CSI Driver:
# Pros:
#   - Secrets never stored in Kubernetes etcd (more secure)
#   - Mounted directly from Key Vault to pod
#   - No additional operator required (uses native CSI)
#   - Secrets are ephemeral (removed when pod terminates)
#
# Cons:
#   - Secrets only available to pods with the volume mount
#   - More complex configuration
#   - Each pod needs to mount the volume
#   - Requires CSI driver installation
#
# Recommendation:
#   - Use External Secrets Operator for most cases (easier, better for GitOps)
#   - Use CSI Driver for highly sensitive secrets that should never touch etcd
#   - Can use both: ESO for regular secrets, CSI for critical encryption keys
