# ==================================
# CitadelBuy - Deployment Pipeline for Azure DevOps
# Multi-stage deployment with approval gates
# ==================================

name: Deploy-$(Date:yyyyMMdd)$(Rev:.r)

trigger:
  branches:
    include:
      - main
  paths:
    exclude:
      - '**.md'
      - 'docs/**'

pr: none

variables:
  - template: variables/common.yml
  - name: SHORT_SHA
    value: $[format('{0}', substring(variables['Build.SourceVersion'], 0, 7))]

stages:
  # ==================================
  # STAGE 1: BUILD DOCKER IMAGES
  # ==================================
  - stage: BuildImages
    displayName: 'Build Docker Images'
    jobs:
      - job: BuildAPI
        displayName: 'Build API Image'
        pool:
          vmImage: $(AGENT_VM_IMAGE)
        steps:
          - checkout: self
            clean: true

          - template: templates/build-app.yml
            parameters:
              appName: 'api'
              dockerfilePath: 'apps/api/Dockerfile'
              dockerContext: 'apps/api'
              imageName: 'citadelbuy-api'

      - job: BuildWeb
        displayName: 'Build Web Image'
        pool:
          vmImage: $(AGENT_VM_IMAGE)
        steps:
          - checkout: self
            clean: true

          - template: templates/build-app.yml
            parameters:
              appName: 'web'
              dockerfilePath: 'apps/web/Dockerfile'
              dockerContext: 'apps/web'
              imageName: 'citadelbuy-web'
              buildArgs: |
                NEXT_PUBLIC_API_URL=$(STAGING_API_URL)

      - job: BuildSupplierIntegration
        displayName: 'Build Supplier Integration Image'
        pool:
          vmImage: $(AGENT_VM_IMAGE)
        steps:
          - checkout: self
            clean: true

          - template: templates/build-app.yml
            parameters:
              appName: 'supplier-integration'
              dockerfilePath: 'apps/services/supplier-integration/Dockerfile'
              dockerContext: 'apps/services/supplier-integration'
              imageName: 'citadelbuy-supplier-integration'

      - job: BuildAIEngine
        displayName: 'Build AI Engine Image'
        pool:
          vmImage: $(AGENT_VM_IMAGE)
        steps:
          - checkout: self
            clean: true

          - template: templates/build-app.yml
            parameters:
              appName: 'ai-engine'
              dockerfilePath: 'apps/services/ai-engine/Dockerfile'
              dockerContext: 'apps/services/ai-engine'
              imageName: 'citadelbuy-ai-engine'

  # ==================================
  # STAGE 2: DEPLOY TO STAGING
  # ==================================
  - stage: DeployStaging
    displayName: 'Deploy to Staging'
    dependsOn: BuildImages
    condition: succeeded()
    variables:
      - template: variables/staging.yml
    jobs:
      - deployment: DeployToStaging
        displayName: 'Deploy All Services to Staging'
        pool:
          vmImage: $(AGENT_VM_IMAGE)
        environment: 'staging'
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self

                - task: KubectlInstaller@0
                  displayName: 'Install kubectl'
                  inputs:
                    kubectlVersion: 'latest'

                - task: AzureCLI@2
                  displayName: 'Get AKS credentials'
                  inputs:
                    azureSubscription: '$(AZURE_SERVICE_CONNECTION)'
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      az aks get-credentials \
                        --resource-group $(AKS_RESOURCE_GROUP) \
                        --name $(AKS_CLUSTER_NAME) \
                        --overwrite-existing

                - template: templates/deploy-k8s.yml
                  parameters:
                    environment: 'staging'
                    namespace: $(K8S_NAMESPACE)
                    apiImageTag: '$(SHORT_SHA)'
                    webImageTag: '$(SHORT_SHA)'

                - script: |
                    echo "Waiting for deployments to stabilize..."
                    kubectl rollout status deployment/api -n $(K8S_NAMESPACE) --timeout=300s
                    kubectl rollout status deployment/web -n $(K8S_NAMESPACE) --timeout=300s
                    kubectl rollout status deployment/supplier-integration -n $(K8S_NAMESPACE) --timeout=300s
                    kubectl rollout status deployment/ai-engine -n $(K8S_NAMESPACE) --timeout=300s
                  displayName: 'Wait for rollout completion'

                - script: |
                    POD=$(kubectl get pod -n $(K8S_NAMESPACE) -l app=api -o jsonpath='{.items[0].metadata.name}')
                    kubectl exec -n $(K8S_NAMESPACE) $POD -- npx prisma migrate deploy
                  displayName: 'Run database migrations'

                - script: |
                    echo "Running health checks..."
                    curl -f $(STAGING_WEB_URL)/api/health || exit 1
                    echo "Health checks passed!"
                  displayName: 'Health check'

      - job: StagingSmokeTests
        displayName: 'Run Smoke Tests'
        dependsOn: DeployToStaging
        pool:
          vmImage: $(AGENT_VM_IMAGE)
        steps:
          - checkout: self

          - task: NodeTool@0
            displayName: 'Setup Node.js'
            inputs:
              versionSpec: $(NODE_VERSION)

          - script: |
              npm install -g pnpm@$(PNPM_VERSION)
              pnpm install --frozen-lockfile
            displayName: 'Install dependencies'

          - script: |
              echo "Running smoke tests against staging..."
              curl -f $(STAGING_WEB_URL)/api/health || exit 1
              curl -f $(STAGING_WEB_URL) || exit 1
              echo "Smoke tests passed!"
            displayName: 'Execute smoke tests'

  # ==================================
  # STAGE 3: DEPLOY TO PRODUCTION
  # ==================================
  - stage: DeployProduction
    displayName: 'Deploy to Production'
    dependsOn: DeployStaging
    condition: succeeded()
    variables:
      - template: variables/prod.yml
    jobs:
      - deployment: DeployToProduction
        displayName: 'Deploy All Services to Production'
        pool:
          vmImage: $(AGENT_VM_IMAGE)
        environment: 'production'
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self

                - task: KubectlInstaller@0
                  displayName: 'Install kubectl'
                  inputs:
                    kubectlVersion: 'latest'

                - task: AzureCLI@2
                  displayName: 'Get AKS credentials'
                  inputs:
                    azureSubscription: '$(AZURE_SERVICE_CONNECTION)'
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      az aks get-credentials \
                        --resource-group $(AKS_RESOURCE_GROUP) \
                        --name $(AKS_CLUSTER_NAME) \
                        --overwrite-existing

                - script: |
                    echo "Creating backup of current deployment..."
                    kubectl get deployment api -n $(K8S_NAMESPACE) -o yaml > api-backup.yaml
                    kubectl get deployment web -n $(K8S_NAMESPACE) -o yaml > web-backup.yaml
                  displayName: 'Backup current deployment'

                - template: templates/deploy-k8s.yml
                  parameters:
                    environment: 'production'
                    namespace: $(K8S_NAMESPACE)
                    apiImageTag: '$(SHORT_SHA)'
                    webImageTag: '$(SHORT_SHA)'

                - script: |
                    echo "Waiting for deployments to stabilize..."
                    kubectl rollout status deployment/api -n $(K8S_NAMESPACE) --timeout=600s
                    kubectl rollout status deployment/web -n $(K8S_NAMESPACE) --timeout=600s
                    kubectl rollout status deployment/supplier-integration -n $(K8S_NAMESPACE) --timeout=300s
                    kubectl rollout status deployment/ai-engine -n $(K8S_NAMESPACE) --timeout=300s
                  displayName: 'Wait for rollout completion'

                - script: |
                    POD=$(kubectl get pod -n $(K8S_NAMESPACE) -l app=api -o jsonpath='{.items[0].metadata.name}')
                    kubectl exec -n $(K8S_NAMESPACE) $POD -- npx prisma migrate deploy
                  displayName: 'Run database migrations'

                - script: |
                    echo "Running production health checks..."
                    sleep 30
                    curl -f $(PRODUCTION_WEB_URL)/api/health || exit 1
                    curl -f $(PRODUCTION_WEB_URL) || exit 1
                    echo "Production health checks passed!"
                  displayName: 'Production health check'

                - script: |
                    echo "Deployment completed successfully!"
                    echo "Version: $(SHORT_SHA)"
                    echo "Environment: Production"
                  displayName: 'Deployment summary'

      - job: NotifyDeployment
        displayName: 'Notify Deployment'
        dependsOn: DeployToProduction
        condition: succeeded()
        pool:
          vmImage: $(AGENT_VM_IMAGE)
        steps:
          - script: |
              curl -X POST $(SLACK_WEBHOOK_URL) \
                -H 'Content-Type: application/json' \
                -d '{
                  "text": "üöÄ CitadelBuy Production Deployment Completed",
                  "blocks": [
                    {
                      "type": "header",
                      "text": {
                        "type": "plain_text",
                        "text": "‚úÖ Production Deployment Successful"
                      }
                    },
                    {
                      "type": "section",
                      "fields": [
                        {
                          "type": "mrkdwn",
                          "text": "*Version:*\n$(SHORT_SHA)"
                        },
                        {
                          "type": "mrkdwn",
                          "text": "*Build:*\n$(Build.BuildNumber)"
                        },
                        {
                          "type": "mrkdwn",
                          "text": "*Branch:*\n$(Build.SourceBranchName)"
                        },
                        {
                          "type": "mrkdwn",
                          "text": "*Deployed by:*\n$(Build.RequestedFor)"
                        }
                      ]
                    }
                  ]
                }'
            displayName: 'Send Slack notification'
            continueOnError: true
            env:
              SLACK_WEBHOOK_URL: $(SLACK_WEBHOOK_URL)

  # ==================================
  # STAGE 4: ROLLBACK (Manual)
  # ==================================
  - stage: Rollback
    displayName: 'Rollback Production'
    dependsOn: DeployProduction
    condition: failed()
    variables:
      - template: variables/prod.yml
    jobs:
      - job: RollbackProduction
        displayName: 'Rollback Production Deployment'
        pool:
          vmImage: $(AGENT_VM_IMAGE)
        steps:
          - checkout: self

          - task: KubectlInstaller@0
            displayName: 'Install kubectl'
            inputs:
              kubectlVersion: 'latest'

          - task: AzureCLI@2
            displayName: 'Get AKS credentials'
            inputs:
              azureSubscription: '$(AZURE_SERVICE_CONNECTION)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                az aks get-credentials \
                  --resource-group $(AKS_RESOURCE_GROUP) \
                  --name $(AKS_CLUSTER_NAME) \
                  --overwrite-existing

          - script: |
              echo "Rolling back deployment..."
              kubectl rollout undo deployment/api -n $(K8S_NAMESPACE)
              kubectl rollout undo deployment/web -n $(K8S_NAMESPACE)
              kubectl rollout undo deployment/supplier-integration -n $(K8S_NAMESPACE)
              kubectl rollout undo deployment/ai-engine -n $(K8S_NAMESPACE)

              echo "Waiting for rollback to complete..."
              kubectl rollout status deployment/api -n $(K8S_NAMESPACE) --timeout=300s
              kubectl rollout status deployment/web -n $(K8S_NAMESPACE) --timeout=300s
            displayName: 'Execute rollback'

          - script: |
              echo "Verifying rollback..."
              curl -f $(PRODUCTION_WEB_URL)/api/health || exit 1
              echo "Rollback completed successfully!"
            displayName: 'Verify rollback'

          - script: |
              curl -X POST $(SLACK_WEBHOOK_URL) \
                -H 'Content-Type: application/json' \
                -d '{
                  "text": "‚ö†Ô∏è CitadelBuy Production Rollback Executed",
                  "blocks": [
                    {
                      "type": "header",
                      "text": {
                        "type": "plain_text",
                        "text": "‚ö†Ô∏è Production Rollback"
                      }
                    },
                    {
                      "type": "section",
                      "text": {
                        "type": "mrkdwn",
                        "text": "Production deployment failed and was rolled back.\n*Build:* $(Build.BuildNumber)\n*Branch:* $(Build.SourceBranchName)"
                      }
                    }
                  ]
                }'
            displayName: 'Notify rollback'
            continueOnError: true
            env:
              SLACK_WEBHOOK_URL: $(SLACK_WEBHOOK_URL)
