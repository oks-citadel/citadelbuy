# CitadelBuy - Staging Deployment Pipeline
# Converted from GitHub Actions staging-deployment.yml
# Comprehensive staging deployment with smoke tests and notifications

trigger:
  branches:
    include:
      - main
      - develop

pr: none

parameters:
  - name: skipTests
    displayName: 'Skip running tests'
    type: boolean
    default: false
  - name: skipSmokeTests
    displayName: 'Skip smoke tests after deployment'
    type: boolean
    default: false

variables:
  - name: REGISTRY
    value: 'ghcr.io'
  - name: IMAGE_NAME
    value: 'citadelplatforms/citadelbuy'
  - name: K8S_NAMESPACE
    value: 'citadelbuy-staging'
  - name: NODE_VERSION
    value: '20'
  - name: PNPM_VERSION
    value: '8'

stages:
  # ============================================
  # STAGE 1: Lint and Test
  # ============================================
  - stage: LintAndTest
    displayName: 'Lint and Test'
    condition: and(succeeded(), eq('${{ parameters.skipTests }}', 'false'))
    jobs:
      - job: LintTest
        displayName: 'Run Linting and Tests'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
            displayName: 'Checkout code'

          - task: NodeTool@0
            displayName: 'Setup Node.js $(NODE_VERSION)'
            inputs:
              versionSpec: '$(NODE_VERSION)'

          - script: |
              npm install -g pnpm@$(PNPM_VERSION)
            displayName: 'Setup pnpm'

          - script: |
              pnpm install --frozen-lockfile
            displayName: 'Install dependencies'

          - script: |
              pnpm run lint
            displayName: 'Run linting'

          - script: |
              pnpm run type-check
            displayName: 'Run type checking'

          - script: |
              pnpm run test
            displayName: 'Run unit tests'

  # ============================================
  # STAGE 2: Build Docker Images
  # ============================================
  - stage: BuildImages
    displayName: 'Build Docker Images'
    dependsOn: LintAndTest
    condition: |
      or(
        and(succeeded(), eq('${{ parameters.skipTests }}', 'false')),
        and(skipped(), eq('${{ parameters.skipTests }}', 'true'))
      )
    jobs:
      - job: BuildAndPushImages
        displayName: 'Build and Push Docker Images'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
            displayName: 'Checkout code'

          - task: Docker@2
            displayName: 'Login to GitHub Container Registry'
            inputs:
              command: 'login'
              containerRegistry: 'GitHubContainerRegistry'

          - bash: |
              SHA=$(echo $(Build.SourceVersion) | cut -c1-7)
              BRANCH=$(echo $(Build.SourceBranchName) | tr '/' '-')
              echo "##vso[task.setvariable variable=SHA_TAG]$SHA"
              echo "##vso[task.setvariable variable=BRANCH_TAG]$BRANCH"
            displayName: 'Generate image tags'

          - task: Docker@2
            displayName: 'Build and push API image'
            inputs:
              command: 'buildAndPush'
              repository: '$(REGISTRY)/$(IMAGE_NAME)-api'
              dockerfile: '$(System.DefaultWorkingDirectory)/apps/api/Dockerfile'
              buildContext: '$(System.DefaultWorkingDirectory)/apps/api'
              tags: |
                staging-$(SHA_TAG)
                staging-latest
                staging-$(BRANCH_TAG)
              arguments: |
                --build-arg NODE_ENV=staging
                --build-arg BUILD_DATE=$(Build.BuildNumber)
                --build-arg VCS_REF=$(Build.SourceVersion)

          - task: Docker@2
            displayName: 'Build and push Web image'
            inputs:
              command: 'buildAndPush'
              repository: '$(REGISTRY)/$(IMAGE_NAME)-web'
              dockerfile: '$(System.DefaultWorkingDirectory)/apps/web/Dockerfile'
              buildContext: '$(System.DefaultWorkingDirectory)/apps/web'
              tags: |
                staging-$(SHA_TAG)
                staging-latest
                staging-$(BRANCH_TAG)
              arguments: |
                --build-arg NODE_ENV=staging
                --build-arg NEXT_PUBLIC_API_URL=$(STAGING_API_URL)
                --build-arg BUILD_DATE=$(Build.BuildNumber)
                --build-arg VCS_REF=$(Build.SourceVersion)

          - bash: |
              echo "API Image Digest: $API_DIGEST"
              echo "Web Image Digest: $WEB_DIGEST"
            displayName: 'Display image digests'

  # ============================================
  # STAGE 3: Deploy to Staging
  # ============================================
  - stage: DeployStaging
    displayName: 'Deploy to Staging'
    dependsOn: BuildImages
    condition: succeeded()
    jobs:
      - deployment: DeployToStaging
        displayName: 'Deploy to Staging Environment'
        pool:
          vmImage: 'ubuntu-latest'
        environment: 'staging'
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                  displayName: 'Checkout code'

                - task: KubernetesManifest@0
                  displayName: 'Setup kubectl'
                  inputs:
                    action: 'deploy'
                    kubernetesServiceConnection: 'Kubernetes-Staging'
                    namespace: '$(K8S_NAMESPACE)'

                - bash: |
                    kubectl cluster-info
                    kubectl get nodes
                  displayName: 'Verify cluster connection'

                - bash: |
                    kubectl create namespace $(K8S_NAMESPACE) --dry-run=client -o yaml | kubectl apply -f -
                  displayName: 'Create namespace if not exists'

                - task: KubernetesManifest@0
                  displayName: 'Apply Kubernetes configurations'
                  inputs:
                    action: 'deploy'
                    kubernetesServiceConnection: 'Kubernetes-Staging'
                    namespace: '$(K8S_NAMESPACE)'
                    manifests: |
                      infrastructure/kubernetes/staging/namespace.yaml
                      infrastructure/kubernetes/staging/configmap.yaml

                - bash: |
                    # Only update if secrets have changed
                    if kubectl get secret citadelbuy-secrets -n $(K8S_NAMESPACE) &> /dev/null; then
                      echo "Secrets already exist, skipping creation"
                    else
                      echo "Creating secrets..."
                      kubectl create secret generic citadelbuy-secrets \
                        --namespace=$(K8S_NAMESPACE) \
                        --from-literal=DATABASE_URL="$(STAGING_DATABASE_URL)" \
                        --from-literal=POSTGRES_PASSWORD="$(STAGING_POSTGRES_PASSWORD)" \
                        --from-literal=JWT_SECRET="$(STAGING_JWT_SECRET)" \
                        --from-literal=JWT_REFRESH_SECRET="$(STAGING_JWT_REFRESH_SECRET)" \
                        --from-literal=STRIPE_SECRET_KEY="$(STAGING_STRIPE_SECRET_KEY)" \
                        --from-literal=SENDGRID_API_KEY="$(STAGING_SENDGRID_API_KEY)"
                    fi
                  displayName: 'Update secrets (if changed)'

                - task: KubernetesManifest@0
                  displayName: 'Deploy database services'
                  inputs:
                    action: 'deploy'
                    kubernetesServiceConnection: 'Kubernetes-Staging'
                    namespace: '$(K8S_NAMESPACE)'
                    manifests: |
                      infrastructure/kubernetes/staging/postgres-deployment.yaml
                      infrastructure/kubernetes/staging/redis-deployment.yaml

                - bash: |
                    kubectl wait --for=condition=ready pod \
                      -l app=postgres \
                      -n $(K8S_NAMESPACE) \
                      --timeout=300s
                  displayName: 'Wait for database to be ready'

                - task: KubernetesManifest@0
                  displayName: 'Deploy application services'
                  inputs:
                    action: 'deploy'
                    kubernetesServiceConnection: 'Kubernetes-Staging'
                    namespace: '$(K8S_NAMESPACE)'
                    manifests: |
                      infrastructure/kubernetes/staging/api-deployment.yaml
                      infrastructure/kubernetes/staging/web-deployment.yaml

                - bash: |
                    SHA=$(echo $(Build.SourceVersion) | cut -c1-7)
                    kubectl set image deployment/citadelbuy-api \
                      api=$(REGISTRY)/$(IMAGE_NAME)-api:staging-${SHA} \
                      -n $(K8S_NAMESPACE)
                    kubectl set image deployment/citadelbuy-web \
                      web=$(REGISTRY)/$(IMAGE_NAME)-web:staging-${SHA} \
                      -n $(K8S_NAMESPACE)
                  displayName: 'Update deployment images'

                - task: KubernetesManifest@0
                  displayName: 'Apply ingress and HPA'
                  inputs:
                    action: 'deploy'
                    kubernetesServiceConnection: 'Kubernetes-Staging'
                    namespace: '$(K8S_NAMESPACE)'
                    manifests: |
                      infrastructure/kubernetes/staging/ingress.yaml
                      infrastructure/kubernetes/staging/hpa.yaml

                - bash: |
                    kubectl rollout status deployment/citadelbuy-api \
                      -n $(K8S_NAMESPACE) \
                      --timeout=300s
                  displayName: 'Wait for API rollout'

                - bash: |
                    kubectl rollout status deployment/citadelbuy-web \
                      -n $(K8S_NAMESPACE) \
                      --timeout=300s
                  displayName: 'Wait for Web rollout'

                - bash: |
                    API_POD=$(kubectl get pods -n $(K8S_NAMESPACE) \
                      -l app=citadelbuy-api \
                      -o jsonpath='{.items[0].metadata.name}')

                    echo "Running migrations in pod: $API_POD"
                    kubectl exec -n $(K8S_NAMESPACE) $API_POD -- \
                      npx prisma migrate deploy
                  displayName: 'Run database migrations'

                - bash: |
                    kubectl get pods -n $(K8S_NAMESPACE)

                    API_READY=$(kubectl get deployment citadelbuy-api \
                      -n $(K8S_NAMESPACE) \
                      -o jsonpath='{.status.readyReplicas}')
                    API_DESIRED=$(kubectl get deployment citadelbuy-api \
                      -n $(K8S_NAMESPACE) \
                      -o jsonpath='{.status.replicas}')

                    WEB_READY=$(kubectl get deployment citadelbuy-web \
                      -n $(K8S_NAMESPACE) \
                      -o jsonpath='{.status.readyReplicas}')
                    WEB_DESIRED=$(kubectl get deployment citadelbuy-web \
                      -n $(K8S_NAMESPACE) \
                      -o jsonpath='{.status.replicas}')

                    echo "API Pods: ${API_READY}/${API_DESIRED} ready"
                    echo "Web Pods: ${WEB_READY}/${WEB_DESIRED} ready"

                    if [ "$API_READY" != "$API_DESIRED" ] || [ "$WEB_READY" != "$WEB_DESIRED" ]; then
                      echo "##vso[task.logissue type=error]Not all pods are ready"
                      exit 1
                    fi
                  displayName: 'Verify pod health'

                - bash: |
                    echo "=== Deployment Info ==="
                    kubectl get all -n $(K8S_NAMESPACE)

                    echo ""
                    echo "=== Ingress Info ==="
                    kubectl get ingress -n $(K8S_NAMESPACE)
                  displayName: 'Get deployment info'

  # ============================================
  # STAGE 4: Smoke Tests
  # ============================================
  - stage: SmokeTests
    displayName: 'Run Smoke Tests'
    dependsOn: DeployStaging
    condition: and(succeeded(), eq('${{ parameters.skipSmokeTests }}', 'false'))
    jobs:
      - job: RunSmokeTests
        displayName: 'Execute Smoke Tests'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
            displayName: 'Checkout code'

          - bash: |
              sudo apt-get update
              sudo apt-get install -y curl jq
            displayName: 'Install test dependencies'

          - bash: |
              echo "Waiting 30 seconds for services to stabilize..."
              sleep 30
            displayName: 'Wait for services to stabilize'

          - bash: |
              chmod +x scripts/smoke-tests.sh
              ./scripts/smoke-tests.sh $(K8S_NAMESPACE)
            displayName: 'Run smoke tests'
            env:
              STAGING_API_URL: $(STAGING_API_URL)
              STAGING_WEB_URL: $(STAGING_WEB_URL)

          - task: PublishPipelineArtifact@1
            displayName: 'Upload test results'
            condition: always()
            inputs:
              targetPath: 'logs/smoke-tests-*.txt'
              artifact: 'smoke-test-results'
              publishLocation: 'pipeline'

  # ============================================
  # STAGE 5: Notifications
  # ============================================
  - stage: NotifySuccess
    displayName: 'Notify Success'
    dependsOn:
      - DeployStaging
      - SmokeTests
    condition: succeeded()
    jobs:
      - job: SendNotification
        displayName: 'Send Success Notification'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: InvokeRESTAPI@1
            displayName: 'Send Slack notification'
            inputs:
              connectionType: 'connectedServiceName'
              serviceConnection: 'SlackWebhook'
              method: 'POST'
              body: |
                {
                  "text": "Staging Deployment Successful",
                  "blocks": [
                    {
                      "type": "header",
                      "text": {
                        "type": "plain_text",
                        "text": "✅ CitadelBuy - Staging Deployment"
                      }
                    },
                    {
                      "type": "section",
                      "text": {
                        "type": "mrkdwn",
                        "text": "*Status:* Deployment Successful\n*Environment:* Staging\n*Commit:* $(Build.SourceVersion)\n*Author:* $(Build.RequestedFor)\n*Branch:* $(Build.SourceBranchName)"
                      }
                    },
                    {
                      "type": "section",
                      "fields": [
                        {
                          "type": "mrkdwn",
                          "text": "*Web:*\n<https://staging.citadelbuy.com|View Staging>"
                        },
                        {
                          "type": "mrkdwn",
                          "text": "*API:*\n<https://staging-api.citadelbuy.com|View API>"
                        }
                      ]
                    },
                    {
                      "type": "section",
                      "text": {
                        "type": "mrkdwn",
                        "text": "<$(System.CollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)|View Pipeline Run>"
                      }
                    }
                  ]
                }
            continueOnError: true

  - stage: NotifyFailure
    displayName: 'Notify Failure'
    dependsOn:
      - DeployStaging
      - SmokeTests
    condition: failed()
    jobs:
      - job: SendNotification
        displayName: 'Send Failure Notification'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: InvokeRESTAPI@1
            displayName: 'Send Slack notification'
            inputs:
              connectionType: 'connectedServiceName'
              serviceConnection: 'SlackWebhook'
              method: 'POST'
              body: |
                {
                  "text": "Staging Deployment Failed",
                  "blocks": [
                    {
                      "type": "header",
                      "text": {
                        "type": "plain_text",
                        "text": "❌ CitadelBuy - Staging Deployment Failed"
                      }
                    },
                    {
                      "type": "section",
                      "text": {
                        "type": "mrkdwn",
                        "text": "*Status:* Deployment Failed\n*Environment:* Staging\n*Commit:* $(Build.SourceVersion)\n*Author:* $(Build.RequestedFor)\n*Branch:* $(Build.SourceBranchName)"
                      }
                    },
                    {
                      "type": "section",
                      "text": {
                        "type": "mrkdwn",
                        "text": "⚠️ *Action Required:* Check pipeline logs and resolve issues.\n<$(System.CollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)|View Pipeline Run>"
                      }
                    }
                  ]
                }
            continueOnError: true

          - task: CreateWorkItem@1
            displayName: 'Create work item on failure'
            inputs:
              workItemType: 'Bug'
              title: 'Staging deployment failed - $(Build.SourceVersion)'
              assignedTo: '$(Build.RequestedFor)'
              areaPath: '$(System.TeamProject)'
              iterationPath: '$(System.TeamProject)'
              fieldMappings: |
                Description=Staging deployment failed for commit $(Build.SourceVersion)<br><br>Pipeline run: <a href="$(System.CollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)">View Run</a>
              associate: true
              tags: 'deployment;staging;automated'
            continueOnError: true
